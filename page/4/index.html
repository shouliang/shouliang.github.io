<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-03T06:45:23.000Z"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">2014-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">一.简单介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是MongoDB"><a href="#1-什么是MongoDB" class="headerlink" title="1.什么是MongoDB"></a>1.什么是MongoDB</h3><hr>
<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个高性能，开源，无模式的文档型数据库，官方给自己的定义是Key-value存储(高性能和高扩展)和传统RDBMS(丰富的查询和功能)之间的一座桥梁。</p>
<h3 id="2-Document和BSON"><a href="#2-Document和BSON" class="headerlink" title="2.Document和BSON"></a>2.Document和BSON</h3><hr>
<p>MongoDB中保存的数据格式为BSON，如：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbson.jpg" alt=""></p>
<p>MongoDB中数据的基本单元称为文档(Document)，它是MongoDB的核心概念，由多个键极其关联的值有序的放置在一起组成，数据库中它对应于关系型数据库的行。</p>
<p>数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p>
<p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON，BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p>
<p>BSON的优点是灵活性高，但它的缺点是空间利用率不是很理想，BSON有三个特点：轻量性、可遍历性、高效性。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-27T12:45:23.000Z"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">2014-03-27</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">六.属性方法</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-ObjectId类型"><a href="#1-ObjectId类型" class="headerlink" title="1.ObjectId类型"></a>1.ObjectId类型</h3><hr>
<h4 id="ObjectId简述"><a href="#ObjectId简述" class="headerlink" title="ObjectId简述"></a>ObjectId简述</h4><p>存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。</p>
<p>使用过MySQL等关系型数据库的友友们都知道，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，MongoDB采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，一次代表：</p>
<p>4字节：UNIX时间戳<br>3字节：表示运行MongoDB的机器<br>2字节：表示生成此_id的进程<br>3字节：由一个随机数开始的计数器生成的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var tSchema = new mongoose.Schema(&#123;&#125;); //默认_id:ObjectId类型</span><br></pre></td></tr></table></figure></p>
<p>每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。</p>
<h3 id="2-添加属性"><a href="#2-添加属性" class="headerlink" title="2.添加属性"></a>2.添加属性</h3><hr>
<h4 id="Schema添加属性值"><a href="#Schema添加属性值" class="headerlink" title="Schema添加属性值"></a>Schema添加属性值</h4><p>前面我们已经讲述了如何定义一个Schema并赋予某些属性值,那能不能先定义后添加属性呢，答案是可以的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var TempSchema = new mongoose.Schema;</span><br><span class="line">TempSchema.add(&#123; name: &apos;String&apos;, email: &apos;String&apos;, age: &apos;Number&apos; &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3.实例方法"></a>3.实例方法</h3><hr>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var saySchema = new mongoose.Schema(&#123;name : String&#125;);</span><br><span class="line">saySchema.method(&apos;say&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;Trouble Is A Friend&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">var say = mongoose.model(&apos;say&apos;, saySchema);</span><br><span class="line">var lenka = new say();</span><br><span class="line">lenka.say(); //Trouble Is A Friend</span><br></pre></td></tr></table></figure></p>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4.静态方法"></a>4.静态方法</h3><hr>
<h4 id="Schema静态方法"><a href="#Schema静态方法" class="headerlink" title="Schema静态方法"></a>Schema静态方法</h4><p>接下来将讲述怎么为Schema创建静态方法。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); </span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.static(&apos;findByName&apos;, function (name, callback) &#123;</span><br><span class="line">    return this.find(&#123; name: name &#125;, callback);</span><br><span class="line">&#125;);</span><br><span class="line">var TestModel = db.model(&quot;test1&quot;, TestSchema );</span><br><span class="line">TestModel.findByName(&apos;tom&apos;, function (err, docs) &#123;</span><br><span class="line"> //docs所有名字叫tom的文档结果集</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-追加方法"><a href="#5-追加方法" class="headerlink" title="5.追加方法"></a>5.追加方法</h3><hr>
<h4 id="Schema追加方法"><a href="#Schema追加方法" class="headerlink" title="Schema追加方法"></a>Schema追加方法</h4><p>有时场景的需要，我们甚至可以为Schema模型追加方法。</p>
<p>为Schema模型追加speak方法，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);</span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.methods.speak = function()&#123;</span><br><span class="line">  console.log(&apos;我的名字叫&apos;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">var TestModel = db.model(&apos;test1&apos;,TestSchema);</span><br><span class="line">var TestEntity = new TestModel(&#123;name:&apos;Lenka&apos;&#125;);</span><br><span class="line">TestEntity.speak();//我的名字叫Lenka</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-22T06:45:23.000Z"><a href="/2014/03/22/Mongoose/Mongoose(5)游标/">2014-03-22</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/22/Mongoose/Mongoose(5)游标/">五.游标</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p>
<p>最常用的查询选项就是限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)。所有这些选项一点要在查询被发送到服务器之前指定。</p>
<h3 id="2-限制返回数量"><a href="#2-限制返回数量" class="headerlink" title="2.限制返回数量"></a>2.限制返回数量</h3><hr>
<h4 id="limit函数的基本用法"><a href="#limit函数的基本用法" class="headerlink" title="limit函数的基本用法"></a>limit函数的基本用法</h4><p>在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那么我们就可以使用limit函数，通过它来限制结果数量。</p>
<p>1.限制数量：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;limit:20&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果匹配的结果不到20个，则返回匹配数量的结果，也就是说limit函数指定的是上限而非下限。</p>
<h3 id="3-跳过结果数量"><a href="#3-跳过结果数量" class="headerlink" title="3.跳过结果数量"></a>3.跳过结果数量</h3><hr>
<h4 id="skip函数的基本用法"><a href="#skip函数的基本用法" class="headerlink" title="skip函数的基本用法"></a>skip函数的基本用法</h4><p>skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。如下示例：</p>
<p>1.跳过数量：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;skip:4&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果查询结果数量中少于4个的话，则不会返回任何结果。</p>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h3><hr>
<h4 id="sort函数的基本用法"><a href="#sort函数的基本用法" class="headerlink" title="sort函数的基本用法"></a>sort函数的基本用法</h4><p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。</p>
<p>1.结果排序：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">  //查询所有数据，并按照age降序顺序返回数据docs</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>sort函数可根据用户自定义条件有选择性的来进行排序显示数据结果。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>limit函数：限制返回结果的数量。</p>
</li>
<li><p>skip函数：略过指定的返回结果数量。</p>
</li>
<li><p>sort函数：对返回结果进行有效排序。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-19T00:45:23.000Z"><a href="/2014/03/19/Mongoose/Mongoose(4)高级查询/">2014-03-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/19/Mongoose/Mongoose(4)高级查询/">四.高级查询</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1.条件查询"></a>1.条件查询</h3><hr>
<p>接下来我们来看一些在查询时会用的常用操作符，通过操作符的使用，我们就可对数据进行更细致性的查询，一起来看一下吧。</p>
<p>“$lt”(小于)，”$lte”(小于等于),”$gt”(大于)，”$gte”(大于等于)，”$ne”(不等于)，”$in”(可单值和多个值的匹配)，”$or”(查询多个键值的任意给定值)，”$exists”(表示是否存在的意思)”$all”。</p>
<h3 id="2-大、小于"><a href="#2-大、小于" class="headerlink" title="2.大、小于"></a>2.大、小于</h3><hr>
<h4 id="gt、-lt简述"><a href="#gt、-lt简述" class="headerlink" title="$gt、$lt简述"></a>$gt、$lt简述</h4><p>查询时我们经常会碰到要根据某些字段进行条件筛选查询，比如说Number类型，怎么办呢，我们就可以使用$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)操作符进行排除性的查询，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage大于18的数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage小于60的数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18,&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage大于18小于60的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果我们要对类似age字段的数据进行筛选，使用$gt、$lt是不是很方便快捷呢！</p>
<h3 id="3-不匹配"><a href="#3-不匹配" class="headerlink" title="3.不匹配"></a>3.不匹配</h3><hr>
<h4 id="ne简述"><a href="#ne简述" class="headerlink" title="$ne简述"></a>$ne简述</h4><p>$ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定，具体使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123; age:&#123; $ne:24&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    //查询age不等于24的所有数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;name:&#123;$ne:&quot;tom&quot;&#125;,age:&#123;$gte:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询name不等于tom、age&gt;=18的所有数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>$ne可以匹配单个值，也可以匹配不同类型的值。</p>
<h3 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4.匹配"></a>4.匹配</h3><hr>
<h4 id="in简述"><a href="#in简述" class="headerlink" title="$in简述"></a>$in简述</h4><p>和$ne操作符相反，$in相当于包含、等于，查询时查找包含于指定字段条件的数据。具体使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123; age:&#123; $in: 20&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询age等于20的所有数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123; age:&#123;$in:[20,30]&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //可以把多个值组织成一个数组</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>$in和$ne除了条件判定不同，用法是不是很相似呀！</p>
<h3 id="5-或者"><a href="#5-或者" class="headerlink" title="5.或者"></a>5.或者</h3><hr>
<h4 id="or"><a href="#or" class="headerlink" title="$or"></a>$or</h4><p>$or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&quot;$or&quot;:[&#123;&quot;name&quot;:&quot;yaya&quot;&#125;,&#123;&quot;age&quot;:28&#125;]&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询name为yaya或age为28的全部文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-存在"><a href="#6-存在" class="headerlink" title="6.存在"></a>6.存在</h3><hr>
<h4 id="exists"><a href="#exists" class="headerlink" title="$exists"></a>$exists</h4><p>$exists操作符，可用于判断某些关键字段是否存在来进行条件查询。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;name: &#123;$exists: true&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询所有存在name属性的文档</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;telephone: &#123;$exists: false&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询所有不存在telephone属性的文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>$gt(&gt;),$lt(&lt;),$lte(&lt;=),$gte(&gt;=)操作符：针对Number类型的查询具体超强的排除性。</p>
</li>
<li><p>$ne(!=)操作符：相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。</p>
</li>
<li><p>$in操作符：和$ne操作符用法相同，但意义相反。</p>
</li>
<li><p>$or操作符：可查询多个条件，只要满足其中一个就可返回结果值。</p>
</li>
<li><p>$exists操作符：主要用于判断某些属性是否存在。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-14T06:45:23.000Z"><a href="/2014/03/14/Mongoose/Mongoose(3)简单查询/">2014-03-14</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/14/Mongoose/Mongoose(3)简单查询/">三.简单查询</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>查询就是返回一个集合中的文档的子集，Mongoose 模型提供了find、findOne、和findById方法用于文档查询。</p>
<p>这里先添加一些测试数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TestModel.create([</span><br><span class="line">                  &#123; name:&quot;test1&quot;, age:20 &#125;,</span><br><span class="line">                  &#123; name:&quot;test2&quot;, age:30 &#125;,</span><br><span class="line">                  &#123; name:&quot;test3&quot;, age:24 &#125;,</span><br><span class="line">                  &#123; name:&quot;test4&quot;, age:18 &#125;,</span><br><span class="line">                  &#123; name:&quot;test5&quot;, age:60 &#125;,</span><br><span class="line">                  &#123; name:&quot;test6&quot;, age:50, email:&quot;t6@qq.com&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test7&quot;, age:40, email:&quot;t7@163.com&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test8&quot;, age:27 &#125;,</span><br><span class="line">                  &#123; name:&quot;test9&quot;, age:27, email:&quot;t9@yeah.net&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test10&quot;,age:65 &#125;</span><br><span class="line">                 ], function(error,docs) &#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;save ok&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-find过滤查询"><a href="#2-find过滤查询" class="headerlink" title="2.find过滤查询"></a>2.find过滤查询</h3><hr>
<p>了解和掌握它的过滤功能，怎么个过滤法呢，请看如下介绍。</p>
<p>1.属性过滤 find(Conditions,field,callback);</p>
<p>field省略或为Null，则返回所有属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回只包含一个键值name、age的所有记录</span><br><span class="line">Model.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;，function(err,docs)&#123;</span><br><span class="line">   //docs 查询结果集</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的，_id是默认返回，如果不要显示加上(“_id”:0)，但是，对其他不需要显示的属性且不是_id，如果设置为0的话将会抛异常或查询无果。</p>
<h3 id="3-findOne查询"><a href="#3-findOne查询" class="headerlink" title="3.findOne查询"></a>3.findOne查询</h3><hr>
<p>与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果。</p>
<p>1.单条数据 findOne(Conditions,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestModel.findOne(&#123; age: 27&#125;, function (err, doc)&#123;</span><br><span class="line">   // 查询符合age等于27的第一条数据</span><br><span class="line">   // doc是查询结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>findOne方法，只返回第一个符合条件的文档数据。</p>
<h3 id="4-findById"><a href="#4-findById" class="headerlink" title="4.findById"></a>4.findById</h3><hr>
<p>与findOne相同，但它只接收文档的_id作为参数，返回单个文档。</p>
<p>1.单条数据 findById(_id, callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestModel.findById(&apos;obj._id&apos;, function (err, doc)&#123;</span><br><span class="line"> //doc 查询结果文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同样是单条数据，findById和findOne还是有些区别的。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>find过滤查询 ：find查询时我们可以过滤返回结果所显示的属性个数。</p>
</li>
<li><p>findOne查询 ：只返回符合条件的首条文档数据。</p>
</li>
<li><p>findById查询：根据文档_id来查询文档。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-12T02:45:23.000Z"><a href="/2014/03/12/Mongoose/Mongoose(2)增删改查/">2014-03-12</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/12/Mongoose/Mongoose(2)增删改查/">二.增删改查</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h3><hr>
<p>查询分很多种类型，如条件查询，过滤查询等等，先看最基本的find查询。<br>1.find查询： obj.find(查询条件,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,function(error,docs)&#123;</span><br><span class="line">   //若没有向find传递参数，默认的是显示所有文档</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123; &quot;age&quot;: 28 &#125;, function (error, docs) &#123;</span><br><span class="line">  if(error)&#123;</span><br><span class="line">    console.log(&quot;error :&quot; + error);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(docs); //docs: age为28的所有文档</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Model保存"><a href="#2-Model保存" class="headerlink" title="2.Model保存"></a>2.Model保存</h3><hr>
<p>Model提供了一个create方法来对数据进行保存。下面我们来看一下示例：</p>
<ol>
<li>Model.create(文档数据, callback))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Model.create(&#123; name:&quot;model_create&quot;, age:26&#125;, function(error,doc)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-Entity保存"><a href="#3-Entity保存" class="headerlink" title="3.Entity保存"></a>3.Entity保存</h3><hr>
<p>entity的保存方法。如下示例：</p>
<ol>
<li>Entity.save(文档数据, callback))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Entity = new Model(&#123;name:&quot;entity_save&quot;,age: 27&#125;);</span><br><span class="line">Entity.save(function(error,doc) &#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>model调用的是create方法，entity调用的是save方法。</p>
<h3 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h3><hr>
<p>数据更新！</p>
<p>1.示例：obj.update(查询条件,更新对象,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var conditions = &#123;name : &apos;test_update&apos;&#125;;</span><br><span class="line">var update = &#123;$set : &#123; age : 16 &#125;&#125;;</span><br><span class="line">TestModel.update(conditions, update, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Update success!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>更新后find一下，此时数据已经修改成功了！</p>
<h3 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h3><hr>
<p>有了数据的保存、更新，就差删除了。</p>
<p>1.示例：obj.remove(查询条件,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var conditions = &#123; name: &apos;tom&apos; &#125;;</span><br><span class="line">TestModel.remove(conditions, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Delete success!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>和update类似吧，有了remove方法我们就可以进行删除操作了。</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>查询：find查询返回符合条件一个、多个或者空数组文档结果。</p>
</li>
<li><p>保存：model调用create方法，entity调用的save方法。</p>
</li>
<li><p>更新：obj.update(查询条件,更新对象,callback)，根据条件更新相关数据。</p>
</li>
<li><p>删除：obj.remove(查询条件,callback)，根据条件删除相关数据。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-09T06:45:23.000Z"><a href="/2014/03/09/Mongoose/Mongoose(1)基础介绍/">2014-03-09</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/09/Mongoose/Mongoose(1)基础介绍/">一.基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-认识Mongoose"><a href="#1-认识Mongoose" class="headerlink" title="1.认识Mongoose"></a>1.认识Mongoose</h3><hr>
<p>什么是Mongoose呢，它于MongoDB又是什么关系呢，它可以用来做什么呢，介绍Mongoose之前，我们先简单了解一下MongoDB。</p>
<p>MongoDB是一个开源的NoSQL数据库，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储(文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，数据格式就是JSON。</p>
<p>介绍了MongoDB，我们下面就要认识Mongoose了。</p>
<ol>
<li>Mongoose是什么？</li>
</ol>
<p>Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。</p>
<ol start="2">
<li>Mongoose能做什么？</li>
</ol>
<p>Mongoose，因为封装了对MongoDB对文档操作的常用处理方法，让NodeJS操作Mongodb数据库变得easy、easy、So easy!</p>
<h3 id="2-使用Mongoose"><a href="#2-使用Mongoose" class="headerlink" title="2.使用Mongoose"></a>2.使用Mongoose</h3><hr>
<ol>
<li><p>安装mongoose：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用mongoose：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用”mongoose”连接数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var db = mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下面代码检查默认数据库test，是否可以正常连接成功?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line">db.connection.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据库连接失败："</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.on(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"------数据库连接成功！------"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-了解集合"><a href="#3-了解集合" class="headerlink" title="3.了解集合"></a>3.了解集合</h3><hr>
<p>MongoDB —— 是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，后面我们会学习如何创建文档并插入内容。</p>
<p>在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。</p>
<p>我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的“文档”，文档又是什么意思呢，请看如下介绍。</p>
<p>文档 —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。</p>
<p>集合 —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。</p>
<p>如果我们要通过Mongoose去创建一个“集合”并对其进行增删改查，该怎么实现呢，到这里我们就要先了解Schema(数据属性模型)、Model、Entity了。</p>
<h3 id="4-Schema"><a href="#4-Schema" class="headerlink" title="4.Schema"></a>4.Schema</h3><hr>
<p>Schema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p>
<p>那如何去定义一个Schema呢，请看示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,<span class="comment">//属性name,类型为String</span></span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,<span class="comment">//属性age,类型为Number,默认为0</span></span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">default</span>:<span class="string">''</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>基本属性类型有：字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等。</p>
<h3 id="5-Model"><a href="#5-Model" class="headerlink" title="5.Model"></a>5.Model</h3><hr>
<p>Model —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。</p>
<p>如何通过Schema来创建Model呢，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);</span><br></pre></td></tr></table></figure></p>
<p>// 创建Model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var TestModel = db.model(&quot;test1&quot;, TestSchema);</span><br></pre></td></tr></table></figure></p>
<p>test1：数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后在保存数据。</p>
<p>拥有了Model，我们也就拥有了操作数据库的金钥匙。</p>
<p>如果你想对某个集合有所作为，那就交给Model模型来处理吧，创建一个Model模型，我们需要指定：1.集合名称，2.集合的Schema结构对象，满足这两个条件，我们就会拥有一个操作数据库的金钥匙。</p>
<h3 id="6-Entity"><a href="#6-Entity" class="headerlink" title="6.Entity"></a>6.Entity</h3><hr>
<p>Entity —— 由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p>
<p>使用Model创建Entity，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var TestEntity = new TestModel(&#123;</span><br><span class="line">       name : &quot;Lenka&quot;,</span><br><span class="line">       age  : 36,</span><br><span class="line">       email: &quot;lenka@qq.com&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(TestEntity.name); // Lenka</span><br><span class="line">console.log(TestEntity.age); // 36</span><br></pre></td></tr></table></figure></p>
<p>创建成功之后，Schema属性就变成了Model和Entity的公共属性了。</p>
<h3 id="7-创建集合"><a href="#7-创建集合" class="headerlink" title="7.创建集合"></a>7.创建集合</h3><hr>
<p>下面是关于一些基础数据的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br><span class="line"><span class="keyword">var</span> TestEntity = <span class="keyword">new</span> TestModel(&#123;</span><br><span class="line">    name : <span class="string">"helloworld"</span>,</span><br><span class="line">    age  : <span class="number">28</span>,</span><br><span class="line">    email: <span class="string">"helloworld@qq.com"</span></span><br><span class="line">&#125;);</span><br><span class="line">TestEntity.save(<span class="function"><span class="keyword">function</span>(<span class="params">error,doc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"error :"</span> + error);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。</p>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h3><hr>
<p>学习了如何通过Mongoose去创建一个数据库“集合”，还有定义“集合”的基本组成结构并使其具有相应的操作数据库能力。</p>
<p>简单回顾：</p>
<ol>
<li><p>Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。</p>
</li>
<li><p>Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。</p>
</li>
<li><p>Entity：通过Model创建的实体，它也可以操作数据库。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-13T06:45:23.000Z"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">2014-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">三.async</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><hr>
<p>async是一个流程控制库，它就像黑夜中的明灯照亮那陷入callback嵌套泥潭的人们。 这么说虽然有些夸张，但是async确实为我们带来了丰富的嵌套解决方案。</p>
<p>项目地址：</p>
<p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a></p>
<p>npm 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install async</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-serires-tasks-callback"><a href="#2-serires-tasks-callback" class="headerlink" title="2.serires(tasks, callback)"></a>2.serires(tasks, callback)</h3><hr>
<p>首先登场的是series函数，它的作用是串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">    one: function(callback)&#123;</span><br><span class="line">        callback(null, 1);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: function(callback)&#123;</span><br><span class="line">        callback(null, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,function(err, results) &#123; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>series函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式，如示例中的参数为数组，返回的results应该是这样的’[1,2]’。</p>
<h3 id="3-waterfall-tasks-callback"><a href="#3-waterfall-tasks-callback" class="headerlink" title="3.waterfall(tasks,[callback])"></a>3.waterfall(tasks,[callback])</h3><hr>
<p>waterfall和series函数有很多相似之处，都是按顺序依次执行一组函数，不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([  </span><br><span class="line">    function(callback)&#123; </span><br><span class="line">      //task1 </span><br><span class="line">      callback(null,1);       </span><br><span class="line">    &#125;,function(data,callback)&#123;</span><br><span class="line">      //task2 </span><br><span class="line">      callback(null,2); </span><br><span class="line">    &#125; </span><br><span class="line">],function(err,results)&#123;  </span><br><span class="line">    console.log(results); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是waterfall的tasks参数只能是数组类型。</p>
<h3 id="4-parallel-tasks-callback"><a href="#4-parallel-tasks-callback" class="headerlink" title="4.parallel(tasks,[callback])"></a>4.parallel(tasks,[callback])</h3><hr>
<p>parallel函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。 传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>tasks参数可以是一个数组或是json对象，和series函数一样，tasks参数类型不同，返回的results格式会不一样。</p>
<h3 id="5-paralleLimit-tasks-limit-callback"><a href="#5-paralleLimit-tasks-limit-callback" class="headerlink" title="5.paralleLimit(tasks,limit,[callback])"></a>5.paralleLimit(tasks,limit,[callback])</h3><hr>
<p>parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.parallelLimit([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">2,</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-whilst-test-fn-callback"><a href="#6-whilst-test-fn-callback" class="headerlink" title="6.whilst(test,fn,callback)"></a>6.whilst(test,fn,callback)</h3><hr>
<p>相当于while，但其中的异步调用将在完成后才会进行下一次循环。当你需要循环异步的操作的时候，它可以帮助你。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.whilst(</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件。</p>
<p>fn参数就是我们要异步执行的作业，每次fn执行完毕后才会进入下一次循环。</p>
<h3 id="7-doWhilst"><a href="#7-doWhilst" class="headerlink" title="7.doWhilst"></a>7.doWhilst</h3><hr>
<p>相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.doWhilst(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-until-test-fn-callback"><a href="#8-until-test-fn-callback" class="headerlink" title="8.until(test,fn,callback)"></a>8.until(test,fn,callback)</h3><hr>
<p>until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.until(</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-doUntil-fn-test-callback"><a href="#9-doUntil-fn-test-callback" class="headerlink" title="9.doUntil(fn,test,callback)"></a>9.doUntil(fn,test,callback)</h3><hr>
<p>doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.doUntil(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-forever-fn-errback"><a href="#10-forever-fn-errback" class="headerlink" title="10.forever(fn,errback)"></a>10.forever(fn,errback)</h3><hr>
<p>forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async.forever(</span><br><span class="line">    function(next) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-compose-fn1-fn2…"><a href="#11-compose-fn1-fn2…" class="headerlink" title="11.compose(fn1,fn2…)"></a>11.compose(fn1,fn2…)</h3><hr>
<p>使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值。</p>
<p>我们可以使用compose把异步函数f、g、h，组合成f(g(h()))的形式，通过callback得到返回值，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unction fn1(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n * 3);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var demo = async.compose(fn2, fn1);</span><br><span class="line">demo(4, function (err, result) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-auto-tasks-callback"><a href="#12-auto-tasks-callback" class="headerlink" title="12.auto(tasks,[callback])"></a>12.auto(tasks,[callback])</h3><hr>
<p>用来处理有依赖关系的多个任务的执行。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async.auto(&#123;</span><br><span class="line">    getData: function(callback)&#123;</span><br><span class="line">        callback(null, &apos;data&apos;, &apos;converted to array&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    makeFolder: function(callback)&#123;        </span><br><span class="line">        callback(null, &apos;folder&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback, results)&#123;        </span><br><span class="line">        callback(null, &apos;filename&apos;);</span><br><span class="line">    &#125;],</span><br><span class="line">    emailLink: [&apos;writeFile&apos;, function(callback, results)&#123;</span><br><span class="line">        callback(null, &#123;&apos;file&apos;:results.writeFile, &apos;email&apos;:&apos;user@example.com&apos;&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, function(err, results) &#123;</span><br><span class="line">    console.log(&apos;err = &apos;, err);</span><br><span class="line">    console.log(&apos;results = &apos;, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中writeFile依赖getData和makeFolder,emailLink依赖writeFile。</p>
<h3 id="13-queue-worker-concurrency"><a href="#13-queue-worker-concurrency" class="headerlink" title="13.queue(worker,concurrency)"></a>13.queue(worker,concurrency)</h3><hr>
<p>queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。</p>
<p>它有多个点可供回调，如无等候任务时(empty)、全部执行完时(drain)等。</p>
<p>示例：定义一个queue，其worker数量为2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;worker is processing task: &apos;, task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当最后一个任务交给worker执行时，会调用empty函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.empty = function() &#123;</span><br><span class="line">    console.log(&apos;no more tasks wating&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-apply-function-arguments…"><a href="#14-apply-function-arguments…" class="headerlink" title="14.apply(function,arguments…)"></a>14.apply(function,arguments…)</h3><hr>
<p>apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(callback) &#123; </span><br><span class="line">    test(3, callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用apply改写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async.apply(test, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="15-iterator-tasks"><a href="#15-iterator-tasks" class="headerlink" title="15.iterator(tasks)"></a>15.iterator(tasks)</h3><hr>
<p>将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var iter = async.iterator([</span><br><span class="line">    function() &#123; console.log(&apos;111&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;222&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;333&apos;) &#125;</span><br><span class="line">]);</span><br><span class="line">iter();</span><br></pre></td></tr></table></figure>
<p>直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator。</p>
<p>对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null。</p>
<h3 id="16-小结"><a href="#16-小结" class="headerlink" title="16.小结"></a>16.小结</h3><hr>
<p>async模块在流程控制方面给我们带来了比较全面的解决办法，下面我们来回顾一下都有哪几种方案：</p>
<p>串行控制： series、waterfall、compose;</p>
<p>并行控制：</p>
<p>parallel、parallelLimit、queue;</p>
<p>循环控制：<br>whilst、doWhilst、until、doUntil、forever;</p>
<p>其他控制：<br>apply、applyEach、iterator、auto;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-09T06:45:23.000Z"><a href="/2014/02/09/Node.js异步编程/Node.js异步编程(2)函数式编程/">2014-02-09</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/09/Node.js异步编程/Node.js异步编程(2)函数式编程/">二.函数式编程</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1.高阶函数"></a>1.高阶函数</h3><hr>
<p>高阶函数是异步编程的基础，那么什么是高阶函数呢?</p>
<p>高阶二字听起来有点高大上的感觉，其实不然，高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值，请看如下示例。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(v)&#123;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    return v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例中是一个最简单的高阶函数，如你所见，高阶函数test的返回值是一个匿名函数。</p>
<h3 id="2-现实应用"><a href="#2-现实应用" class="headerlink" title="2.现实应用"></a>2.现实应用</h3><hr>
<p>虽然有可能是第一次真正的去了解什么是高阶函数，但是其实我们在日常开发中经常会用到它，只是我们没有去留意或者说不知道它的称谓而已。</p>
<p>示例：数组的排序(sort)函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [23,54,3,12,78];</span><br><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>有没有很熟悉的感觉,想一想常见的还有哪些高阶函数。</p>
<h3 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3.偏函数"></a>3.偏函数</h3><hr>
<p>什么是偏函数？</p>
<p>假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数，有点拗口？请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var isType = function(type)&#123;</span><br><span class="line">  return function(obj)&#123;</span><br><span class="line">    return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var isString = isType(&apos;String&apos;);</span><br><span class="line">var isFunction = isType(&apos;Function&apos;);</span><br></pre></td></tr></table></figure></p>
<p>isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><hr>
<p>高阶函数和偏函数是异步编程的基础，熟练运用高阶函数和偏函数是非常必要的。</p>
<p><strong>高阶函数</strong></p>
<p>1.函数作为参数；<br>2.函数作为返回值；<br><strong>偏函数</strong></p>
<p>1.一个创建函数的工厂函数；<br>2.通过指定部分参数，定制新的函数；</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-04T06:45:23.000Z"><a href="/2014/02/04/Node.js异步编程/Node.js异步编程(1)简介/">2014-02-04</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/04/Node.js异步编程/Node.js异步编程(1)简介/">一.简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hi!&apos;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">   console.log(&apos;hello!&apos;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">console.log(&apos;wow!&apos;);</span><br></pre></td></tr></table></figure></p>
<p>从示例中可以看到，hello是在wow输出后才输出的，因为setTimeout函数设置了延迟1000毫秒才异步执行，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function()&#123; console.log(&apos;hello&apos;); &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是异步回调函数，这样的编程风格就是异步编程。</p>
<h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h3><hr>
<p>为什么选择node.js？它有哪些优势呢？</p>
<p>1.性能：相对于多线程，异步I/O没有了线程间的上下文切换开销，由此带来可观的性能提升是选择它的主要原因。</p>
<p>2.成本：由于性能的提升，相同的硬件可以发挥更大的作用，变相的降低了运营成本，由于node.js采用javascript作为开发语言，而javascript的使用已经非常广泛，所以降低了node.js的学习成本。</p>
<p>3.效率：node.js采用javascript作为开发语言，使前后端开发语言统一，不需要切换开发语言，使开发效率更高，加之javascript使用者众多，使得node.js迅速的流行起来。</p>
<h3 id="3-思维习惯"><a href="#3-思维习惯" class="headerlink" title="3.思维习惯"></a>3.思维习惯</h3><hr>
<p><strong>不符合线性思维习惯</strong><br>虽然异步会带来很多好处，但是也衍生了很多问题。 异步编程在流程控制中业务表达不太适合自然语言的线性思维习惯。</p>
<p>实例 - 获取数据<br>线性表达<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = getData(id);</span><br></pre></td></tr></table></figure></p>
<p>异步编程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getData(id,function(data)&#123;</span><br><span class="line">   //在回调函数中才能获取到data数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-异常捕获"><a href="#4-异常捕获" class="headerlink" title="4.异常捕获"></a>4.异常捕获</h3><hr>
<p>异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常。</p>
<p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        var data = a/1; //错误的计算</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;catch (e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为计算并不会马上执行，所以即便是发生了错误，也无法捕获到相关信息，那么异步编程中应该如何处理异常的呢？请看示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        var data = a/1; //错误的计算</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-函数嵌套"><a href="#5-函数嵌套" class="headerlink" title="5.函数嵌套"></a>5.函数嵌套</h3><hr>
<p>os模块可提供操作系统的一些基本信息，它的一些常用方法如下：<br>函数嵌套<br>刚刚接触node.js的朋友们都有一个共同的烦恼，在进行较复杂的业务处理时，茫茫多的callback看得人头昏眼花，写着写着自己都糊涂了，更何况普遍患有强迫症的程序猿，面对如此难看的代码，如何能忍？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test1(function(v1)&#123;</span><br><span class="line">  test2(funciton(v1,function(v2)&#123;</span><br><span class="line">    test3(function(v2,fcuntion(v3)&#123;</span><br><span class="line">      test4(v3,function(v4)&#123;</span><br><span class="line">        callback(v4);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>异步编程中，函数嵌套是一个普遍存在的问题，也因此常常被人诟病，如何解决函数嵌套，且看下回分解。</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><hr>
<p>非线性的思维只是因为和以前的习惯不太一样，才会觉得不太适应，但是长期使用锻炼你也会发现它并非一无是处。</p>
<p>异常捕获在node.js中也有了统一的约定，将异常信息作为回调函数的第一个实参传递给回调函数。 深层嵌套的问题也有很多解决办法。</p>
<p>思维方式 ===&gt; 非线性思维需要多使用锻炼，适应这种思维方式。<br>异常捕获 ===&gt; 遵守node.js统一的回调函数格式，将异常信息传入回调函数。<br>函数嵌套 ===&gt; 相应解决方案，专门课程讲解。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/Mocha/">Mocha</a><small>4</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js入门/">Node.js入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js错误处理-调试/">Node.js错误处理&amp;调试</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>2</small></li>
  
    <li><a href="/tags/异步编程/">异步编程</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>