<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-15T14:16:53.000Z"><a href="/2016/04/15/Node.js_IO/Buffer那些事儿/">2016-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/15/Node.js_IO/Buffer那些事儿/">Buffer那些事儿</a></h1>
  

    </header>
    <div class="entry">
      
        <p>作为前端的JSer，是一件非常幸福的事情，因为在字符串上从来没有出现过任何纠结的问题。我们来看看PHP对字符串长度的判断结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php </span><br><span class="line">echo strlen(&quot;0123456789&quot;);     </span><br><span class="line">echo strlen(&quot;零一二三四五六七八九&quot;);     </span><br><span class="line">echo mb_strlen(&quot;零一二三四五六七八九&quot;, &quot;utf-8&quot;);      </span><br><span class="line">echo &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>以上三行判断分别返回10、30、10。对于中国人而言，strlen这个方法对于Unicode的判断结果是非常让人疑惑。而看看JavaScript中对字符串长度的判断，就知道这个length属性对调用者而言是多么友好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"0123456789"</span>.length); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"零一二三四五六七八九"</span>.length); <span class="regexp">/10</span></span><br><span class="line"><span class="regexp">console.log("\u00bd".length); /</span><span class="regexp">/ 1</span></span><br></pre></td></tr></table></figure>
<p>尽管在计算机内部，一个中文字和一个英文字占用的字节位数是不同的，但对于用户而言，它们拥有相同的长度。我认为这是JavaScript中 String处理得精彩的一个点。正是由于这个原因，所有的数据从后端传输到前端被调用时，都是这般友好的字符串。所以对于前端工程师而言，他们是没有字 符串Buffer的概念的。如果你是一名前端工程师，那么从此在与Node.js打交道的过程中，一定要小心Buffer啦，因为它比传统的String 要调皮一点。</p>
<h2 id="你该小心Buffer啦"><a href="#你该小心Buffer啦" class="headerlink" title="你该小心Buffer啦"></a>你该小心Buffer啦</h2><p>像许多计算机的技术一样，都是从国外传播过来的。那些以英文作为母语的传道者们应该没有考虑过英文以外的使用者，所以你有可能看到如下这样一段代码在向你描述如何在data事件中连接字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>)</span>&#123;</span><br><span class="line">    data += trunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果这个文件读取流读取的是一个纯英文的文件，这段代码是能够正常输出的。但是如果我们再改变一下条件，将每次读取的buffer大小变成一个奇数，以模拟一个字符被分配在两个trunk中的场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>, &#123;<span class="attr">bufferSize</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>我们将会得到以下这样的乱码输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件循���和请求���象构成了Node.js���异步I/O模型的���个基本���素，这也是典���的消费���生产者场景。</span><br></pre></td></tr></table></figure>
<p>造成这个问题的根源在于data += trunk语句里隐藏的错误，在默认的情况下，trunk是一个Buffer对象。这句话的实质是隐藏了toString的变换的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = data.toString() + trunk.toString();</span><br></pre></td></tr></table></figure>
<p>由于汉字不是用一个字节来存储的，导致有被截破的汉字的存在，于是出现乱码。解决这个问题有一个简单的方案，是设置编码集：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf-8'</span>, <span class="attr">bufferSize</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>这将得到一个正常的字符串响应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件循环和请求对象构成了Node.js的异步I/O模型的两个基本元素，这也是典型的消费者生产者场景。</span><br></pre></td></tr></table></figure>
<p>遗憾的是目前Node.js仅支持hex、utf8、ascii、binary、base64、ucs2几种编码的转换。对于那些因为历史遗留问题依旧还生存着的GBK，GB2312等编码，该方法是无能为力的。</p>
<h2 id="有趣的string-decoder"><a href="#有趣的string-decoder" class="headerlink" title="有趣的string_decoder"></a>有趣的string_decoder</h2><p>在这个例子中，如果仔细观察，会发现一件有趣的事情发生在设置编码集之后。我们提到data += trunk等价于data = data.toString() + trunk.toString()。通过以下的代码可以测试到一个汉字占用三个字节，而我们按11个字节来截取trunk的话，依旧会存在一个汉字被分割在两个trunk中的情景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"事件循环和请求对象"</span>.length);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">"事件循环和请求对象"</span>).length);</span><br></pre></td></tr></table></figure>
<p>按照猜想的toString()方式，应该返回的是事件循xxx和请求xxx象才对，其中“环”字应该变成乱码才对，但是在设置了encoding（默认的utf8）之后，结果却正常显示了，这个结果十分有趣。</p>
<p>在好奇心的驱使下可以探查到<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L1237" target="_blank" rel="noopener">data事件</a>调用了string_decoder来进行编码补足的行为。通过string_decoder对象输出第一个截取Buffer(事件循xx)时，只返回事件循这个字符串，保留xx。第二次通过string_decoder对象输出时检测到上次保留的xx，将上次剩余内容和本次的Buffer进行重新拼接输出。于是达到正常输出的目的。</p>
<p>string_decoder，目前在文件流读取和网络流读取中都有应用到，一定程度上避免了粗鲁拼接trunk导致的乱码错误。但是，遗憾在于string_decoder目前只支持utf8编码。它的思路其实还可以扩展到其他编码上，只是最终是否会支持目前尚不可得知。</p>
<h2 id="连接Buffer对象的正确方法"><a href="#连接Buffer对象的正确方法" class="headerlink" title="连接Buffer对象的正确方法"></a>连接Buffer对象的正确方法</h2><p>那么万能的适应各种编码而且正确的拼接Buffer对象的方法是什么呢？我们从Node.js在github上的源码中找出这样一段<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L107" target="_blank" rel="noopener">正确读取文件，并连接buffer对象的方法</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = [];</span><br><span class="line"><span class="keyword">var</span> nread = <span class="number">0</span>;</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    buffers.push(chunk);</span><br><span class="line">    nread += chunk.length;</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span>(buffers.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: buffer = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: buffer = buffers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            buffer = <span class="keyword">new</span> Buffer(nread);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, pos = <span class="number">0</span>, l = buffers.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> chunk = buffers[i];</span><br><span class="line">                chunk.copy(buffer, pos);</span><br><span class="line">                pos += chunk.length;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在end事件中通过细腻的连接方式，最后拿到理想的Buffer对象。这时候无论是在支持的编码之间转换，还是在不支持的编码之间转换（利用iconv模块转换），都不会导致乱码。</p>
<h2 id="简化连接Buffer对象的过程"><a href="#简化连接Buffer对象的过程" class="headerlink" title="简化连接Buffer对象的过程"></a>简化连接Buffer对象的过程</h2><p>上述一大段代码仅只完成了一件事情，就是连接多个Buffer对象，而这种场景需求将会在多个地方发生，所以，采用一种更优雅的方式来完成该过程是必要的。笔者基于以上的代码封装出一个bufferhelper模块，用于更简洁地处理Buffer对象。可以通过NPM进行安装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bufferhelper</span><br></pre></td></tr></table></figure>
<p>下面的例子演示了如何调用这个模块。与传统data += trunk之间只是bufferHelper.concat(chunk)的差别，既避免了错误的出现，又使得代码可以得到简化而有效地编写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);  </span><br><span class="line"><span class="keyword">var</span> BufferHelper = <span class="built_in">require</span>(<span class="string">'bufferhelper'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bufferHelper = <span class="keyword">new</span> BufferHelper();</span><br><span class="line">    request.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    bufferHelper.concat(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = bufferHelper.toBuffer().toString();</span><br><span class="line">    response.writeHead(<span class="number">200</span>);</span><br><span class="line">    response.end(html);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br></pre></td></tr></table></figure>
<p>所以关于Buffer对象的操作的最佳实践是：</p>
<ul>
<li>保持编码不变，以利于后续编码转换</li>
<li>使用封装方法达到简洁代码的目的</li>
</ul>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://www.infoq.com/cn/articles/nodejs-about-buffer" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/nodejs-about-buffer</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-12T14:16:53.000Z"><a href="/2016/04/12/Node.js_错误处理和调试/动态修改NodeJS程序中的变量值/">2016-04-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/12/Node.js_错误处理和调试/动态修改NodeJS程序中的变量值/">动态修改Node程序中的变量值</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="启动一个-HTTP-Server"><a href="#启动一个-HTTP-Server" class="headerlink" title="启动一个 HTTP Server"></a>启动一个 HTTP Server</h2><p>用简单的 Hello World 做例子吧，不过略作修改。在 <code>global</code> 下放一个变量 <code>message</code>， 然后打印出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message content will be modified !</span></span><br><span class="line">global.message = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(global.message);</span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pid = %d'</span>, process.pid);</span><br></pre></td></tr></table></figure>
<p>用命令启动 Server，此时，通过用浏览器访问 <code>http://localhost:8001</code> 可以看到网页内容是 <code>hello world!</code>。 接下来我们将尝试在不改变代码，不重启进程的情况下把 <code>message</code> 换成 “hello bugs!”。</p>
<h2 id="使-Server-进程进入-Debug-模式"><a href="#使-Server-进程进入-Debug-模式" class="headerlink" title="使 Server 进程进入 Debug 模式"></a>使 Server 进程进入 Debug 模式</h2><p>V8 引擎在实现的时候留了 Debugger 接口。 通过命令 <code>node --debug-brk=5858 [filename]</code> 可以启动一个脚本，并且立即进入 Debug 模式。</p>
<p>那么如果是已经运行着的 NodeJS 程序，可以进入 Debug 模式吗？也是可以的，在操作系统下给 NodeJS 的进程发一个 <code>SIGUSR1</code> 信号，可以让进程进入 Debug 模式。 进入 Debug 模式的进程会在本地启动一个 TCP Server 并且默认监听 <code>5858</code> 端口。</p>
<p>此时在另一个命令行窗口执行命令 <code>node debug localhost:5858</code> 就可以连接到 Debugger 调试端口， 并且可以使用很多常用的 Debug 命令，比如 <code>c</code>继续执行，<code>s</code> 步入， <code>o</code>步出等。</p>
<h2 id="Debugger-协议"><a href="#Debugger-协议" class="headerlink" title="Debugger 协议"></a>Debugger 协议</h2><p>使用 <code>node debug hostname:port</code> 命令连接到进程进行 Debug 的方式比较简单，但是要完成一些高级的功能就会处处受限，因为它只封装了 Debugger 协议中 command 的一部分。 下面介绍一下这个简单的协议。</p>
<p>Client 和 Server 的通讯是通过 TCP 进行的。 DebugClient 第一次连接到 DebugServer 的时候会拿到一些 Header，比如 Node 版本， V8 版本等。后面紧跟着一个空的消息1</p>
<p><strong>消息1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type: connect\r\n</span><br><span class="line">V8-Version: <span class="number">3.28</span><span class="number">.71</span><span class="number">.19</span>\r\n</span><br><span class="line">Protocol-Version: <span class="number">1</span>\r\n</span><br><span class="line">Embedding-Host: node v0<span class="number">.12</span><span class="number">.4</span>\r\n</span><br><span class="line">Content-Length: <span class="number">0</span>\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>消息实体由 Header 和 Body 组成，消息1的 Body 为空，所以 Header 中对应的 Content-Length 为 0。而在下面这个例子里，Body 为一个单行的 JSON 字符串，这是由协议所规定的。</p>
<p><strong>消息2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">46</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;<span class="string">"command"</span>:<span class="string">"version"</span>,<span class="string">"type"</span>:<span class="string">"request"</span>,<span class="string">"seq"</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>消息2的类型( type )是 <code>request</code>，代表这是 Client 发给 Server 的命令，其他的可能值是 <code>response</code> 和 <code>event</code> 分别代表 Server 对 Client 的相应，和 Server 端发生的事件。</p>
<p><strong>消息3</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">137</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;<span class="string">"seq"</span>:<span class="number">1</span>,<span class="string">"request_seq"</span>:<span class="number">1</span>,<span class="string">"type"</span>:<span class="string">"response"</span>,<span class="string">"command"</span>:<span class="string">"version"</span>,<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"body"</span>:&#123;<span class="string">"V8Version"</span>:<span class="string">"3.28.71.19"</span>&#125;,<span class="string">"refs"</span>:[],<span class="string">"running"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>消息2是 Client 发送给 Server的，消息3是 Server 对 Client 的相应，那么如何判断消息3是不是消息2的结果呢？可以看到消息2中的 seq 值是1，而 消息3中的 request_seq 值是1。 Debugger 协议正是通过这两个值把异步返回的结果和请求一一对应起来的。</p>
<p>Debugger 协议就是这么的简单。</p>
<h3 id="实例化一个-Debugger-Client"><a href="#实例化一个-Debugger-Client" class="headerlink" title="实例化一个 Debugger Client"></a>实例化一个 Debugger Client</h3><p>了解了 Debugger 协议后，相信好奇心强的程序员已经跃跃欲试自己实现一个了。本着不重复发明轮子的原则开始在网上找实现，找了好久找到这个库 <a href="https://www.npmjs.com/package/pDebug" target="_blank" rel="noopener">pDebug</a>， 可惜这个库已经好久不更新了。后来通过阅读 <code>node-inspector</code> 的源码才发现，其实 NodeJS 自带了一个 Debugger 模块, 相关代码在 <code>_debugger</code> 模块里(<a href="https://github.com/joyent/node/blob/master/lib/_debugger.js" target="_blank" rel="noopener">源码</a>)，由于模块名是以 <code>_</code>开头的，所以网上找不到它的 API，好在代码注释写的非常详细，很快就能上手。</p>
<p>我们需要的正是这个模块下的 Client， 而 Client 其实是继承于 Socket 的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Client = <span class="built_in">require</span>(<span class="string">'_debugger'</span>).Client;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line">client.connect(<span class="number">5858</span>);</span><br><span class="line">client.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连接成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过-Debugger-接口执行命令"><a href="#通过-Debugger-接口执行命令" class="headerlink" title="通过 Debugger 接口执行命令"></a>通过 Debugger 接口执行命令</h3><p>接下来我们来看看如何修改这个 global 的变量，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modifyTheMessage</span>(<span class="params">newMessage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = &#123;</span><br><span class="line">        <span class="string">'command'</span>: <span class="string">'evaluate'</span>,</span><br><span class="line">        <span class="string">'arguments'</span>: &#123;</span><br><span class="line">            <span class="string">'expression'</span>: <span class="string">'global.message="'</span> + newMessage + <span class="string">'"'</span>,</span><br><span class="line">            <span class="string">'global'</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    client.req(msg, <span class="function"><span class="keyword">function</span> (<span class="params">err, body, res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'modified to %s'</span>, newMessage);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>client.req</code> 方法封装了 <code>type=request</code> 消息类型 和 <code>seq</code> 自增的逻辑，因此在构造 <code>msg</code> JSON对象的时候不需要指明这两个属性。 我们要修改 message 其实就是在 JavaScript 调用的顶层执行 <code>global.message=newMessage</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时，再访问 <code>http://localhost:8001</code> 可以看到网页上显示的内容已经由 <code>&#39;hello world!&#39;</code> 变成了 <code>&#39;hello bugs!&#39;</code>，是不是很神奇。</p>
<p>这种方式也带来了很多可能性：</p>
<ul>
<li>动态修改配置</li>
</ul>
<p>线上的服务器不用重启就可以应用新的配置</p>
<ul>
<li>模块注入</li>
</ul>
<p>通过其他任意语言编写的应用程序为已经运行的 NodeJS 进程注入新的模块</p>
<ul>
<li>性能监控</li>
</ul>
<p>可以剥离用户线上代码对第三方性能监控模块的直接依赖</p>
<ul>
<li>错误监控</li>
</ul>
<p>发生异常时，通过 Debugger 可以抓到发生错误的函数和行号，并且抓取各个调用栈中的每一个变量，即使是在闭包里</p>
<ul>
<li>Chrome 调试</li>
</ul>
<p>由于 Chrome 也是基于 V8 的，上述方法也可以用于 Chrome 相关的功能集成</p>
<p>原文：<a href="http://code.oneapm.com/nodejs/2015/06/27/intereference/" target="_blank" rel="noopener">http://code.oneapm.com/nodejs/2015/06/27/intereference/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-10T14:16:53.000Z"><a href="/2016/04/10/Node.js_错误处理和调试/CPU profiling/">2016-04-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/10/Node.js_错误处理和调试/CPU profiling/">CPU profiling</a></h1>
  

    </header>
    <div class="entry">
      
        <p>There are many third party tools available for profiling Node.js applications but, in many cases, the easiest option is to use the Node.js built in profiler. The built in profiler uses the <a href="https://developers.google.com/v8/profiler_example" target="_blank" rel="noopener">profiler inside V8</a> which samples the stack at regular intervals during program execution. It records the results of these samples, along with important optimization events such as jit compiles, as a series of ticks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code-creation,LazyCompile,0,0x2d5000a337a0,396,&quot;bp native array.js:1153:16&quot;,0x289f644df68,~</span><br><span class="line">code-creation,LazyCompile,0,0x2d5000a33940,716,&quot;hasOwnProperty native v8natives.js:198:30&quot;,0x289f64438d0,~</span><br><span class="line">code-creation,LazyCompile,0,0x2d5000a33c20,284,&quot;ToName native runtime.js:549:16&quot;,0x289f643bb28,~</span><br><span class="line">code-creation,Stub,2,0x2d5000a33d40,182,&quot;DoubleToIStub&quot;</span><br><span class="line">code-creation,Stub,2,0x2d5000a33e00,507,&quot;NumberToStringStub&quot;</span><br></pre></td></tr></table></figure>
<p>In the past you need the V8 source code to be able to interpret the ticks. Luckily, tools have recently been introduced into Node.js 4.4.0 that facilitate the consumption of this information without separately building V8 from source. Let’s see how the built-in profiler can help provide insight into application performance.</p>
<p>To illustrate the use of the tick profiler, we will work with a simple Express application. Our application will have two handlers, one for adding new users to our system:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/newUser'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || users.username) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> salt = crypto.randomBytes(<span class="number">128</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.pbkdf2Sync(password, salt, <span class="number">10000</span>, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  users[username] = &#123; salt, hash &#125;;</span><br><span class="line"></span><br><span class="line">  res.sendStatus(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>and another for validating user authentication attempts:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/auth'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || !users[username]) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hash = crypto.pbkdf2Sync(password, users[username].salt, <span class="number">10000</span>, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (users[username].hash.toString() === hash.toString()) &#123;</span><br><span class="line">    res.sendStatus(<span class="number">200</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.sendStatus(<span class="number">401</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>Please note that these are NOT recommended handlers for authenticating users in your Node.js applications and are used purely for illustration purposes. You should not be trying to design your own cryptographic authentication mechanisms in general. It is much better to use existing, proven authentication solutions.</em></p>
<p>Now assume that we’ve deployed our application and users are complaining about high latency on requests. We can easily run the app with the built in profiler:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production node --prof app.js</span><br></pre></td></tr></table></figure>
<p>and put some load on the server using <code>ab</code> (ApacheBench):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;http://localhost:8080/newUser?username=matt&amp;password=password&quot;</span><br><span class="line">ab -k -c 20 -n 250 &quot;http://localhost:8080/auth?username=matt&amp;password=password&quot;</span><br></pre></td></tr></table></figure>
<p>and get an ab output of:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20</span><br><span class="line">Time taken for tests:   46.932 seconds</span><br><span class="line">Complete requests:      250</span><br><span class="line">Failed requests:        0</span><br><span class="line">Keep-Alive requests:    250</span><br><span class="line">Total transferred:      50250 bytes</span><br><span class="line">HTML transferred:       500 bytes</span><br><span class="line">Requests per second:    5.33 [#/sec] (mean)</span><br><span class="line">Time per request:       3754.556 [ms] (mean)</span><br><span class="line">Time per request:       187.728 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1.05 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   3755</span><br><span class="line">  66%   3804</span><br><span class="line">  75%   3818</span><br><span class="line">  80%   3825</span><br><span class="line">  90%   3845</span><br><span class="line">  95%   3858</span><br><span class="line">  98%   3874</span><br><span class="line">  99%   3875</span><br><span class="line"> 100%   4225 (longest request)</span><br></pre></td></tr></table></figure>
<p>From this output, we see that we’re only managing to serve about 5 requests per second and that the average request takes just under 4 seconds round trip. In a real world example, we could be doing lots of work in many functions on behalf of a user request but even in our simple example, time could be lost compiling regular expressions, generating random salts, generating unique hashes from user passwords, or inside the Express framework itself.</p>
<p>Since we ran our application using the <code>--prof</code> option, a tick file was generated in the same directory as your local run of the application. It should have the form <code>isolate-0xnnnnnnnnnnnn-v8.log</code> (where <code>n</code> is a digit).</p>
<p>In order to make sense of this file, we need to use the tick processor bundled with the Node.js binary. To run the processor, use the <code>--prof-process</code> flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --prof-process isolate-0xnnnnnnnnnnnn-v8.log &gt; processed.txt</span><br></pre></td></tr></table></figure>
<p>Opening processed.txt in your favorite text editor will give you a few different types of information. The file is broken up into sections which are again broken up by language. First, we look at the summary section and see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Summary]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">    79    0.2%    0.2%  JavaScript</span><br><span class="line"> 36703   97.2%   99.2%  C++</span><br><span class="line">     7    0.0%    0.0%  GC</span><br><span class="line">   767    2.0%          Shared libraries</span><br><span class="line">   215    0.6%          Unaccounted</span><br></pre></td></tr></table></figure>
<p>This tells us that 97% of all samples gathered occurred in C++ code and that when viewing other sections of the processed output we should pay most attention to work being done in C++ (as opposed to Javascript). With this in mind, we next find the [C++] section which contains information about which C++ functions are taking the most CPU time and see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[C++]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line"> 19557   51.8%   52.9%  node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)</span><br><span class="line">  4510   11.9%   12.2%  _sha1_block_data_order</span><br><span class="line">  3165    8.4%    8.6%  _malloc_zone_malloc</span><br></pre></td></tr></table></figure>
<p>We see that the top 3 entries account for 72.1% of CPU time taken by the program. From this output, we immediately see that at least 51.8% of CPU time is taken up by a function called PBKDF2 which corresponds to our hash generation from a user’s password. However, it may not be immediately obvious how the lower two entries factor into our application (or if it is we will pretend otherwise for the sake of example). To better understand the relationship between these functions, we will next look at the [Bottom up (heavy) profile] section which provides information about the primary callers of each function. Examining this section, we find:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ticks parent  name</span><br><span class="line">19557   51.8%  node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)</span><br><span class="line">19557  100.0%    v8::internal::Builtins::~Builtins()</span><br><span class="line">19557  100.0%      LazyCompile: ~pbkdf2 crypto.js:557:16</span><br><span class="line"></span><br><span class="line"> 4510   11.9%  _sha1_block_data_order</span><br><span class="line"> 4510  100.0%    LazyCompile: *pbkdf2 crypto.js:557:16</span><br><span class="line"> 4510  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30</span><br><span class="line"></span><br><span class="line"> 3165    8.4%  _malloc_zone_malloc</span><br><span class="line"> 3161   99.9%    LazyCompile: *pbkdf2 crypto.js:557:16</span><br><span class="line"> 3161  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30</span><br></pre></td></tr></table></figure>
<p>Parsing this section takes a little more work than the raw tick counts above. Within each of the “call stacks” above, the percentage in the parent column tells you the percentage of samples for which the function in the row above was called by the function in the current row. For example, in the middle “call stack” above for _sha1_block_data_order, we see that _sha1_block_data_order occurred in 11.9% of samples, which we knew from the raw counts above. However, here, we can also tell that it was always called by the pbkdf2 function inside the Node.js crypto module. We see that similarly, _malloc_zone_malloc was called almost exclusively by the same pbkdf2 function. Thus, using the information in this view, we can tell that our hash computation from the user’s password accounts not only for the 51.8% from above but also for all CPU time in the top 3 most sampled functions since the calls to _sha1_block_data_order and _malloc_zone_malloc were made on behalf of the pbkdf2 function.</p>
<p>At this point, it is very clear that the password based hash generation should be the target of our optimization. Thankfully, you’ve fully internalized the <a href="https://nodesource.com/blog/why-asynchronous" target="_blank" rel="noopener">benefits of asynchronous programming</a> and you realize that the work to generate a hash from the user’s password is being done in a synchronous way and thus tying down the event loop. This prevents us from working on other incoming requests while computing a hash.</p>
<p>To remedy this issue, you make a small modification to the above handlers to use the asynchronous version of the pbkdf2 function:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/auth'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || !users[username]) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  crypto.pbkdf2(password, users[username].salt, <span class="number">10000</span>, <span class="number">512</span>, (err, hash) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (users[username].hash.toString() === hash.toString()) &#123;</span><br><span class="line">      res.sendStatus(<span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.sendStatus(<span class="number">401</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>A new run of the ab benchmark above with the asynchronous version of your app yields:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20</span><br><span class="line">Time taken for tests:   12.846 seconds</span><br><span class="line">Complete requests:      250</span><br><span class="line">Failed requests:        0</span><br><span class="line">Keep-Alive requests:    250</span><br><span class="line">Total transferred:      50250 bytes</span><br><span class="line">HTML transferred:       500 bytes</span><br><span class="line">Requests per second:    19.46 [#/sec] (mean)</span><br><span class="line">Time per request:       1027.689 [ms] (mean)</span><br><span class="line">Time per request:       51.384 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          3.82 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   1018</span><br><span class="line">  66%   1035</span><br><span class="line">  75%   1041</span><br><span class="line">  80%   1043</span><br><span class="line">  90%   1049</span><br><span class="line">  95%   1063</span><br><span class="line">  98%   1070</span><br><span class="line">  99%   1071</span><br><span class="line"> 100%   1079 (longest request)</span><br></pre></td></tr></table></figure>
<p>Yay! Your app is now serving about 20 requests per second, roughly 4 times more than it was with the synchronous hash generation. Additionally, the average latency is down from the 4 seconds before to just over 1 second.</p>
<p>Hopefully, through the performance investigation of this (admittedly contrived) example, you’ve seen how the V8 tick processor can help you gain a better understanding of the performance of your Node.js applications.</p>
<p>原文：<a href="https://nodejs.org/en/docs/guides/simple-profiling/" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/simple-profiling/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-05T14:16:53.000Z"><a href="/2016/04/05/Node.js_错误处理和调试/Node出现uncaughtException之后的优雅退出方案/">2016-04-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/05/Node.js_错误处理和调试/Node出现uncaughtException之后的优雅退出方案/">Node出现uncaughtException之后的优雅退出方案</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Node 的异步特性是它最大的魅力，但是在带来便利的同时也带来了不少麻烦和坑，错误捕获就是一个。由于 Node 的异步特性，导致我们无法使用 try/catch 来捕获回调函数中的异常，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入 try/catch'</span>);</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'fs'</span>).stat(<span class="string">'SOME_FILE_DOES_NOT_EXIST'</span>, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readCallback</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err; <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 这里捕获不到 readCallback 函数中抛出的异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'离开 try/catch'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入 <span class="keyword">try</span>/<span class="keyword">catch</span></span><br><span class="line">离开 <span class="keyword">try</span>/<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">test.js:<span class="number">7</span></span><br><span class="line">            <span class="keyword">throw</span> err; <span class="comment">// 抛出异常</span></span><br><span class="line">                  ^</span><br><span class="line"><span class="built_in">Error</span>: ENOENT, stat <span class="string">'SOME_FILE_DOES_NOT_EXIST'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中由于 <code>fs.stat</code> 去查询一个不存在的文件的状态，导致 <code>readCallback</code> 抛出了一个异常。由于 <code>fs.read</code> 的异步特性，<code>readCallback</code> 函数的调用发生在 <code>try/catch</code> 块结束之后，所以该异常不会被 try/catch 捕获。之后 Node 会触发 <code>uncaughtException</code> 事件，如果这个事件依然没有得到响应，整个进程(<code>process</code>)就会 crash。</p>
<p>程序员永远无法保证代码中不出现 <code>uncaughtException</code>，即便是自己代码写的足够小心，也不能保证用的第三方模块没有 bug，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="built_in">require</span>(<span class="string">'deserialize'</span>); </span><br><span class="line"><span class="comment">// 假设 deserialize 是一个带有 bug 的第三方模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app 是一个 express 服务对象</span></span><br><span class="line">app.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    mysql.query(<span class="string">'SELECT * FROM user WHERE id=1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> config = deserialize(user.config); </span><br><span class="line"><span class="comment">// 假如这里触发了 deserialize 的 bug</span></span><br><span class="line">        res.send(config);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果不幸触发了 <code>deserialize</code> 模块的 bug，这里就会抛出一个异常，最终结果是整个服务 crash。</p>
<p>当这种情况发生在 Web 服务上时结果是灾难性的。<code>uncaughtException</code> 错误会导致当前的所有的用户连接都被中断，甚至不能返回一个正常的 HTTP 错误码，用户只能等到浏览器超时才能看到一个 <code>no data received</code> 错误。</p>
<p>这是一种非常野蛮粗暴的异常处理机制，任何线上服务都不应该因为 <code>uncaughtException</code> 导致服务器崩溃。一个友好的错误处理机制应该满足三个条件:</p>
<ol>
<li>对于引发异常的用户，返回 500 页面</li>
<li>其他用户不受影响，可以正常访问</li>
<li>不影响整个进程的正常运行</li>
</ol>
<p>很遗憾的是，保证 <code>uncaughtException</code> 不影响整个进程的健康运转是不可能的。当 Node 抛出 <code>uncaughtException</code> 异常时就会丢失当前环境的堆栈，导致 Node 不能正常进行内存回收。也就是说，每一次 <code>uncaughtException</code> 都有可能导致内存泄露。</p>
<p>既然如此，退而求其次，我们可以在满足前两个条件的情况下退出进程以便重启服务。</p>
<h2 id="用-domain-来捕获异步异常"><a href="#用-domain-来捕获异步异常" class="headerlink" title="用 domain 来捕获异步异常"></a>用 domain 来捕获异步异常</h2><p>普遍的思路是，如果可以通过某种方式来捕获回调函数中的异常，那么就不会有 <code>uncaughtException</code> 错误导致的崩溃。为了解决这个问题，Node 0.8 之后的版本新增了 <code>domain</code> 模块，它可以用来捕获回调函数中抛出的异常。</p>
<p><code>domain</code> 主要的 API 有 <code>domain.run</code> 和 <code>error</code> 事件。简单的说，通过 <code>domain.run</code> 执行的函数中引发的异常都可以通过 <code>domain</code> 的 <code>error</code> 事件捕获，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"><span class="keyword">var</span> d = domain.create();</span><br><span class="line">d.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async error'</span>); <span class="comment">// 抛出一个异步异常</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch err:'</span>, err); <span class="comment">// 这里可以捕获异步异常</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <code>domain</code> 模块，以及 JavaScript 的词法作用域特性，可以很轻易的为引发异常的用户返回 500 页面。以 express 为例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqDomain = domain.create();</span><br><span class="line">    reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 下面抛出的异常在这里被捕获</span></span><br><span class="line">        res.send(<span class="number">500</span>, err.stack); <span class="comment">// 成功给用户返回了 500</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    reqDomain.run(next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async exception'</span>); <span class="comment">// 抛出一个异步异常</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码将 domain 作为一个中间件来使用，保证之后 express 所有的中间件都在 <code>domain.run</code>函数内部执行。这些中间件内的异常都可以通过 <code>error</code> 事件来捕获。</p>
<p>尽管借助于闭包，我们可以正常的给用户返回 500 错误，但是 <code>domain</code> 捕获到错误时依然会丢失堆栈信息，此时已经无法保证程序的健康运行，必须退出。Node http server 提供了 <code>close</code> 方法，该方法在调用时会停止 server 接收新的请求，但不会断开当前已经建立的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制退出机制</span></span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref(); <span class="comment">// 非常重要</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动退出机制，停止接收新链接，等待当前已建立连接的关闭</span></span><br><span class="line">        server.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 此时所有连接均已关闭，此时 Node 会自动退出，不需要再调用 </span></span><br><span class="line">process.exit(<span class="number">1</span>) 来结束进程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子来自 Node 的文档。其中有几个关键点：</p>
<ul>
<li>Node 有个非常好的特性，所有连接都被释放后进程会自动结束，所以不需要再 <code>server.close</code> 方法的回调函数中退出进程</li>
<li>强制退出机制: 因为用户连接有可能因为某些原因无法释放，在这种情况下应该强制退出整个进程。</li>
<li><code>killTimer.unref()</code>: 如果不使用 <code>unref</code> 方法，那么即使 server 的所有连接都关闭，Node 也会保持运行直到 <code>killTimer</code> 的回调函数被调用。<code>unref</code> 可以创建一个”不保持程序运行”的计时器。</li>
<li>处理异常时要小心的把异常处理逻辑用 try/catch 包住，避免处理异常时抛出新的异常</li>
</ul>
<p>通过 <code>domain</code> 似乎就已经解决了我们的需求: 给触发异常的用户一个 500，停止接收新请求，提供正常的服务给已经建立连接的用户，直到所有请求都已结束，退出进程。但是，理想很丰满，现实很骨感，<code>domain</code> 有个最大的问题，它<a href="http://cnodejs.org/topic/516b64596d38277306407936" target="_blank" rel="noopener">不能捕获所有的异步异常</a>！。也就是说，即使用了 <code>domain</code>，程序依然有因为 <code>uncaughtException</code> crash 的可能。</p>
<p>所幸的是我们可以监听 <code>uncaughtException</code> 事件。</p>
<h2 id="uncaughtException-事件"><a href="#uncaughtException-事件" class="headerlink" title="uncaughtException 事件"></a><code>uncaughtException</code> 事件</h2><p><code>uncaughtException</code> 是一个非常古老的事件。当 Node 发现一个未捕获的异常时，会触发这个事件。并且如果这个事件存在回调函数，Node 就不会强制结束进程。这个特性，可以用来弥补 <code>domain</code> 的不足:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>uncaughtException</code> 事件的缺点在于无法为抛出异常的用户请求返回一个 500 错误，这是由于 <code>uncaughtException</code> 丢失了当前环境的上下文，比如下面的例子就是它做不到的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async error'</span>); </span><br><span class="line"><span class="comment">// uncaughtException, 导致 req 的引用丢失</span></span><br><span class="line">        res.send(<span class="number">200</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="number">500</span>); <span class="comment">// 做不到，拿不到当前请求的 res 对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终出错的用户只能等待浏览器超时。</p>
<h2 id="domain-uncaughtException"><a href="#domain-uncaughtException" class="headerlink" title="domain + uncaughtException"></a><code>domain</code> + <code>uncaughtException</code></h2><p>所以，我们可以结合两种异常捕获机制，用 <code>domain</code> 来捕获大部分的异常，并且提供友好的 500 页面以及优雅退出。对于剩下的异常，通过 <code>uncaughtException</code> 事件来避免服务器直接 crash。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).create(app);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 domain 来捕获大部分异常</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqDomain = domain.create();</span><br><span class="line">    reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                process.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;, <span class="number">30000</span>);</span><br><span class="line">            killTimer.unref();</span><br><span class="line"></span><br><span class="line">            server.close();</span><br><span class="line"></span><br><span class="line">            res.send(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    reqDomain.run(next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncaughtException 避免程序崩溃</span></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="其他的一些问题"><a href="#其他的一些问题" class="headerlink" title="其他的一些问题"></a>其他的一些问题</h2><h3 id="express-中异常的处理"><a href="#express-中异常的处理" class="headerlink" title="express 中异常的处理"></a><code>express</code> 中异常的处理</h3><p>使用 <code>express</code> 时记住一定不要在 controller 的异步回调中抛出异常，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 总是接收 next 参数</span></span><br><span class="line">    mysql.query(<span class="string">'SELECT * FROM users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 不要这样做</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应该将 err 传递给 errorHandler 处理</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 带有四个参数的 middleware 专门用来处理异常</span></span><br><span class="line">    res.render(<span class="number">500</span>, err.stack);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="和-cluster-一起使用"><a href="#和-cluster-一起使用" class="headerlink" title="和 cluster 一起使用"></a>和 cluster 一起使用</h3><p>cluster 是 node 自带的负载均衡模块，使用 cluster 模块可以方便的建立起一套 master/slave 服务。在使用 cluster 模块时，需要注意不仅需要调用 <code>server.close()</code> 来关闭连接，同时还需要调用 <code>cluster.worker.disconnect()</code> 通知 master 进程已停止服务:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cluster.worker) &#123;</span><br><span class="line">            cluster.worker.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="不要通过-uncaughtException-来忽略错误"><a href="#不要通过-uncaughtException-来忽略错误" class="headerlink" title="不要通过 uncaughtException 来忽略错误"></a>不要通过 <code>uncaughtException</code> 来忽略错误</h3><p>当 <code>uncaughtException</code> 事件有一个以上的 <code>listener</code> 时，会阻止 Node 结束进程。因此就有一个广泛流传的做法是监听 <code>process</code> 的 <code>uncaughtException</code> 事件来阻止进程退出，这种做法有内存泄露的风险，所以千万不要这么做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123; // 不要这么做</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="pm2-对于-uncaughtException-的额外处理"><a href="#pm2-对于-uncaughtException-的额外处理" class="headerlink" title="pm2 对于 uncaughtException 的额外处理"></a>pm2 对于 <code>uncaughtException</code> 的额外处理</h3><p>如果你在用 pm2 0.7.1 之前的版本，那么要当心。pm2 有一个 bug，如果进程抛出了 <code>uncaughtException</code>，无论代码中是否捕获了这个事件，进程都会被 pm2 杀死。0.7.2 之后的 pm2 解决了这个问题。</p>
<h3 id="要小心-worker-disconnect"><a href="#要小心-worker-disconnect" class="headerlink" title="要小心 worker.disconnect()"></a>要小心 worker.disconnect()</h3><p>如果你在退出进程时希望可以发消息给监控服务器，并且还使用了 cluster，那么这个时候要特别小心，比如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> udpLog = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    udpLog.send(<span class="string">'process '</span> + process.pid + <span class="string">' down'</span>, </span><br><span class="line">    <span class="comment">/* ... 一些发送 udp 消息的参数 ...*/</span>);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line">    cluster.worker.disconnect();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这份代码就不能正常的将消息发送出去。因为 <code>udpLog.send</code> 是一个异步方法，真正发消息的操作发生在下一个事件循环中。而在真正的发送消息之前 <code>cluster.worker.disconnect()</code> 就已经执行了。<code>worker.disconnect()</code> 会在当前进程没有任何链接之后，杀掉整个进程，这种情况有可能发生在发送 log 数据之前，导致 log 数据发不出去。</p>
<p>一个解决方法是在 <code>udpLog.send</code> 方法发送完数据后再调用 <code>worker.disconnect</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> udpLog = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    udpLog.send(<span class="string">'process '</span> + process.pid + <span class="string">' down'</span>, <span class="comment">/* ... </span></span><br><span class="line"><span class="comment">一些发送 udp 消息的参数 ...*/</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cluster.worker.disconnect();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证 worker.disconnect 不会拖太久..</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cluster.worker.disconnect();</span><br><span class="line">    &#125;, <span class="number">100</span>).unref();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>说了这么多，结论是，目前为止(Node 0.10.25)，依然没有一个完美的方案来解决任意异常的优雅退出问题。用 <code>domain</code> 来捕获大部分异常，并且通过 <code>uncaughtException</code> 避免程序 crash 是目前来说最理想的方案。回调异常的退出问题在遇到 cluster 以后会更加复杂，特别是对于连接关闭的处理要格外小心。</p>
<p>原文：<a href="http://www.infoq.com/cn/articles/quit-scheme-of-node-uncaughtexception-emergence" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/quit-scheme-of-node-uncaughtexception-emergence</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-04T14:16:53.000Z"><a href="/2016/04/04/Node.js_错误处理和调试/JavaScript错误处理机制/">2016-04-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/04/Node.js_错误处理和调试/JavaScript错误处理机制/">JavaScript错误处理机制</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">err.message <span class="comment">// "出错了"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>
<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.name + <span class="string">': '</span> + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwit();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack); <span class="comment">// print stack trace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catchit()</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class="line"><span class="comment">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class="line"><span class="comment">//    at repl:1:5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>
<h2 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>
<h3 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>a;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>
<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>
<h3 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个不存在的变量</span></span><br><span class="line">unknownVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure>
<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者<code>this</code>赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 对象不能手动赋值</span></span><br><span class="line"><span class="keyword">this</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
<p>上面代码对函数<code>console.log</code>的运行结果和<code>this</code>赋值，结果都引发了<code>ReferenceError</code>错误。</p>
<h3 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组长度不得为负数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>
<h3 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h3><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: number is not a func</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>
<h3 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h3><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">'%2'</span>)</span><br><span class="line"><span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>
<h3 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个函数，代表错误提示信息（message）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'出错了，变量超出有效范围！'</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'出错了，变量类型无效！'</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// "出错了！"</span></span><br><span class="line">err2.message <span class="comment">// "出错了，变量超出有效范围！"</span></span><br><span class="line">err3.message <span class="comment">// "出错了，变量类型无效！"</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>
<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x 必须为正数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果变量<code>x</code>小于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>
<p><code>throw</code>也可以抛出自定义错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserError(<span class="string">'出错了！'</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Error！'</span>;</span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Error!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<h2 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>
<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"出错了"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 222</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught 100</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">EvalError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>
<h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleansUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了……'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此行不会执行'</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成清理工作'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleansUp()</span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Error: 出错了……</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于没有<code>catch</code>语句块，所以错误没有捕获。执行<code>finally</code>代码块以后，程序就中断在错误抛出的地方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idle</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"FINALLY"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idle(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br><span class="line"><span class="comment">// "result"</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。注意，只有在其执行完毕后，才会显示<code>return</code>语句的值。</p>
<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countUp()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">count</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>return</code>语句的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>
<p>下面是<code>finally</code>代码块用法的典型场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openFile();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writeFile(Data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>
<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'bug'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>
<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'出错了！'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉到内部错误'</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caught outer "bogus"'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>
<p>原文：<a href="http://javascript.ruanyifeng.com/grammar/error.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/grammar/error.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-12T06:45:23.000Z"><a href="/2016/03/12/javascript/JavaScript中的作用域和上下文/">2016-03-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/12/javascript/JavaScript中的作用域和上下文/">JavaScript中的作用域和上下文</a></h1>
  

    </header>
    <div class="entry">
      
        <p>JavaScript对于作用域（Scope）和上下文（Context）的实现是这门语言的一个非常独到的地方，部分归功于其独特的灵活性。 函数可以接收不同的的上下文和作用域。这些概念为JavaScript中的很多强大的设计模式提供了坚实的基础。 然而这也概念也非常容易给开发人员带来困惑。为此，本文将全面的剖析这些概念，并阐述不同的设计模式是如何利用它们的。</p>
<h3 id="上下文（Context）和作用域（Scope）"><a href="#上下文（Context）和作用域（Scope）" class="headerlink" title="上下文（Context）和作用域（Scope）"></a>上下文（Context）和作用域（Scope）</h3><p>首先需要知道的是，上下文和作用域是两个完全不同的概念。多年来，我发现很多开发者会混淆这两个概念（包括我自己）， 错误的将两个概念混淆了。平心而论，这些年来很多术语都被混乱的使用了。</p>
<p>函数的每次调用都有与之紧密相关的作用域和上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。 换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字的值， 它是拥有（控制）当前所执行代码的对象的引用。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个变量可以被定义在局部或者全局作用域中，这建立了在运行时（runtime）期间变量的访问性的不同作用域范围。 任何被定义的全局变量，意味着它需要在函数体的外部被声明，并且存活于整个运行时（runtime），并且在任何作用域中都可以被访问到。 在ES6之前，局部变量只能存在于函数体中，并且函数的每次调用它们都拥有不同的作用域范围。 局部变量只能在其被调用期的作用域范围内被赋值、检索、操纵。</p>
<p>需要注意，在ES6之前，JavaScript不支持块级作用域，这意味着在if语句、switch语句、for循环、while循环中无法支持块级作用域。 也就是说，ES6之前的JavaScript并不能构建类似于Java中的那样的块级作用域（变量不能在语句块外被访问到）。但是， 从ES6开始，你可以通过let关键字来定义变量，它修正了var关键字的缺点，能够让你像Java语言那样定义变量，并且支持块级作用域。看两个例子：</p>
<p>ES6之前，我们使用var关键字定义变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var tmp = 123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以能够访问，是因为var关键字声明的变量有一个变量提升的过程。而在ES6场景，推荐使用let关键字定义变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let tmp = 123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(tmp); // ReferenceError: tmp is not defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式，能够避免很多错误。</p>
<h3 id="什么是this上下文"><a href="#什么是this上下文" class="headerlink" title="什么是this上下文"></a>什么是this上下文</h3><p>上下文通常取决于函数是如何被调用的。当一个函数被作为对象中的一个方法被调用的时候，this被设置为调用该方法的对象上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    foo: function()&#123;</span><br><span class="line">        alert(this === obj);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); // true</span><br></pre></td></tr></table></figure></p>
<p>这个准则也适用于当调用函数时使用new操作符来创建对象的实例的情况下。在这种情况下，在函数的作用域内部this的值被设置为新创建的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    alert(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new foo() // foo</span><br><span class="line">foo() // window</span><br></pre></td></tr></table></figure></p>
<p>当调用一个为绑定函数时，this默认情况下是全局上下文，在浏览器中它指向window对象。需要注意的是，ES5引入了严格模式的概念， 如果启用了严格模式，此时上下文默认为undefined。</p>
<h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>JavaScript是一个单线程语言，意味着同一时间只能执行一个任务。当JavaScript解释器初始化执行代码时， 它首先默认进入全局执行环境（execution context），从此刻开始，函数的每次调用都会创建一个新的执行环境。</p>
<p>这里会经常引起新手的困惑，这里提到了一个新的术语——执行环境（execution context），它定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 它更偏向于作用域的作用，而不是我们前面讨论的上下文（Context）。请务必仔细的区分执行环境和上下文这两个概念（注：英文容易造成混淆）。 说实话，这是个非常糟糕的命名约定，但是它是ECMAScript规范制定的，你还是遵守吧。</p>
<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出， 把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。</p>
<p>执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object）， 它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化，this的值也会被最终确定。 在执行阶段，代码被解释执行。</p>
<p>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。 需要知道，我们无法手动访问这个对象，只有解析器才能访问它。</p>
<h3 id="作用域链（The-Scope-Chain）"><a href="#作用域链（The-Scope-Chain）" class="headerlink" title="作用域链（The Scope Chain）"></a>作用域链（The Scope Chain）</h3><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链包含了在环境栈中的每个执行环境对应的变量对象。通过作用域链，可以决定变量的访问和标识符的解析。 注意，全局执行环境的变量对象始终都是作用域链的最后一个对象。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">function changeColor()&#123;</span><br><span class="line">  var anotherColor = &quot;red&quot;;</span><br><span class="line"></span><br><span class="line">  function swapColors()&#123;</span><br><span class="line">    var tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line"></span><br><span class="line">    // 这里可以访问color, anotherColor, 和 tempColor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这里可以访问color 和 anotherColor，但是不能访问 tempColor</span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br><span class="line"></span><br><span class="line">// 这里只能访问color</span><br><span class="line">console.log(&quot;Color is now &quot; + color);</span><br></pre></td></tr></table></figure>
<p>上述代码一共包括三个执行环境：全局环境、changeColor()的局部环境、swapColors()的局部环境。 上述程序的作用域链如下图所示：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/imgscope-chain.png" alt=""></p>
<p>从上图发现。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。 这些环境之间的联系是线性的、有次序的。</p>
<p>对于标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后（全局执行环境）回溯，直到找到标识符为止。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一函数作用域中的变量的函数。换句话说，在函数内定义一个嵌套的函数时，就构成了一个闭包， 它允许嵌套函数访问外层函数的变量。通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。 这种封装允许你在外部作用域中隐藏和保护执行环境，并且暴露公共接口，进而通过公共接口执行进一步的操作。可以看个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var localVariable = &apos;private variable&apos;;</span><br><span class="line">    return function bar()&#123;</span><br><span class="line">        return localVariable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getLocalVariable = foo();</span><br><span class="line">getLocalVariable() // private variable</span><br></pre></td></tr></table></figure>
<p>模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Module = (function()&#123;</span><br><span class="line">    var privateProperty = &apos;foo&apos;;</span><br><span class="line"></span><br><span class="line">    function privateMethod(args)&#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">        publicProperty: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">        publicMethod: function(args)&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        privilegedMethod: function(args)&#123;</span><br><span class="line">            return privateMethod(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>模块类似于一个单例对象。由于在上面的代码中我们利用了(function() { … })();的匿名函数形式，因此当编译器解析它的时候会立即执行。 在闭包的执行上下文的外部唯一可以访问的对象是位于返回对象中的公共方法和属性。然而，因为执行上下文被保存的缘故， 所有的私有属性和方法将一直存在于应用的整个生命周期，这意味着我们只有通过公共方法才可以与它们交互。</p>
<p>另一种类型的闭包被称为立即执行的函数表达式（IIFE）。其实它很简单，只不过是一个在全局环境中自执行的匿名函数而已：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function(window)&#123;</span><br><span class="line">          </span><br><span class="line">    var foo, bar;</span><br><span class="line"></span><br><span class="line">    function private()&#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.Module = &#123;</span><br><span class="line"></span><br><span class="line">        public: function()&#123;</span><br><span class="line">            // do something </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure>
<p>对于保护全局命名空间免受变量污染而言，这种表达式非常有用，它通过构建函数作用域的形式将变量与全局命名空间隔离， 并通过闭包的形式让它们存在于整个运行时（runtime）。在很多的应用和框架中，这种封装源代码的方式用处非常的流行， 通常都是通过暴露一个单一的全局接口的方式与外部进行交互。</p>
<h3 id="Call和Apply"><a href="#Call和Apply" class="headerlink" title="Call和Apply"></a>Call和Apply</h3><p>这两个方法内建在所有的函数中（它们是Function对象的原型方法），允许你在自定义上下文中执行函数。 不同点在于，call函数需要参数列表，而apply函数需要你提供一个参数数组。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将函数f作为o的方法，实际上就是重新设置函数f的上下文</span><br><span class="line">f.call(o, 1, 2);    // 3</span><br><span class="line">f.apply(o, [1, 2]); // 3</span><br></pre></td></tr></table></figure></p>
<p>两个结果是相同的，函数f在对象o的上下文中被调用，并提供了两个相同的参数1和2。</p>
<p>在ES5中引入了Function.prototype.bind方法，用于控制函数的执行上下文，它会返回一个新的函数， 并且这个新函数会被永久的绑定到bind方法的第一个参数所指定的对象上，无论该函数被如何使用。 它通过闭包将函数引导到正确的上下文中。对于低版本浏览器，我们可以简单的对它进行实现如下（polyfill）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(!(&apos;bind&apos; in Function.prototype))&#123;</span><br><span class="line">    Function.prototype.bind = function()&#123;</span><br><span class="line">        var fn = this, </span><br><span class="line">            context = arguments[0], </span><br><span class="line">            args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return fn.apply(context, args.concat(arguments));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bind()方法通常被用在上下文丢失的场景下，例如面向对象和事件处理。之所以要这么做， 是因为节点的addEventListener方法总是为事件处理器所绑定的节点的上下文中执行回调函数， 这就是它应该表现的那样。但是，如果你想要使用高级的面向对象技术，或需要你的回调函数成为某个方法的实例， 你将需要手动调整上下文。这就是bind方法所带来的便利之处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function MyClass()&#123;</span><br><span class="line">    this.element = document.createElement(&apos;div&apos;);</span><br><span class="line">    this.element.addEventListener(&apos;click&apos;, this.onClick.bind(this), false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.onClick = function(e)&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>回顾上面bind方法的源代码，你可能会注意到有两次调用涉及到了Array的slice方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments, 1);</span><br><span class="line">[].slice.call(arguments);</span><br></pre></td></tr></table></figure></p>
<p>我们知道，arguments对象并不是一个真正的数组，而是一个类数组对象，虽然具有length属性，并且值也能够被索引， 但是它们不支持原生的数组方法，例如slice和push。但是，由于它们具有和数组类似的行为，数组的方法能够被调用和劫持， 因此我们可以通过类似于上面代码的方式达到这个目的，其核心是利用call方法。</p>
<p>这种调用其他对象方法的技术也可以被应用到面向对象中，我们可以在JavaScript中模拟经典的继承方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass.prototype.init = function()&#123;</span><br><span class="line">    // call the superclass init method in the context of the &quot;MyClass&quot; instance</span><br><span class="line">    MySuperClass.prototype.init.apply(this, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是利用call或apply在子类（MyClass）的实例中调用超类（MySuperClass）的方法。</p>
<h3 id="ES6中的箭头函数"><a href="#ES6中的箭头函数" class="headerlink" title="ES6中的箭头函数"></a>ES6中的箭头函数</h3><p>ES6中的箭头函数可以作为Function.prototype.bind()的替代品。和普通函数不同，箭头函数没有它自己的this值， 它的this值继承自外围作用域。</p>
<p>对于普通函数而言，它总会自动接收一个this值，this的指向取决于它调用的方式。我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  addAll: function (pieces) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    _.each(pieces, function (piece) &#123;</span><br><span class="line">      self.add(piece);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，最直接的想法是直接使用this.add(piece)，但不幸的是，在JavaScript中你不能这么做， 因为each的回调函数并未从外层继承this值。在该回调函数中，this的值为window或undefined， 因此，我们使用临时变量self来将外部的this值导入内部。我们还有两种方法解决这个问题：</p>
<p>使用ES5中的bind()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  addAll: function (pieces) &#123;</span><br><span class="line">    _.each(pieces, function (piece) &#123;</span><br><span class="line">      this.add(piece);</span><br><span class="line">    &#125;.bind(this));</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用ES6中的箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  addAll: function (pieces) &#123;</span><br><span class="line">    _.each(pieces, piece =&gt; this.add(piece));</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6版本中，addAll方法从它的调用者处获得了this值，内部函数是一个箭头函数，所以它集成了外部作用域的this值。</p>
<p>注意：对回调函数而言，在浏览器中，回调函数中的this为window或undefined（严格模式），而在Node.js中， 回调函数的this为global。实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hello(a, callback) &#123;</span><br><span class="line">  callback(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(&apos;weiwei&apos;, function(a) &#123;</span><br><span class="line">  console.log(this === global); // true</span><br><span class="line">  console.log(a); // weiwei</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在你学习高级的设计模式之前，理解这些概念非常的重要，因为作用域和上下文在现代JavaScript中扮演着的最基本的角色。 无论我们谈论的是闭包、面向对象、继承、或者是各种原生实现，上下文和作用域都在其中扮演着至关重要的角色。 如果你的目标是精通JavaScript语言，并且深入的理解它的各个组成，那么作用域和上下文便是你的起点。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" target="_blank" rel="noopener">Understanding Scope and Context in JavaScript</a><br><a href="http://www.2ality.com/2016/02/arrow-functions-vs-bind.html" target="_blank" rel="noopener">Arrow functions vs. bind()</a><br><a href="http://www.html-js.com/article/Sexy-Javascript-understand-the-callback-function-with-the-use-of-Javascript-in" target="_blank" rel="noopener">理解与使用Javascript中的回调函数</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-09T06:45:23.000Z"><a href="/2016/03/09/javascript/Javascript面对对象/">2016-03-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/09/javascript/Javascript面对对象/">Javascipt面对对象</a></h1>
  

    </header>
    <div class="entry">
      
        <p>面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式，主要包括模块化、多态、和封装几种技术。 对JavaScript而言，其核心是支持面向对象的，同时它也提供了强大灵活的基于原型的面向对象编程能力。 本文将会深入的探讨有关使用JavaScript进行面向对象编程的一些核心基础知识，包括对象的创建，继承机制， 最后还会简要的介绍如何借助ES6提供的新的类机制重写传统的JavaScript面向对象代码。</p>
<h3 id="面向对象的几个概念"><a href="#面向对象的几个概念" class="headerlink" title="面向对象的几个概念"></a>面向对象的几个概念</h3><p>在进入正题前，先了解传统的面向对象编程（例如Java）中常会涉及到的概念，大致可以包括：</p>
<ul>
<li>类：定义对象的特征。它是对象的属性和方法的模板定义。</li>
<li>对象（或称实例）：类的一个实例。</li>
<li>属性：对象的特征，比如颜色、尺寸等。</li>
<li>方法：对象的行为，比如行走、说话等。</li>
<li>构造函数：对象初始化的瞬间被调用的方法。</li>
<li>继承：子类可以继承父类的特征。例如，猫继承了动物的一般特性。</li>
<li>封装：一种把数据和相关的方法绑定在一起使用的方法。</li>
<li>抽象：结合复杂的继承、方法、属性的对象能够模拟现实的模型。</li>
<li>多态：不同的类可以定义相同的方法或属性。<br>在JavaScript的面向对象编程中大体也包括这些。不过在称呼上可能稍有不同，例如，JavaScript中没有原生的“类”的概念， 而只有对象的概念。因此，随着你认识的深入，我们会混用对象、实例、构造函数等概念。</li>
</ul>
<h3 id="对象（类）的创建"><a href="#对象（类）的创建" class="headerlink" title="对象（类）的创建"></a>对象（类）的创建</h3><p>在JavaScript中，我们通常可以使用构造函数来创建特定类型的对象。诸如Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。 此外，我们也可以创建自定义的构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br></pre></td></tr></table></figure></p>
<p>按照惯例，构造函数始终都应该以一个大写字母开头（和Java中定义的类一样），普通函数则小写字母开头。 要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象（实例）</li>
<li>将构造函数的作用域赋给新对象（也就是重设了this的指向，this就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>在上面的例子中，我们创建了Person的两个实例person1和person2。 这两个对象默认都有一个constructor属性，该属性指向它们的构造函数Person，也就是说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.constructor == Person);  //true</span><br><span class="line">console.log(person2.constructor == Person);  //true</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义对象的类型检测"><a href="#自定义对象的类型检测" class="headerlink" title="自定义对象的类型检测"></a>自定义对象的类型检测</h3><p>我们可以使用instanceof操作符进行类型检测。我们创建的所有对象既是Object的实例，同时也是Person的实例。 因为所有的对象都继承自Object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1 instanceof Object);  //true</span><br><span class="line">console.log(person1 instanceof Person);  //true</span><br><span class="line">console.log(person2 instanceof Object);  //true</span><br><span class="line">console.log(person2 instanceof Person);  //true</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>我们不建议在构造函数中直接定义方法，如果这样做的话，每个方法都要在每个实例上重新创建一遍，这将非常损耗性能。 ——不要忘了，ECMAScript中的函数是对象，每定义一个函数，也就实例化了一个对象。</p>
<p>幸运的是，在ECMAScript中，我们可以借助原型对象来解决这个问题。</p>
<h3 id="借助原型模式定义对象的方法"><a href="#借助原型模式定义对象的方法" class="headerlink" title="借助原型模式定义对象的方法"></a>借助原型模式定义对象的方法</h3><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向该函数的原型对象， 该对象包含了由特定类型的所有实例共享的属性和方法。也就是说，我们可以利用原型对象来让所有对象实例共享它所包含的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line">// 通过原型模式来添加所有实例共享的方法</span><br><span class="line">// sayName() 方法将会被Person的所有实例共享，而避免了重复创建</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br><span class="line">console.log(person1.sayName === person2.sayName); // true</span><br><span class="line">person1.sayName(); // Weiwei</span><br><span class="line">person2.sayName(); // Lily</span><br></pre></td></tr></table></figure></p>
<p>正如上面的代码所示，通过原型模式定义的方法sayName()为所有的实例所共享。也就是， person1和person2访问的是同一个sayName()函数。同样的，公共属性也可以使用原型模式进行定义。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Chinese (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Chinese.prototype.country = &apos;China&apos;; // 公共属性，所有实例共享</span><br></pre></td></tr></table></figure></p>
<p>当我们new Person()时，返回的Person实例会结合构造函数中定义的属性、行为和原型中定义的属性、行为， 生成最终属于Person实例的属性和行为。</p>
<p>构造函数中定义的属性和行为的优先级要比原型中定义的属性和行为的优先级高，如果构造函数和原型中定义了同名的属性或行为， 构造函数中的属性或行为会覆盖原型中的同名的属性或行为。</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>现在我们来深入的理解一下什么是原型对象。</p>
<p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 也就是说：Person.prototype.constructor指向Person构造函数。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。 当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中称这个指针为[[Prototype]]， 在Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>（目前已被废弃）；而在其他实现中，这个属性对脚本则是完全不可见的。 要注意，这个链接存在于实例与构造函数的原型对象之间，而不是实例与构造函数之间。</p>
<p>这三者关系的示意图如下：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/imgprototype-graph-1.jpg" alt=""></p>
<p>上图展示了Person构造函数、Person的原型对象以及Person现有的两个实例之间的关系。</p>
<ul>
<li>Person.prototype指向了原型对象</li>
<li>Person.prototype.constructor又指回了Person构造函数</li>
<li>Person的每个实例person1和person2都包含一个内部属性（通常为<strong>proto</strong>），person1.<strong>proto</strong>和person2.<strong>proto</strong>指向了原型对象</li>
</ul>
<h3 id="查找对象属性"><a href="#查找对象属性" class="headerlink" title="查找对象属性"></a>查找对象属性</h3><p>从上图我们发现，虽然Person的两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。 这是通过查找对象属性的过程来实现的。</p>
<ol>
<li>搜索首先从对象实例本身开始（实例person1有sayName属性吗？——没有）</li>
<li>如果没找到，则继续搜索指针指向的原型对象（person1.<strong>proto</strong>有sayName属性吗？——有）<br>这也是多个对象实例共享原型所保存的属性和方法的基本原理。</li>
</ol>
<p>注意，如果我们在对象的实例中重写了某个原型中已存在的属性，则该实例属性会屏蔽原型中的那个属性。 此时，可以使用delete操作符删除实例上的属性。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>根据ECMAScript标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。 这个等同于 JavaScript 的 <strong>proto</strong> 属性（现已弃用，因为它不是标准）。 从ECMAScript 5开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。</p>
<p>其中Object.getPrototypeOf()在所有支持的实现中，这个方法返回[[Prototype]]的值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ === Object.getPrototypeOf(person1); // true</span><br><span class="line">Object.getPrototypeOf(person1) === Person.prototype; // true</span><br></pre></td></tr></table></figure></p>
<p>也就是说，Object.getPrototypeOf(p1)返回的对象实际就是这个对象的原型。 这个方法的兼容性请参考该链接。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>要取得对象上所有可枚举的实例属性，可以使用ES5中的Object.keys()方法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(p1); // [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;]</span><br></pre></td></tr></table></figure></p>
<p>此外，如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyName()方法。</p>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>在上面的代码中，如果我们要添加原型属性和方法，就要重复的敲一遍Person.prototype。为了减少这个重复的过程， 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写整个原型对象</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  </span><br><span class="line">  // 这里务必要重新将构造函数指回Person构造函数，否则会指向这个新创建的对象</span><br><span class="line">  constructor: Person, // Attention!</span><br><span class="line"></span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName === person2.sayName); // true</span><br><span class="line"></span><br><span class="line">person1.sayName();  // Weiwei</span><br><span class="line">person2.sayName();  // Lily</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。 注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性设置为true。默认情况下，原生的constructor属性是不可枚举的。 你可以使用Object.defineProperty()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 重设构造函数，只适用于ES5兼容的浏览器</span><br><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性， 而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方的引用， 最大限度的节省了内存。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>大多的面向对象语言都支持两种继承方式：接口继承和实现继承。ECMAScript只支持实现继承，而且其实现继承主要依靠原型链来实现。</p>
<p>前面我们知道，JavaScript中实例的属性和行为是由构造函数和原型两部分共同组成的。如果我们想让Child继承Father， 那么我们就需要把Father构造函数和原型中属性和行为全部传给Child的构造函数和原型。</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>使用原型链作为实现继承的基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。首先我们先回顾一些基本概念：</p>
<p>每个构造函数都有一个原型对象（prototype）<br>原型对象包含一个指向构造函数的指针（constructor）<br>实例都包含一个指向原型对象的内部指针（[[Prototype]]）<br>如果我们让原型对象等于另一个类型的实现，结果会怎么样？显然，此时的原型对象将包含一个指向另一个原型的指针， 相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立， 如此层层递进，就构成了实例与原型的链条。 更详细的内容可以参考这个链接。 先看一个简单的例子，它演示了使用原型链实现继承的基本框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line">  this.fatherValue = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getFatherValue = function () &#123;</span><br><span class="line">  console.log(this.fatherValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">  this.childValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现继承：继承自Father</span><br><span class="line">Child.prototype = new Father();</span><br><span class="line"></span><br><span class="line">Child.prototype.getChildValue = function () &#123;</span><br><span class="line">  console.log(this.childValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new Child();</span><br><span class="line">instance.getFatherValue(); // true</span><br><span class="line">instance.getChildValue();  // false</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，原型链继承的核心语句是Child.prototype = new Father()，它实现了Child对Father的继承， 而继承是通过创建Father的实例，并将该实例赋给Child.prototype实现的。</p>
<p>实现的本质是重写原型对象，代之以一个新类型的实例。也就是说，原来存在于Father的实例中的所有属性和方法， 现在也存在于Child.prototype中了。</p>
<p>这个例子中的实例以及构造函数和原型之间的关系如下图所示：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/imgprototype-chain-inheritance.jpg" alt=""></p>
<p>在上面的代码中，我们没有使用Child默认提供的原型，而是给它换了一个新原型；这个新原型就是Father的实例。 于是，新原型不仅具有了作为一个Father的实例所拥有的全部属性和方法。而且其内部还有一个指针[[Prototype]]，指向了Father的原型。</p>
<ul>
<li>instance指向Child的原型对象</li>
<li>Child的原型对象指向Father的原型对象</li>
<li>getFatherValue()方法仍然还在Father.prototype中</li>
<li>但是，fatherValue则位于Child.prototype中</li>
<li>instance.constructor现在指向的是Father<br>因为fatherValue是一个实例属性，而getFatherValue()则是一个原型方法。既然Child.prototype现在是Father的实例， 那么fatherValue当然就位于该实例中。</li>
</ul>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。例如，instance.getFatherValue()会经历三个搜索步骤：</p>
<ol>
<li>搜索实例</li>
<li>搜索Child.prototype</li>
<li>搜索Father.prototype</li>
</ol>
<h3 id="别忘了Object"><a href="#别忘了Object" class="headerlink" title="别忘了Object"></a>别忘了Object</h3><p>所有的函数都默认原型都是Object的实例，因此默认原型都会包含一个内部指针[[Prototype]]，指向Object.prototype。 这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以， 我们说上面例子展示的原型链中还应该包括另外一个继承层次。关于Object的更多内容，可以参考这篇博客。</p>
<p>也就是说，Child继承了Father，而Father继承了Object。当调用了instance.toString()时， 实际上调用的是保存在Object.prototype中的那个方法。</p>
<h3 id="原型链继承的问题"><a href="#原型链继承的问题" class="headerlink" title="原型链继承的问题"></a>原型链继承的问题</h3><p>首先是顺序，一定要先继承父类，然后为子类添加新方法。</p>
<p>其次，使用原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line">  this.fatherValue = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getFatherValue = function () &#123;</span><br><span class="line">  console.log(this.fatherValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">  this.childValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承了Father</span><br><span class="line">// 此时的原型链为 Child -&gt; Father -&gt; Object</span><br><span class="line">Child.prototype = new Father();</span><br><span class="line"></span><br><span class="line">// 使用字面量添加新方法，会导致上一行代码无效</span><br><span class="line">// 此时我们设想的原型链被切断，而是变成 Child -&gt; Object</span><br><span class="line">// 所以我们不推荐这么写了</span><br><span class="line">Child.prototype = &#123;</span><br><span class="line">  getChildValue: function () &#123;</span><br><span class="line">    console.log(this.childValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new Child();</span><br><span class="line">instance.getChildValue();  // false</span><br><span class="line">instance.getFatherValue(); // error!</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们连续两次修改了Child.prototype的值。由于现在的原型包含的是一个Object的实例， 而非Father的实例，因此我们设想中的原型链已经被切断——Child和Father之间已经没有关系了。</p>
<p>最后，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下， 给超类型的构造函数传递参数。因此，我们很少单独使用原型链。</p>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>借用构造函数（constructor stealing）的基本思想如下：即在子类构造函数的内部调用超类型构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Father (name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">  // 继承了Father，同时传递了参数</span><br><span class="line">  // 之所以这么做，是为了获得Father构造函数中的所有属性和方法</span><br><span class="line">  // 之所以用call，是为了修正Father内部this的指向</span><br><span class="line">  Father.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Child(&quot;weiwei&quot;);</span><br><span class="line">instance1.colors.push(&apos;black&apos;);</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line">console.log(instance1.name); // weiwei</span><br><span class="line"></span><br><span class="line">var instance2 = new Child(&quot;lily&quot;);</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line">console.log(instance2.name); // lily</span><br></pre></td></tr></table></figure></p>
<p>为了确保Father构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h3 id="借用构造函数的缺点"><a href="#借用构造函数的缺点" class="headerlink" title="借用构造函数的缺点"></a>借用构造函数的缺点</h3><p>同构造函数一样，无法实现方法的复用（所有的方法会被重复创建一份）。</p>
<h3 id="组合使用原型链和借用构造函数"><a href="#组合使用原型链和借用构造函数" class="headerlink" title="组合使用原型链和借用构造函数"></a>组合使用原型链和借用构造函数</h3><p>通常，我们会组合使用原型链继承和借用构造函数来实现继承。也就是说，使用原型链实现对原型属性和方法的继承， 而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 我们改造最初的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 父类构造函数</span><br><span class="line">function Person (name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类方法</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// --------------</span><br><span class="line"></span><br><span class="line">// 子类构造函数</span><br><span class="line">function Student (name, age, job, school) &#123;</span><br><span class="line">  // 继承父类的所有实例属性（获得父类构造函数中的属性）</span><br><span class="line">  Person.call(this, name, age, job);</span><br><span class="line">  this.school = school; // 添加新的子类属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类的原型方法（获得父类原型链上的属性和方法）</span><br><span class="line">Student.prototype = new Person();</span><br><span class="line"></span><br><span class="line">// 新增的子类方法</span><br><span class="line">Student.prototype.saySchool = function () &#123;</span><br><span class="line">  console.log(this.school);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var student1 = new Student(&apos;Lily&apos;, 25, &apos;Doctor&apos;, &quot;Southeast University&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName === student1.sayName); // true</span><br><span class="line"></span><br><span class="line">person1.sayName();  // Weiwei</span><br><span class="line">student1.sayName(); // Lily</span><br><span class="line">student1.saySchool(); // Southeast University</span><br></pre></td></tr></table></figure></p>
<p>组合集成避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。 而且，instanceof和isPropertyOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="组合继承的改进版：使用Object-create"><a href="#组合继承的改进版：使用Object-create" class="headerlink" title="组合继承的改进版：使用Object.create()"></a>组合继承的改进版：使用Object.create()</h3><p>在上面，我们继承父类的原型方法使用的是Student.prototype = new Person()。 这样做有很多的问题。 改进方法是使用ES5中新增的Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用create()方法传入的第一个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype.constructor); // [Function: Person]</span><br><span class="line"></span><br><span class="line">// 设置 constructor 属性指向 Student</span><br><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure></p>
<p>关于Object.create()的实现，我们可以参考一个简单的polyfill：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createObject(proto) &#123;</span><br><span class="line">    function F() &#123; &#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage:</span><br><span class="line">Student.prototype = createObject(Person.prototype);</span><br><span class="line">从本质上讲，createObject()对传入其中的对象执行了一次浅复制。</span><br></pre></td></tr></table></figure>
<h3 id="ES6中的面向对象语法"><a href="#ES6中的面向对象语法" class="headerlink" title="ES6中的面向对象语法"></a>ES6中的面向对象语法</h3><p>ES6中引入了一套新的关键字用来实现class。 但它并不是映入了一种新的面向对象继承模式。JavaScript仍然是基于原型的，这些新的关键字包括class、 constructor、 static、 extends、 和super。</p>
<p>class关键字不过是提供了一种在本文中所讨论的基于原型模式和构造器模式的面向对象的继承方式的语法糖(syntactic sugar)。</p>
<p>对前面的代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor (name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor (name, age, school) &#123;</span><br><span class="line">    super(name, age, &apos;Student&apos;);</span><br><span class="line">    this.school = school;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  saySchool () &#123;</span><br><span class="line">    console.log(this.school);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu1 = new Student(&apos;weiwei&apos;, 20, &apos;Southeast University&apos;);</span><br><span class="line">var stu2 = new Student(&apos;lily&apos;, 22, &apos;Nanjing University&apos;);</span><br><span class="line"></span><br><span class="line">stu1.sayName(); // weiwei</span><br><span class="line">stu1.saySchool(); // Southeast University</span><br><span class="line"></span><br><span class="line">stu2.sayName(); // lily</span><br><span class="line">stu2.saySchool(); // Nanjing University</span><br></pre></td></tr></table></figure>
<h3 id="类：class"><a href="#类：class" class="headerlink" title="类：class"></a>类：class</h3><p>是JavaScript中现有基于原型的继承的语法糖。ES6中的类并不是一种新的创建对象的方法，只不过是一种“特殊的函数”， 因此也包括类表达式和类声明， 但需要注意的是，与函数声明不同的是，类声明不会被提升。 参考链接</p>
<h3 id="类构造器：constructor"><a href="#类构造器：constructor" class="headerlink" title="类构造器：constructor"></a>类构造器：constructor</h3><p>constructor()方法是有一种特殊的和class一起用于创建和初始化对象的方法。注意，在ES6类中只能有一个名称为constructor的方法， 否则会报错。在constructor()方法中可以调用super关键字调用父类构造器。如果你没有指定一个构造器方法， 类会自动使用一个默认的构造器。参考链接</p>
<h3 id="类的静态方法：static"><a href="#类的静态方法：static" class="headerlink" title="类的静态方法：static"></a>类的静态方法：static</h3><p>静态方法就是可以直接使用类名调用的方法，而无需对类进行实例化，当然实例化后的类也无法调用静态方法。 静态方法常被用于创建应用的工具函数。参考链接</p>
<h3 id="继承父类：extends"><a href="#继承父类：extends" class="headerlink" title="继承父类：extends"></a>继承父类：extends</h3><p>extends关键字可以用于继承父类。使用extends可以扩展一个内置的对象（如Date），也可以是自定义对象，或者是null。</p>
<h3 id="关键字：super"><a href="#关键字：super" class="headerlink" title="关键字：super"></a>关键字：super</h3><p>super关键字用于调用父对象上的函数。 super.prop和super[expr]表达式在类和对象字面量中的任何方法定义中都有效。</p>
<p>super([arguments]); // 调用父类构造器<br>super.functionOnParent([arguments]); // 调用父类中的方法<br>如果是在类的构造器中，需要在this关键字之前使用。参考链接</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文对JavaScript的面向对象机制进行了较为深入的解读，尤其是构造函数和原型链方式实现对象的创建、继承、以及实例化。 此外，本文还简要介绍了如在ES6中编写面向对象代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-08T14:16:53.000Z"><a href="/2015/11/08/Node.js_进程/当我们谈论cluster时我们在谈论什么/">2015-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/08/Node.js_进程/当我们谈论cluster时我们在谈论什么/">当我们谈论 cluster 时我们在谈论什么</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Node.js 诞生之初就遭到不少这样的吐槽，当然这些都早已不是问题了。</p>
<ol>
<li>可靠性低。</li>
<li>单进程，单线程，只支持单核 CPU，不能充分的利用多核 CPU 服务器。一旦这个进程崩掉，那么整个 web 服务就崩掉了。</li>
</ol>
<p>回想以前用 php 开发 web 服务器的时候，每个 request 都在单独的线程中处理，即使某一个请求发生很严重的错误也不会影响到其它请求。Node.js 会在一个线程中处理大量请求，如果处理某个请求时产生一个没有被捕获到的异常将导致整个进程的退出，已经接收到的其它连接全部都无法处理，对一个 web 服务器来说，这绝对是致命的灾难。</p>
<p>应用部署到多核服务器时，为了充分利用多核 CPU 资源一般启动多个 Node.js 进程提供服务，这时就会使用到 Node.js 内置的 cluster 模块了。相信大多数的 Node.js 开发者可能都没有直接使用到 cluster，cluster 模块对 child_process 模块提供了一层封装，可以说是为了发挥服务器多核优势而量身定做的。简单的一个 fork，不需要开发者修改任何的应用代码便能够实现多进程部署。当下最热门的带有负载均衡功能的 Node.js 应用进程管理器 pm2 便是最好的一个例子，开发的时候完全不需要关注多进程场景，剩余的一切都交给 pm2 处理，与开发者的应用代码完美分离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure>
<p>pm2 确实非常强大，但本文并不讲解 pm2 的工作原理，而是从更底层的进程通信讲起，为大家揭秘使用 Node.js 开发 web 应用时，使用 cluster 模块实现多进程部署的原理。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>说到多进程当然少不了 fork ,在 un*x 系统中，fork 函数为用户提供最底层的多进程实现。</p>
<p>fork() creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process.</p>
<p>The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other.</p>
<p>本文中要讲解的 fork 是 cluster 模块中非常重要的一个方法，当然了，底层也是依赖上面提到的 fork 函数实现。 多个子进程便是通过在master进程中不断的调用 cluster.fork 方法构造出来。下面的结构图大家应该非常熟悉了。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/cluster01_180703.png" alt=""></p>
<p>上面的图非常粗糙， 并没有告诉我们 master 与 worker 到底是如何分工协作的。Node.js 在这块做过比较大的改动，下面就细细的剖析开来。</p>
<h3 id="多进程监听同一端口"><a href="#多进程监听同一端口" class="headerlink" title="多进程监听同一端口"></a>多进程监听同一端口</h3><p>最初的 Node.js 多进程模型就是这样实现的，master 进程创建 socket，绑定到某个地址以及端口后，自身不调用 listen 来监听连接以及 accept 连接，而是将该 socket 的 fd 传递到 fork 出来的 worker 进程，worker 接收到 fd 后再调用 listen，accept 新的连接。但实际一个新到来的连接最终只能被某一个 worker 进程 accpet 再做处理，至于是哪个 worker 能够 accept 到，开发者完全无法预知以及干预。这势必就导致了当一个新连接到来时，多个 worker 进程会产生竞争，最终由胜出的 worker 获取连接。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/cluster02_180703.png" alt=""><br>为了进一步加深对这种模型的理解，我编写了一个非常简单的 demo。</p>
<p>master 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const fork = require(&apos;child_process&apos;).fork;</span><br><span class="line"></span><br><span class="line">var handle = net._createServerHandle(&apos;0.0.0.0&apos;, 3000);</span><br><span class="line"></span><br><span class="line">for(var i=0;i&lt;4;i++) &#123;</span><br><span class="line">   fork(&apos;./worker&apos;).send(&#123;&#125;, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">process.on(&apos;message&apos;, function(m, handle) &#123;</span><br><span class="line">  start(handle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var buf = &apos;hello nodejs&apos;;</span><br><span class="line">var res = [&apos;HTTP/1.1 200 OK&apos;,&apos;content-length:&apos;+buf.length].join(&apos;\r\n&apos;)+&apos;\r\n\r\n&apos;+buf;</span><br><span class="line"></span><br><span class="line">function start(server) &#123;</span><br><span class="line">    server.listen();</span><br><span class="line">    server.onconnection = function(err,handle) &#123;</span><br><span class="line">        console.log(&apos;got a connection on worker, pid = %d&apos;, process.pid);</span><br><span class="line">        var socket = new net.Socket(&#123;</span><br><span class="line">            handle: handle</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.readable = socket.writable = true;</span><br><span class="line">        socket.end(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后直接运行 <code>node master.js</code> 启动服务器，在另一个终端多次运行 <code>ab -n10000 -c100 http://127.0.0.1:3000/</code></p>
<p>各个 worker 进程统计到的请求数分别为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker 63999  got 14561 connections</span><br><span class="line">worker 64000  got 8329  connections</span><br><span class="line">worker 64001  got 2356  connections</span><br><span class="line">worker 64002  got 4885  connections</span><br></pre></td></tr></table></figure>
<p>相信到这里大家也应该知道这种多进程模型比较明显的问题了</p>
<ul>
<li>多个进程之间会竞争 accpet 一个连接，产生惊群现象，效率比较低。</li>
<li>由于无法控制一个新的连接由哪个进程来处理，必然导致各 worker 进程之间的负载非常不均衡。</li>
</ul>
<p>这其实就是著名的”惊群”现象。</p>
<p>简单说来，多线程/多进程等待同一个 socket 事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p>
<p>惊群通常发生在 server 上，当父进程绑定一个端口监听 socket，然后 fork 出多个子进程，子进程们开始循环处理（比如 accept）这个 socket。每当用户发起一个 TCP 连接时，多个子进程同时被唤醒，然后其中一个子进程 accept 新连接成功，余者皆失败，重新休眠。</p>
<h3 id="nginx-proxy"><a href="#nginx-proxy" class="headerlink" title="nginx proxy"></a>nginx proxy</h3><p>现代的 web 服务器一般都会在应用服务器外面再添加一层负载均衡，比如目前使用最广泛的 nginx。<br>利用 nginx 强大的反向代理功能，可以启动多个独立的 node 进程，分别绑定不同的端口，最后由nginx 接收请求然后进行分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line">  upstream cluster &#123; </span><br><span class="line">      server 127.0.0.1:3000; </span><br><span class="line">      server 127.0.0.1:3001; </span><br><span class="line">      server 127.0.0.1:3002; </span><br><span class="line">      server 127.0.0.1:3003; </span><br><span class="line">  &#125; </span><br><span class="line">  server &#123; </span><br><span class="line">       listen 80; </span><br><span class="line">       server_name www.domain.com; </span><br><span class="line">       location / &#123; </span><br><span class="line">            proxy_pass http://cluster;</span><br><span class="line">       &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式就将负载均衡的任务完全交给了 nginx 处理，并且 nginx 本身也相当擅长。再加一个守护进程负责各个 node 进程的稳定性，这种方案也勉强行得通。但也有比较大的局限性，比如想增加或者减少一个进程时还得再去改下 nginx 的配置。该方案与 nginx 耦合度太高，实际项目中并不经常使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，一直在讲解 Node.js 多进程部署时遇到的各种问题。小伙伴们肯定会有非常多的疑问。实际的 Node.js 项目中我们到底是如何利用多进程的呢，并且如何保障各个 worker 进程的稳定性。如何利用 cluster 模块 fork 子进程，父子进程间又是如何实现通信的呢？</p>
<p>下篇将为大家一一揭晓，敬请期待！</p>
<p><a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/" target="_blank" rel="noopener">上篇文章</a>讲解了 Node.js 中多进程部署时遇到的各种问题，那么实际的线上项目中到底是如何利用多进程，如何保障各个 worker 进程稳定性的呢，又是如何利用 cluster 模块 fork 子进程，父子进程间又是如何实现通信的呢？本篇就来一一揭晓。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>回忆一下上篇中提到的最初 Node.js 多进程模型，多个进程绑定同一端口，相互竞争 accpet 新到来的连接。由于无法控制一个新的连接由哪个进程来处理，导致各 worker 进程之间的负载非常不均衡。</p>
<p>于是后面就出现了基于 round-robin 算法的另一种模型。主要思路是 master 进程创建 socket，绑定地址以及端口后再进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。这里使用了<strong>指定</strong>, 所以如何传递以及传递给哪个 worker 完全是可控的。round-robin 只是其中的某种算法而已，当然可以换成其他的。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/cluster03_180703.png" alt=""></p>
<p>同样基于这种模型也给出一个简单的 demo。</p>
<p>master 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const fork = require(&apos;child_process&apos;).fork;</span><br><span class="line"></span><br><span class="line">var workers = [];</span><br><span class="line">for (var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">   workers.push(fork(&apos;./worker&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var handle = net._createServerHandle(&apos;0.0.0.0&apos;, 3000);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = function (err,handle) &#123;</span><br><span class="line">    var worker = workers.pop();</span><br><span class="line">    worker.send(&#123;&#125;,handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>woker 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">process.on(&apos;message&apos;, function (m, handle) &#123;</span><br><span class="line">  start(handle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var buf = &apos;hello Node.js&apos;;</span><br><span class="line">var res = [&apos;HTTP/1.1 200 OK&apos;,&apos;content-length:&apos;+buf.length].join(&apos;\r\n&apos;)+&apos;\r\n\r\n&apos;+buf;</span><br><span class="line"></span><br><span class="line">function start(handle) &#123;</span><br><span class="line">    console.log(&apos;got a connection on worker, pid = %d&apos;, process.pid);</span><br><span class="line">    var socket = new net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = true;</span><br><span class="line">    socket.end(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于只有 master 进程接收客户端连接，并且能够按照特定的算法进行分发， 很好的解决了上篇中提到的由于竞争导致各 worker 进程负载不均衡的硬伤。</p>
<h2 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h2><p>上篇文章开头提到 Node.js 被吐槽稳定性差，进程发生未捕获到的异常就会退出。实际项目中由于各种原因，不可避免最后上线时还是存在各种 bug 以及异常，最终进程退出。</p>
<p>当进程异常退出时，有可能该进程上还有很多未处理完的请求，简单粗暴的使进程直接退出必然导致所有的请求都会丢失，给用户带来非常糟的体验，这就非常需要一个进程优雅退出的方案。</p>
<p>给 process 对象添加 uncaughtException 事件绑定能够避免发生异常时进程直接退出。在回调函数里调用当前运行 server 对象的 close 方法，停止接收新的连接。同时告知 master 进程该 worker 进程即将退出，可以 fork 新的 worker 了。</p>
<p>接着在几秒中之后差不多所有请求都已经处理完毕后，该进程主动退出，其中 timeout 可以根据实际业务场景进行设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  process.exit(1);</span><br><span class="line">&#125;, timeout)</span><br></pre></td></tr></table></figure>
<p>这里面有一个小的细节处理，在关闭服务器之前，后续新接收的 request 全部关闭 keep-alive 特性，通知客户端不需要与该服务器保持 socket 连接了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line">    req.shouldKeepAlive = false;</span><br><span class="line">    res.shouldKeepAlive = false;</span><br><span class="line">    if (!res._header) &#123;</span><br><span class="line">        res.setHeader(&apos;Connection&apos;, &apos;close&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第三方 <code>graceful</code> 模块专门来处理这种场景的，感兴趣的同学可以阅读下源码。</p>
<h2 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h2><p>master 进程除了负责接收新的连接，分发给各 worker 进程处理之外，还得像天使一样默默地守护着这些 worker 进程，保障整个应用的稳定性。一旦某个 worker 进程异常退出就 fork 一个新的子进程顶替上去。</p>
<p>这一切 cluster 模块都已经好处理了，当某个 worker 进程发生异常退出或者与 master 进程失去联系（disconnected）时，master 进程都会收到相应的事件通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">    clsuter.fork();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cluster.on(&apos;disconnect&apos;, function () &#123;</span><br><span class="line">    clsuter.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>推荐使用第三方模块 recluster 和 cfork，已经处理的很成熟了。</p>
<p>这样一来整个应用的稳定性重任就落在 master 进程上了，所以一定不要给 master 太多其它的任务，百分百保证它的健壮性，一旦 master 进程挂掉你的应用也就玩完了。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>master 进程能够接收连接进行分发，同时守护 worker 进程，这一切都离不开进程间的通信。<br>讲了这么多，终于到最核心的地方了，要用多进程模型就一定会涉及到 IPC（进程间通信）了。Node.js 中 IPC 都是在父子进程之间进行，按有无发送 fd 分为 2 种方式。</p>
<h3 id="发送-fd"><a href="#发送-fd" class="headerlink" title="发送 fd"></a>发送 fd</h3><p>当进程间需要发生文件描述符 fd 时，libuv 底层采用消息队列来实现 IPC。master 进程接收到客户端连接分发给 worker 进程处理时就用到了进程间 fd 的传递。</p>
<h3 id="不发送-fd"><a href="#不发送-fd" class="headerlink" title="不发送 fd"></a>不发送 fd</h3><p>这种情况父子进程之间只是发送简单的字符串，并且它们之间的通信是双向的。master 与 worker 间的消息传递便是这种方式。虽然 pipe 能够满足父子进程间的消息传递，但由于 pipe 是半双工的，也就是说必须得创建 2 个 pipe 才可以实现双向的通信，这无疑使得程序逻辑更复杂。</p>
<p>libuv 底层采用 socketpair 来实现全双工的进程通信，父进程 fork 子进程之前会调用 socketpair 创建 2 个 fd，下面是一个最简单的也最原始的利用 socketpair 来实现父子进程间双向通信的 demo。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define BUF_SIZE 100</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int s[2];</span><br><span class="line">    int w,r;</span><br><span class="line">    char * buf = (char*)calloc(1 , BUF_SIZE);</span><br><span class="line">    pid_t pid;</span><br><span class="line">    </span><br><span class="line">    if (socketpair(AF_UNIX,SOCK_STREAM,0,s) == -1 ) &#123;</span><br><span class="line">        printf(&quot;create unnamed socket pair failed:%s\n&quot;, strerror(errno));</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ((pid = fork()) &gt; 0) &#123;</span><br><span class="line">        printf(&quot;Parent process&apos;s pid is %d\n&quot;,getpid());</span><br><span class="line">        close(s[1]);</span><br><span class="line">        char *messageToChild = &quot;a message to child  process!&quot;;</span><br><span class="line">        if ((w = write(s[0] , messageToChild , strlen(messageToChild) ) ) == -1) &#123;</span><br><span class="line">            printf(&quot;Write socket error:%s\n&quot;,strerror(errno));</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">        if ( (r = read(s[0], buf , BUF_SIZE )) == -1) &#123;</span><br><span class="line">          printf(&quot;Pid %d read from socket error:%s\n&quot;,getpid() , strerror(errno) );</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Pid %d read string : %s \n&quot;,getpid(),buf);</span><br><span class="line">    &#125; else if (pid == 0) &#123;</span><br><span class="line">         printf(&quot;Fork child process successed\n&quot;);</span><br><span class="line">         printf(&quot;Child process&apos;s pid is :%d\n&quot;,getpid());</span><br><span class="line">         close(s[0]);</span><br><span class="line">         char *messageToParent = &quot;a message to parent process!&quot;;</span><br><span class="line">         if ((w = write(s[1] , messageToParent , strlen(messageToParent))) == -1 ) &#123;</span><br><span class="line">             printf(&quot;Write socket error:%s\n&quot;,strerror(errno));</span><br><span class="line">             exit(-1);</span><br><span class="line">         &#125;</span><br><span class="line">         sleep(1);</span><br><span class="line">         if ((r = read(s[1], buf , BUF_SIZE )) == -1) &#123;</span><br><span class="line">             printf(&quot;Pid %d read from socket error:%s\n&quot;, getpid() , strerror(errno) );</span><br><span class="line">             exit(-1);</span><br><span class="line">         &#125;</span><br><span class="line">         printf(&quot;Pid %d read string : %s \n&quot;,getpid(),buf); </span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        printf(&quot;Fork failed:%s\n&quot;,strerror(errno));</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存为 socketpair.c 后运行 <code>gcc socketpair.c -o socket &amp;&amp; ./socket</code> 输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent process&apos;s pid is 52853</span><br><span class="line">Fork child process successed</span><br><span class="line">Child process&apos;s pid is :52854</span><br><span class="line">Pid 52854 read string : a message to child  process! </span><br><span class="line">Pid 52853 read string : a message to parent process!</span><br></pre></td></tr></table></figure>
<h3 id="Node-js-中的-IPC"><a href="#Node-js-中的-IPC" class="headerlink" title="Node.js 中的 IPC"></a>Node.js 中的 IPC</h3><p>上面从 libuv 底层方面讲解了父子进程间双向通信的原理，在上层 Node.js 中又是如何实现的呢，让我们来一探究竟。</p>
<p>Node.js 中父进程调用 fork 产生子进程时，会事先构造一个 pipe 用于进程通信，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new process.binding(&apos;pipe_wrap&apos;).Pipe(true);</span><br></pre></td></tr></table></figure>
<p>构造出的 pipe 最初还是关闭的状态，或者说底层还并没有创建一个真实的 pipe，直至调用到 libuv 底层的<code>uv_spawn</code>, 利用 socketpair 创建的全双工通信管道绑定到最初 Node.js 层创建的 pipe 上。</p>
<p>管道此时已经真实的存在了，父进程保留对一端的操作，通过环境变量将管道的另一端文件描述符 fd 传递到子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.envPairs.push(&apos;NODE_CHANNEL_FD=&apos; + ipcFd);</span><br></pre></td></tr></table></figure>
<p>子进程启动后通过环境变量拿到 fd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fd = parseInt(process.env.NODE_CHANNEL_FD, 10);</span><br></pre></td></tr></table></figure>
<p>并将 fd 绑定到一个新构造的 pipe 上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = new Pipe(true);</span><br><span class="line">p.open(fd);</span><br></pre></td></tr></table></figure>
<p>于是父子进程间用于双向通信的所有基础设施都已经准备好了。说了这么多可能还是不太明白吧？ 没关系，我们还是来写一个简单的 demo 感受下。</p>
<p>Node.js 构造出的 pipe 被存储在进程的<code>_channel</code>属性上</p>
<p>master.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line"></span><br><span class="line">var worker = cp.fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">var channel = worker._channel;</span><br><span class="line"></span><br><span class="line">channel.onread = function (len, buf, handle) &#123;</span><br><span class="line">    if (buf) &#123;</span><br><span class="line">        console.log(buf.toString())</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        channel.close()</span><br><span class="line">        console.log(&apos;channel closed&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var message = &#123; hello: &apos;worker&apos;,  pid: process.pid &#125;;</span><br><span class="line">var req = new WriteWrap();</span><br><span class="line">var string = JSON.stringify(message) + &apos;\n&apos;;</span><br><span class="line">channel.writeUtf8String(req, string, null);</span><br></pre></td></tr></table></figure>
<p>worker.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">const channel = process._channel;</span><br><span class="line"></span><br><span class="line">channel.ref();</span><br><span class="line">channel.onread = function (len, buf, handle) &#123;</span><br><span class="line">    if (buf) &#123;</span><br><span class="line">        console.log(buf.toString())</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        process._channel.close()</span><br><span class="line">        console.log(&apos;channel closed&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var message = &#123; hello: &apos;master&apos;,  pid: process.pid &#125;;</span><br><span class="line">var req = new WriteWrap();</span><br><span class="line">var string = JSON.stringify(message) + &apos;\n&apos;;</span><br><span class="line">channel.writeUtf8String(req, string, null);</span><br></pre></td></tr></table></figure>
<p>运行<code>node master.js</code> 输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;hello&quot;:&quot;worker&quot;,&quot;pid&quot;:58731&#125;</span><br><span class="line">&#123;&quot;hello&quot;:&quot;master&quot;,&quot;pid&quot;:58732&#125;</span><br><span class="line">channel closed</span><br></pre></td></tr></table></figure>
<h3 id="进程失联"><a href="#进程失联" class="headerlink" title="进程失联"></a>进程失联</h3><p>在多进程服务器中，为了保障整个 web 应用的稳定性，master 进程需要监控 worker 进程的 exit 以及 disconnect 事件，收到相应事件通知后重启 worker 进程。</p>
<p>exit 事件不用说，disconnect 事件可能很多人就不太明白了。还记得上面讲到的进程优雅退出吗，当捕获到未处理异常时，进程不立即退出，但是会立刻通知 master 进程重新 fork 新的进程，而不是等该进程主动退出后再 fork。具体的做法就是调用 worker进程的 disconnect 方法，从而关闭父子进程用于通信的 channel ，此时父子进程之间失去了联系，此时master 进程会触发 disconnect 事件，fork 一个新的 worker进程。</p>
<p>下面是一个触发<code>disconnect</code>事件的简单 demo</p>
<p>master.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const fork = require(&apos;child_process&apos;).fork;</span><br><span class="line"></span><br><span class="line">var workers = [];</span><br><span class="line">for (var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">     var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">     worker.on(&apos;disconnect&apos;, function () &#123;</span><br><span class="line">         console.log(&apos;[%s] worker %s is disconnected&apos;, process.pid, worker.pid);</span><br><span class="line">     &#125;);</span><br><span class="line">     workers.push(worker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var handle = net._createServerHandle(&apos;0.0.0.0&apos;, 3000);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = function (err,handle) &#123;</span><br><span class="line">    var worker = workers.pop();</span><br><span class="line">    var channel = worker._channel;</span><br><span class="line">    var req = new WriteWrap();</span><br><span class="line">    channel.writeUtf8String(req, &apos;dispatch handle&apos;, handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">const channel = process._channel;</span><br><span class="line">var buf = &apos;hello Node.js&apos;;</span><br><span class="line">var res = [&apos;HTTP/1.1 200 OK&apos;,&apos;content-length:&apos; + buf.length].join(&apos;\r\n&apos;) + &apos;\r\n\r\n&apos; + buf;</span><br><span class="line"></span><br><span class="line">channel.ref(); //防止进程退出</span><br><span class="line">channel.onread = function (len, buf, handle) &#123;</span><br><span class="line">    console.log(&apos;[%s] worker %s got a connection&apos;, process.pid, process.pid);</span><br><span class="line">    var socket = new net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = true;</span><br><span class="line">    socket.end(res);</span><br><span class="line">    console.log(&apos;[%s] worker %s is going to disconnect&apos;, process.pid, process.pid);</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>node master.js</code>启动服务器后，在另一个终端执行多次<code>curl http://127.0.0.1:3000</code>，下面是输出的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[63240] worker 63240 got a connection</span><br><span class="line">[63240] worker 63240 is going to disconnect</span><br><span class="line">[63236] worker 63240 is disconnected</span><br></pre></td></tr></table></figure>
<h2 id="最简单的负载均衡-server"><a href="#最简单的负载均衡-server" class="headerlink" title="最简单的负载均衡 server"></a>最简单的负载均衡 server</h2><p>回到前面讲的 round-robin 多进程服务器模型，用于通信的 channel 除了可以发送简单的字符串数据外，还可以发送文件描述符，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.writeUtf8String(req, string, null);</span><br></pre></td></tr></table></figure>
<p>最后一个参数便是要传递的 fd。round-robin 多进程服务器模型的核心也正式依赖于这个特性。 在上面的 demo 基础上，我们再稍微加工一下，还原在 Node.js 中最原始的处理。</p>
<p>master.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const fork = require(&apos;child_process&apos;).fork;</span><br><span class="line"></span><br><span class="line">var workers = [];</span><br><span class="line">for(var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">    workers.push(fork(__dirname + &apos;/worker.js&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var handle = net._createServerHandle(&apos;0.0.0.0&apos;, 3000);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = function (err,handle) &#123;</span><br><span class="line">    var worker = workers.pop();</span><br><span class="line">    var channel = worker._channel;</span><br><span class="line">    var req = new WriteWrap();</span><br><span class="line">    channel.writeUtf8String(req, &apos;dispatch handle&apos;, handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line">const WriteWrap = process.binding(&apos;stream_wrap&apos;).WriteWrap;</span><br><span class="line">const channel = process._channel;</span><br><span class="line">var buf = &apos;hello Node.js&apos;;</span><br><span class="line">var res = [&apos;HTTP/1.1 200 OK&apos;, &apos;content-length:&apos; + buf.length].join(&apos;\r\n&apos;) + &apos;\r\n\r\n&apos; + buf;</span><br><span class="line"></span><br><span class="line">channel.ref();</span><br><span class="line">channel.onread = function (len, buf, handle) &#123;</span><br><span class="line">    var socket = new net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = true;</span><br><span class="line">    socket.end(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>node master.js</code>， 一个简单的多进程 Node.js web 服务器便跑起来了。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>到此整个 Node.js 的多进程服务器模型，以及底层进程间通信原理就讲完了，也为大家揭开了 cluster 的神秘面纱， 相信大家对 cluster 有了更深刻的认识。祝大家 Node.js 的开发旅途上玩得更愉快！</p>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/" target="_blank" rel="noopener">http://taobaofed.org/blog/2015/11/03/nodejs-cluster/</a><br><a href="http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/" target="_blank" rel="noopener">http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-05T14:16:53.000Z"><a href="/2015/11/05/Node.js_事件/初识单线程的Node.js/">2015-11-05</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/05/Node.js_事件/初识单线程的Node.js/">初识单线程的Node.js</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从Node.js进入人们的视野时，我们所知道的它就由这些关键字组成 <strong>事件驱动、非阻塞I/O、高效、轻量</strong>，它在官网中也是这么描述自己的。</p>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an <strong>event-driven</strong>, <strong>non-blocking I/O model</strong> that makes it <strong>lightweight</strong> and <strong>efficient</strong>.</p>
<p>于是，会有下面的场景出现：<br>当我们刚开始接触它时，可能会好奇：</p>
<ul>
<li><p><strong>为什么在浏览器中运行的 Javascript 能与操作系统进行如此底层的交互？</strong><br>当我们在用它进行文件 I/O 和网络 I/O 的时候，发现方法都需要传入回调，是异步的：</p>
</li>
<li><p><strong>那么这种异步，非阻塞的 I/O 是如何实现的？</strong><br>当我们习惯了用回调来处理 I/O，发现当需要顺序处理时，Callback Hell 出现了，于是有想到了同步的方法：</p>
</li>
<li><p><strong>那么在异步为主的 Node.js，有同步的方法嘛？</strong><br>身为一个前端，你在使用时，发现它的异步处理是基于事件的，跟前端很相似：</p>
</li>
<li><p><strong>那么它如何实现的这种事件驱动的处理方式呢？</strong><br>当我们慢慢写的多了，处理了大量 I/O 请求的时候，你会想：</p>
</li>
<li><p><strong>Node.js 异步非阻塞的 I/O 就不会有瓶颈出现吗？</strong><br>之后你还会想：</p>
</li>
<li><p><strong>Node.js 这么厉害，难道没有它不适合的事情吗？</strong><br>看到这些问题，是否有点头大，别急，带着这些问题我们来慢慢看这篇文章。</p>
</li>
</ul>
<h3 id="Node-js-结构"><a href="#Node-js-结构" class="headerlink" title="Node.js 结构"></a>Node.js 结构</h3><p>从 Node.js 本身入手，先来看看 Node.js 的结构。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/nodestandard.jpeg" alt=""></p>
<p>我们可以看到，Node.js 的结构大致分为三个层次：</p>
<p> Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 <a href="https://github.com/nodejs/node/tree/master/lib" target="_blank" rel="noopener">lib</a> 目录下可以看到。</p>
<ul>
<li>Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc" target="_blank" rel="noopener">node.cc</a></li>
<li>这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。<ul>
<li>V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。</li>
<li>Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。</li>
<li>C-ares：提供了异步处理 DNS 相关的能力。</li>
<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>
</ul>
</li>
</ul>
<h3 id="Libuv"><a href="#Libuv" class="headerlink" title="Libuv"></a>Libuv</h3><p>Libuv 是 Node.js 关键的一个组成部分，它为上层的 Node.js 提供了统一的 API 调用，使其不用考虑平台差距，隐藏了底层实现。</p>
<p>具体它能做什么，官网的这张图体现的很好：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/1807041754libuv.png" alt=""></p>
<p>可以看出，它是一个对开发者友好的工具集，包含定时器，非阻塞的网络 I/O，异步文件系统访问，子进程等功能。它封装了 Libev、Libeio 以及 IOCP，保证了跨平台的通用性。</p>
<p>我们只要先知道它本身是异步和事件驱动的，记住这点，下面的问题就有了答案，我们一一来看。</p>
<p> 与操作系统交互</p>
<p>举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">fs.open(&apos;./test.txt&apos;, &quot;w&quot;, function(err, fd) &#123;</span><br><span class="line">	//..do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的调用过程大致可描述为：<a href="https://github.com/nodejs/node/blob/master/lib/fs.js" target="_blank" rel="noopener">lib/fs.js</a> → <a href="https://github.com/nodejs/node/blob/master/src/node_file.cc" target="_blank" rel="noopener">src/node_file.cc</a> → <a href="https://github.com/nodejs/node/tree/master/deps/uv/src" target="_blank" rel="noopener">uv_fs</a></p>
<p>Node.js 深入浅出上的一幅图：<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/nodelib_180701.png" alt=""></p>
<p>具体来说，当我们调用 <code>fs.open</code> 时，Node.js 通过 <code>process.binding</code> 调用 C/C++ 层面的 <code>Open</code> 函数，然后通过它调用 Libuv 中的具体方法 <code>uv_fs_open</code>，最后执行的结果通过回调的方式传回，完成流程。在图中，可以看到平台判断的流程，需要说明的是，这一步是在编译的时候已经决定好的，并不是在运行时中。</p>
<p>总体来说，我们在 Javascript 中调用的方法，最终都会通过 <code>process.binding</code> 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。</p>
<p>通过这个过程，我们可以发现，实际上，Node.js 虽然说是用的 Javascript，但只是在开发时使用 Javascript 的语法来编写程序。真正的执行过程还是由 V8 将 Javascript 解释，然后由 C/C++ 来执行真正的系统调用，所以并不需要过分担心 Javascript 执行效率的问题。可以看出，Node.js 并不是一门语言，而是一个 <strong>平台</strong>，这点一定要分清楚。</p>
<h3 id="异步、非阻塞-I-O"><a href="#异步、非阻塞-I-O" class="headerlink" title="异步、非阻塞 I/O"></a>异步、非阻塞 I/O</h3><p>通过上文，我们了解到，真正执行系统调用的其实是 Libuv。之前我们提到，Libuv 本身就是异步和事件驱动的，所以，当我们将 I/O 操作的请求传达给 Libuv 之后，Libuv 开启线程来执行这次 I/O 调用，并在执行完成后，传回给 Javascript 进行后续处理。</p>
<p>这里面的 I/O 包括文件 I/O 和 网络 I/O。两者的底层执行略有不同。从上面的 Libuv 官网的图中，我们可以看到，文件 I/O，DNS 等操作，都是依托线程池（Thread Pool）来实现的。而网络 I/O 这一大类，包括：TCP、UDP、TTY 等，是由 epoll、IOCP、kqueue 来具体实现的。</p>
<p>总结来说，一个异步 I/O 的大致流程如下：</p>
<ul>
<li>发起 I/O 调用<ol>
<li>用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；</li>
<li>Node 核心模块会将传入的参数和回调函数封装成一个请求对象；</li>
<li>将这个请求对象推入到 I/O 线程池等待执行；</li>
<li>Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。</li>
</ol>
</li>
<li>执行回调<ol>
<li>I/O 操作完成后，会将结果储存到请求对象的 result 属性上，并发出操作完成的通知；</li>
<li>每次事件循环时会检查是否有完成的 I/O 操作，如果有就将请求对象加入到 I/O 观察者队列中，之后当做事件处理；</li>
<li>处理 I/O 观察者事件时，会取出之前封装在请求对象中的回调函数，执行这个回调函数，并将 result 当参数，以完成 Javascript 回调的目的。</li>
</ol>
</li>
</ul>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/updateloop_180701.png" alt=""></p>
<p>这里面涉及到了 Libuv 本身的一个设计理念，事件循环（Event Loop），它是一个类似于 <code>while true</code> 的无限循环，其核心函数是 <code>uv_run</code>，下文会用到。</p>
<p>从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>说到，事件驱动，对于前端来说，并不陌生。事件，是一个在 GUI 开发时很常用的一个概念，常见的有鼠标事件，键盘事件等等。在异步的多种实现中，事件是一种比较容易理解和实现的方式。</p>
<p>说到事件，一定会想到回调，当我们写了一大堆事件处理函数后，Libuv 如何来执行这些回调呢？这就提到了我们之前说到的 <code>uv_run</code>，先看一张它的执行流程图：<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/loopalive_180701.png" alt=""></p>
<p>在 <code>uv_run</code> 函数中，会维护一系列的监视器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct uv_loop_s uv_loop_t;</span><br><span class="line">typedef struct uv_err_s uv_err_t;</span><br><span class="line">typedef struct uv_handle_s uv_handle_t;</span><br><span class="line">typedef struct uv_stream_s uv_stream_t;</span><br><span class="line">typedef struct uv_tcp_s uv_tcp_t;</span><br><span class="line">typedef struct uv_udp_s uv_udp_t;</span><br><span class="line">typedef struct uv_pipe_s uv_pipe_t;</span><br><span class="line">typedef struct uv_tty_s uv_tty_t;</span><br><span class="line">typedef struct uv_poll_s uv_poll_t;</span><br><span class="line">typedef struct uv_timer_s uv_timer_t;</span><br><span class="line">typedef struct uv_prepare_s uv_prepare_t;</span><br><span class="line">typedef struct uv_check_s uv_check_t;</span><br><span class="line">typedef struct uv_idle_s uv_idle_t;</span><br><span class="line">typedef struct uv_async_s uv_async_t;</span><br><span class="line">typedef struct uv_process_s uv_process_t;</span><br><span class="line">typedef struct uv_fs_event_s uv_fs_event_t;</span><br><span class="line">typedef struct uv_fs_poll_s uv_fs_poll_t;</span><br><span class="line">typedef struct uv_signal_s uv_signal_t;</span><br></pre></td></tr></table></figure>
<p>这些监视器都有对应着一种异步操作，它们通过 <code>uv_TYPE_start</code>，来注册事件监听以及相应的回调。</p>
<p>在 <code>uv_run</code> 执行过程中，它会不断的检查这些队列中是或有 <code>pending</code> 状态的事件，有则触发，而且它在这里只会执行一个回调，避免在多个回调调用时发生竞争关系，因为 Javascript 是单线程的，无法处理这种情况。</p>
<p>上面的图中，对 I/O 操作的事件驱动，表达的比较清楚。除了我们常提到的 I/O 操作，图中还表述了一种情况，timer（定时器）。它与其他两者不同之处在于，它没有单独开立新的线程，而是在事件循环中直接完成的。</p>
<p>事件循环除了维护那些观察者队列，还维护了一个 <code>time</code> 字段，在初始化时会被赋值为0，每次循环都会更新这个值。所有与时间相关的操作，都会和这个值进行比较，来决定是否执行。</p>
<p>在图中，与 timer 相关的过程如下：</p>
<ol>
<li>更新当前循环的 time 字段，即当前循环下的“现在”；</li>
<li>检查循环中是否还有需要处理的任务（handlers/requests），如果没有就不必循环了，即是否 alive。</li>
<li>检查注册过的 timer，如果某一个 timer 中指定的时间落后于当前时间了，说明该 timer 已到期，于是执行其对应的回调函数；</li>
<li>执行一次 I/O polling（即阻塞住线程，等待 I/O 事件发生），如果在下一个 timer 到期时还没有任何 I/O 完成，则停止等待，执行下一个 timer 的回调。如果发生了 I/O 事件，则执行对应的回调；由于执行回调的时间里可能又有 timer 到期了，这里要再次检查 timer 并执行回调。<br>Node.js 会一直调用 <code>uv_run</code> 直到到循环不在 alive。</li>
</ol>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>虽然 Node.js 是以异步为主要模式的，但我们在实际开发中，难免会有一些情况是有时序性的，如果由异步来写，就会写出很丑的 Callback Hell，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.query(&apos;select nickname from users where id=&quot;12&quot;&apos;, function() &#123;</span><br><span class="line">	db.query(&apos;select * from xxx where id=&quot;12&quot;&apos;, function() &#123;</span><br><span class="line">		db.query(&apos;select * from xxx where id=&quot;12&quot;&apos;, function() &#123;</span><br><span class="line">			db.query(&apos;select * from xxx where id=&quot;12&quot;&apos;, function() &#123;</span><br><span class="line">				//...	</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个时候如果有同步方法，就会方便很多。这一点，Node.js 的开发者也想到了，目前大部分的异步操作函数，都存在其对应的同步版本，只需要在其名称后面加上 <code>Sync</code> 即可，不用传入回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var file = fs.readFileSync(&apos;/test.txt&apos;, &#123;&quot;encoding&quot;: &quot;utf-8&#125;);</span><br></pre></td></tr></table></figure>
<p>这写方法还是比较好用的，执行 shell 命令，读取文件等都比较方便。不过，体验不太好的一点就是这种调用的错误收集，它不会像回调函数那样，在第一参数中传入错误信息，它会将错误直接抛出，你需要使用 <code>try...catch</code> 来获取，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data;</span><br><span class="line">try &#123;</span><br><span class="line">  data = fs.readFileSync(&apos;/test.txt&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">	if (e.code == &apos;ENOENT&apos;) &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;</span><br><span class="line"> 	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这些方法如何实现的，我们下回再论。</p>
<h3 id="一些可能的瓶颈"><a href="#一些可能的瓶颈" class="headerlink" title="一些可能的瓶颈"></a>一些可能的瓶颈</h3><p>首先，文件的 I/O 方面，用户代码的运行，事件循环的通知等，是通过 Libuv 维护的线程池来进行操作的，它会运行全部的文件系统操作。既然这样，我们抛开硬盘的影响，对于严谨的 C/C++ 来说，这个线程池一定是有大小限制的。官方默认给出的大小是 <strong>4</strong>。当然是可以改变的。在启动时，通过设置 <code>UV_THREADPOOL_SIZE</code> 来改变这个值即可。不过，最大也只能是 <strong>128</strong>，因为这个是涉及到内存占用的。</p>
<p>这个线程池对于所有的事件循环是共享的。当一个函数要使用线程池的时候（比如调用 <code>uv_queue_work</code>），Libuv 会预先分配并初始化 <code>UV_THREADPOOL_SIZE</code> 所允许的线程出来。而<strong>128</strong> 占用的内存大约是 1MB，如果设置的太高，当使用线程池频繁时，会因为内存占用过多而降低线程的性能。<a href="https://github.com/libuv/libuv/blob/master/docs/src/threadpool.rst" target="_blank" rel="noopener">具体说明</a>;</p>
<p>对于网络 I/O 方面，以 Linux 系统下来说，网络 I/O 采用的是 epoll 这个异步模型。它的优点是采用了事件回调的方式，大大降低了文件描述符的创建（Linux下什么都是文件）。</p>
<p>在每次调用 <code>epoll_wait</code> 时，实际返回的是就绪描述符的数量，根据这个值，去 epoll 指定的数组里面取对应数量的描述符，是一种 <strong>内存映射</strong> 的方式，减少了文件描述符的复制开销。</p>
<p>上面提到的 epoll 指定的数组，它的大小即可监听的数量大小，它在不同的系统下，有不同的默认值，可见这里 <a href="https://github.com/nodejs/node/blob/master/deps/uv/src/unix/linux-syscalls.c#L80" target="_blank" rel="noopener">epoll create</a>。</p>
<p>有了大小的限制，还远不够，为了保证运行的稳定，防止你在调用 epoll 函数时，指针越界，导致内存泄漏。还会用到另外一个值 <code>maxevents</code>，它是 <code>epoll_wait</code> 所能处理的最大数量，在调用 <code>epoll_wait</code> 时可以指定。一般情况下小于创建时（epoll_create）的数组大小，当然，也可以设置的比 size 大，不过应该没什么用。可以想到如果就绪的事件很多，超过了 <code>maxevents</code>，那么超出的事件就要等待前面的事件处理完成，才可以继续，可能会导致效率的下降。</p>
<p>在这种情况下，你可能会担心事件会丢失。其实，是不会丢失的，它会通过 <code>ep_collect_ready_items</code> 将这些事件保存在一个队列中，在下一个 <code>epoll_wait</code> 再进行通知。</p>
<h3 id="Node-js-不适合做什么"><a href="#Node-js-不适合做什么" class="headerlink" title="Node.js 不适合做什么"></a>Node.js 不适合做什么</h3><p>虽然看起来，Node.js 可以做很多事情，并且拥有很高的性能。比如做聊天室，搭建 Blog 等等，这些 I/O 密集型的应用，是比较适合 Node.js 的。</p>
<p>但是，有一种类型的应用，可能 Node.js 处理起来会比较吃力，那就是 CPU 密集型的应用。前文提到，Libuv 通过事件循环来处理异步的事件，这是存在于 Node.js 主线程的机制。通过这个机制，所有的 I/O 操作，底层API的调用都变成了异步的。但用户的 Javascript 代码是运行在主线程中的，如果这部分代码运行耗时很长，就会导致事件循环被阻塞。因为，它对于事件的处理，都是按照队列顺序的，所以如果其中的任何一个事务/事件本身没有完成，那么其他的回调、监听器、超时、nextTick() 都得不到运行的机会，被阻塞的事件循环没有机会去处理它们。这样下去，轻则效率降低，重则运行停滞。</p>
<p>比如我们常见的模板渲染，压缩，解压缩，加/解密等操作，都是 Node.js 的软肋，所以使用的时候要考虑到这方面。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Node.js 通过 <code>libuv</code> 来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。</li>
<li>Node.js 实际上是 Javascript 执行线程的单线程，真正的的 I/O 操作，底层 API 调用都是通过多线程执行的。</li>
<li>CPU 密集型的任务是 Node.js 的软肋。</li>
</ul>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://taobaofed.org/blog/2015/10/29/deep-into-node-1/" target="_blank" rel="noopener">http://taobaofed.org/blog/2015/10/29/deep-into-node-1/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-07T06:45:23.000Z"><a href="/2015/06/07/Node.js_模块/Node.js中的循环依赖/">2015-06-07</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/07/Node.js_模块/Node.js中的循环依赖/">Node.js 中的循环依赖</a></h1>
  

    </header>
    <div class="entry">
      
        <p>我们在写node的时候有可能会遇到循环依赖的情况，什么是循环依赖，怎么避免或解决循环依赖问题？</p>
<p>先看一段官网给出的循环依赖的代码:</p>
<p><code>a.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a starting&apos;); </span><br><span class="line">exports.done = false;</span><br><span class="line">var b = require(&apos;./b.js&apos;); // ---&gt; 1</span><br><span class="line">console.log(&apos;in a, b.done = %j&apos;, b.done);</span><br><span class="line">exports.done = true;</span><br><span class="line">console.log(&apos;a done&apos;) // ---&gt; 4</span><br></pre></td></tr></table></figure>
<p><code>b.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;b starting&apos;); </span><br><span class="line">exports.done = false;</span><br><span class="line">var a = require(&apos;./a.js&apos;);  // ---&gt; 2</span><br><span class="line">// console.log(a);  ---&gt; &#123;done:false&#125;</span><br><span class="line">console.log(&apos;in b, a.done = %j&apos;, a.done); // ---&gt; 3</span><br><span class="line">exports.done = true;</span><br><span class="line">console.log(&apos;b done&apos;);</span><br></pre></td></tr></table></figure>
<p><code>main.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;main starting&apos;); </span><br><span class="line">var a = require(&apos;./a.js&apos;); // --&gt; 0</span><br><span class="line">var b = require(&apos;./b.js&apos;);</span><br><span class="line">console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done);</span><br></pre></td></tr></table></figure>
<p>如果我们启动 <code>main.js</code> 会出现什么情况？ 在 <code>a.js</code> 中加载 <code>b.js</code>，然后在<code>b.js</code>中加载 <code>a.js</code>，然后再在 <code>a.js</code>中加载 <code>b.js</code> 吗？这样就会造成循环依赖死循环。</p>
<p>让我们执行看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">main starting</span><br><span class="line">a starting</span><br><span class="line">b starting</span><br><span class="line">in b, a.done = false</span><br><span class="line">b done</span><br><span class="line">in a, b.done = true</span><br><span class="line">a done</span><br><span class="line">in main, a.done=true, b.done=true</span><br></pre></td></tr></table></figure>
<p>可以看到程序并没有陷入死循环，从上面的执行结果可以看到 <code>main.js</code> 中先<code>require</code>了 <code>a.js</code> ，<code>a.js</code> 中执行完了<code>console</code>和<code>export.done=fasle</code>之后，转而去加载<code>b.js</code>，待<code>b.js</code>被load完之后，再返回<code>a.js</code>中执行完剩下的代码。</p>
<p>我在官网的代码基础上增加了一些注释，基本 load 顺序就是按照这个<code>0--&gt;1--&gt;2--&gt;3--&gt;4</code>的顺序去执行的，然后在第二步下面我打印出了<code>require(&#39;./a&#39;)</code>的结果，可以看到是<code>{done:false}</code>，可以猜测在<code>b.js</code>中<code>require(&#39;./a&#39;)</code>的结果是<code>a.js</code>中已经执行到的<code>exports</code>出的值。</p>
<p>上面所说的还只是基于结果基础上的猜测，没有什么说服力，为了验证我的猜测是正确的，我把 Node 的源码稍微翻看了一些，C++ 的代码看不懂没关系，能看懂 JS 的部分就可以了，下面就是 Node 源码的分析（主要是 module 的分析， <a href="https://github.com/nodejs/node" target="_blank" rel="noopener">Node 源码在此</a>）：</p>
<p>将会分析的主要源码：</p>
<ol>
<li>node/src/node.js</li>
<li>node/lib/module.js</li>
</ol>
<h2 id="启动-node-main-js"><a href="#启动-node-main-js" class="headerlink" title="启动 $ node main.js"></a>启动 $ node main.js</h2><p>C++ 的代码我看不懂，总而言之，在我查了资料之后知道当我们在<code>shell</code>中输入<code>node main.js</code>之后，会先执行 <code>node/src/node.cc</code>，然后会执行 <code>node/src/node.js</code>， 所以C++代码不分析，从分析 <code>node/src/node.js</code> 开始（只会分析和主题相关的代码）。</p>
<h2 id="node-js-源码分析"><a href="#node-js-源码分析" class="headerlink" title="node.js 源码分析"></a>node.js 源码分析</h2><p><code>node.js</code>文件主要结构为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function(process) &#123;</span><br><span class="line"></span><br><span class="line">    this.global = this</span><br><span class="line">    </span><br><span class="line">    function startup() &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    startup()</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种闭包代码很常见，从名字可以看出，此处为启动文件。接下来看看 startup 函数中有一大块条件语句，我删除大多数无关代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (process.argv[1]) &#123;</span><br><span class="line">     // ...</span><br><span class="line">    </span><br><span class="line">    var Module = NativeModule.require(&apos;module&apos;);</span><br><span class="line">    Module.runMain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把无关的代码基本都删除了。可以看到这段代码主要做的事是先通过 Native 引入<code>module</code>模块，执行 <code>Module.runMain()</code>。</p>
<p>很多人都知道 <code>require</code> 核心代码，如 require(‘path’)，不需要写全路径，Node 是怎样做到的呢？</p>
<blockquote>
<p>Node 采用了 V8 附带的 js2c.py 工具，将所有内置的 JavasSript 代码( src/node.js 和 lib/*.js) 转成 c++ 里面的数组生成 node_navtives.h 头文件。<br>在这个过程中， JavasSript 以字符串的形式存储在 node 命名空间中， 是不可直接执行的。<br>在启动 Node 进程时， JavaScript 代码直接加载进内存中。</p>
<p>Node 在启动时，会生成一个全局变量 process， 并提供 binding() 方法来协助加载内建模块。</p>
</blockquote>
<p>上面大段介绍基本引自朴老师的「深入浅出 Node.js」。大概理解就是在启动命令的时候，Node 会把 <code>node.js</code> 和 <code>lib/*.js</code> 的内容都放到 <code>process</code> 中传入当前闭包中，我们在当前函数就可以通过<code>process.binding(&#39;natives&#39;)</code>取出来放到 _source 中，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function NativeModule(id) &#123;</span><br><span class="line">  this.filename = id + &apos;.js&apos;;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.exports = &#123;&#125;;</span><br><span class="line">  this.loaded = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeModule._source = process.binding(&apos;natives&apos;);</span><br><span class="line">NativeModule._cache = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看<code>NativeModule.require</code>做了哪些事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NativeModule.require = function(id) &#123;</span><br><span class="line">  if (id == &apos;native_module&apos;) &#123;</span><br><span class="line">    return NativeModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var cached = NativeModule.getCached(id);</span><br><span class="line">  if (cached) &#123;</span><br><span class="line">    return cached.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var nativeModule = new NativeModule(id);</span><br><span class="line"></span><br><span class="line">  nativeModule.cache();</span><br><span class="line">  nativeModule.compile();</span><br><span class="line"></span><br><span class="line">  return nativeModule.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这上面的代码表明内建模块被缓存，就直接返回内建模块的<code>exports</code>，如果没有的话，就生成一个核心模块的实例，然后先把模块根据id来<code>cache</code>，然后调用<code>nativeModule.compile</code>接口编译源文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NativeModule.getSource = function(id) &#123;</span><br><span class="line">  return NativeModule._source[id];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.wrap = function(script) &#123;</span><br><span class="line">  return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.wrapper = [</span><br><span class="line">  &apos;(function (exports, require, module, __filename, __dirname) &#123;\n&apos;,</span><br><span class="line">  &apos;\n&#125;);&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NativeModule.prototype.compile = function() &#123;</span><br><span class="line">  var source = NativeModule.getSource(this.id);</span><br><span class="line">  source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">  var fn = runInThisContext(source, &#123;</span><br><span class="line">    filename: this.filename,</span><br><span class="line">    lineOffset: -1</span><br><span class="line">  &#125;);</span><br><span class="line">  fn(this.exports, NativeModule.require, this, this.filename);</span><br><span class="line"></span><br><span class="line">  this.loaded = true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.prototype.cache = function() &#123;</span><br><span class="line">  NativeModule._cache[this.id] = this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cache 是把实例根据 id 放到 _cache 对象中。先从 _source 中取出对应id的源文件字符串，包上一层<br><code>(function (exports, require, module, __filename, __dirname) {\n&#39;,&#39;\n});</code>。比如<code>main.js</code>最终变成如下JS代码的字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line"> // 如果是main.js</span><br><span class="line">     console.log(&apos;main starting&apos;); </span><br><span class="line">    var a = require(&apos;./a.js&apos;); // --&gt; 0</span><br><span class="line">    var b = require(&apos;./b.js&apos;);</span><br><span class="line">    console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>runInThisContext</code>是将被包装后的源字符串转成可执行函数，（<code>runInThisContext</code>来自<code>contextify</code>模块），<code>runInThisContext</code>的作用，类似<code>eval</code>，再执行这个被<code>eval</code>后的函数，就算被 load 完成了，最后把 load 设为 true。</p>
<p>可以看到<code>fn</code>的实参为 <code>this.exports; NativeModule.require; this; this.filename;</code>。</p>
<p>所以<code>require(&#39;module&#39;)</code>的作用是加载<code>/lib/module.js</code>文件。让我们再回到 startup 函数，加载完 module.js，紧接着运行 <code>Module.runMain()</code>方法。（估计有人忘了前面的startup函数是干嘛的，我再放一次，省得再拉回去了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (process.argv[1]) &#123;</span><br><span class="line">     // ...</span><br><span class="line">    </span><br><span class="line">    var Module = NativeModule.require(&apos;module&apos;);</span><br><span class="line">    Module.runMain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="module-js源码分析"><a href="#module-js源码分析" class="headerlink" title="module.js源码分析"></a>module.js源码分析</h2><p>上面走完了<code>NatvieModule</code>的加载代码。再看看<code>module.js</code>是怎样加载用户使用的文件的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent) &#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.exports = &#123;&#125;;</span><br><span class="line">  this.parent = parent;</span><br><span class="line">  if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.filename = null;</span><br><span class="line">  this.loaded = false;</span><br><span class="line">  this.children = [];</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Module;</span><br><span class="line"></span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line">Module._pathCache = &#123;&#125;;</span><br><span class="line">Module._extensions = &#123;&#125;;</span><br><span class="line">var modulePaths = [];</span><br><span class="line">Module.globalPaths = [];</span><br><span class="line"></span><br><span class="line">Module.wrapper = NativeModule.wrapper;</span><br><span class="line">Module.wrap = NativeModule.wrap;</span><br></pre></td></tr></table></figure>
<p>这是<code>Module</code>的构造函数，<code>Module.wrapper</code>和<code>Module.wrap</code>，是由<code>NativeModule</code>赋值来的，<code>Module._cache</code>是个空对象，存放所有被 load 后的模块 id。</p>
<p>在<code>node.js</code>文件的 startup 函数中，最后一步走到<code>Module.runMain()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.runMain = function() &#123;</span><br><span class="line">  // Load the main module--the command line argument.</span><br><span class="line">  Module._load(process.argv[1], null, true);</span><br><span class="line">  // Handle any nextTicks added in the first tick of the program</span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>runMain</code>方法中调用了<code>_load</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">  var filename = Module._resolveFilename(request, parent);</span><br><span class="line">  var cachedModule = Module._cache[filename];</span><br><span class="line">  </span><br><span class="line">  if (cachedModule) &#123;</span><br><span class="line">    return cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var module = new Module(filename, parent);</span><br><span class="line">  Module._cache[filename] = module;</span><br><span class="line"></span><br><span class="line">  module.load(filename);</span><br><span class="line">  </span><br><span class="line">  return module.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码照例我删除了一些不是很相关的代码，从剩下的代码可以看出<code>_load</code>函数的主要干了两件事（还有一件加载NativeModule的代码被我删掉了）:</p>
<ol>
<li>先判断当前的源文件有没有被加载过，如果 _cache 对象中存在，直接返回 _cache 中的exports对象</li>
<li>如果没有被加载过，新建这个源文件的 module 的实例，并存放到 _cache 中，然后调用 load 方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = function(filename) &#123;</span><br><span class="line">  this.filename = filename;</span><br><span class="line">  this.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">  var extension = path.extname(filename) || &apos;.js&apos;;</span><br><span class="line">  if (!Module._extensions[extension]) extension = &apos;.js&apos;;</span><br><span class="line">  Module._extensions[extension](this, filename);</span><br><span class="line">  this.loaded = true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>load</code>方法中判断源文件的扩展名是什么，默认是<code>&#39;.js&#39;</code>，（我这里也只分析后缀是 <code>.js</code> 的情况），然后调用 <code>Module._extensions[extension]()</code> 方法，并传入 this 和 filename；当<code>extension</code>是<code>&#39;.js&#39;</code>的时候， 调用<code>Module._extensions[&#39;.js&#39;]()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Native extension for .js</span><br><span class="line">Module._extensions[&apos;.js&apos;] = function(module, filename) &#123;</span><br><span class="line">  var content = fs.readFileSync(filename, &apos;utf8&apos;);</span><br><span class="line">  module._compile(internalModule.stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法是读到源文件的字符串后，调用<code>module._compile</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line"></span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  function require(path) &#123;</span><br><span class="line">    return self.require(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var dirname = path.dirname(filename);</span><br><span class="line">  // create wrapper function</span><br><span class="line">  var wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  var compiledWrapper = runInThisContext(wrapper,</span><br><span class="line">                                      &#123; filename: filename, lineOffset: -1 &#125;);</span><br><span class="line"></span><br><span class="line">  var args = [self.exports, require, self, filename, dirname];</span><br><span class="line">  return compiledWrapper.apply(self.exports, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实跟<code>NativeModule</code>的<code>_complie</code>做的事情差不多。先把源文件<code>content</code>包装一层<code>(function (exports, require, module, __filename, __dirname) {\n&#39;,&#39;\n});</code>， 然后通过 <code>runInThisContext</code>把字符串转成可执行的函数，最后把<br><code>self.exports, require, self, filename, dirname</code> 这几个实参传入可执行函数中。</p>
<p><code>require</code> 方法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.require = function(path) &#123;</span><br><span class="line">  return Module._load(path, this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环依赖的时候为什么不会无限循环引用"><a href="#循环依赖的时候为什么不会无限循环引用" class="headerlink" title="循环依赖的时候为什么不会无限循环引用"></a>循环依赖的时候为什么不会无限循环引用</h2><p>所谓的循环依赖就是在两个不同的文件中互相应用了对方。假设按照最上面官网给出的例子中，</p>
<p>在 <code>main.js</code> 中:</p>
<ol>
<li><code>require(&#39;./a.js&#39;)</code>；此时会调用 <code>self.require()</code>,<br>然后会走到<code>module._load</code>，在<code>_load</code>中会判断<code>./a.js</code>是否被load过，当然运行到这里，<code>./a.js</code>还没被 load 过，所以会走完整个load流程，直到<code>_compile</code>。</li>
<li>运行<code>./a.js</code>，运行到 <code>exports.done = false</code> 的时候，给 esports 增加了一个属性。此时的 <code>exports={done: false}</code>。</li>
<li>运行<code>require(&#39;./b.js&#39;)</code>，同 第 1 步。</li>
<li>运行<code>./b.js</code>，到<code>require(&#39;./a.js&#39;)</code>。此时走到<code>_load</code>函数的时候发现<code>./a.js</code>已经被load过了，所以会直接从<code>_cache</code>中返回。所以此时<code>./a.js</code>还没有运行完，<code>exports = {done.false}</code>，那么返回的结果就是 <code>in b, a.done = false</code>;</li>
<li><code>./b.js</code>全部运行完毕，回到<code>./a.js</code>中，继续向下运行，此时的<code>./b.js</code>的 <code>exports={done:true}</code>， 结果自然是<code>in main, a.done=true, b.done=true</code></li>
</ol>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://segmentfault.com/a/1190000004151411" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004151411</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-IO/">Node.js_IO</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-JS基础/">Node.js_JS基础</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-事件/">Node.js_事件</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-入门/">Node.js_入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js-异步编程/">Node.js_异步编程</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-模块/">Node.js_模块</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-测试/">Node.js_测试</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-网络/">Node.js_网络</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-进程/">Node.js_进程</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-错误处理和调试/">Node.js_错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/区块链/">区块链</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/安全/">安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>