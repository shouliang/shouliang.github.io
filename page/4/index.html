<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-04T06:45:23.000Z"><a href="/2014/05/04/express/express(1)基础知识/">2014-05-04</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/04/express/express(1)基础知识/">一.基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-认识express"><a href="#1-认识express" class="headerlink" title="1.认识express"></a>1.认识express</h3><hr>
<p>npm提供了大量的第三方模块，其中不乏许多Web框架，比如其中的一个轻量级的Web框架 ——— Express。</p>
<p>Express是一个简洁、灵活的node.js Web应用开发框架, 它提供一系列强大的功能，比如：模板解析、静态文件服务、中间件、路由控制等等,并且还可以使用插件或整合其他模块来帮助你创建各种 Web和移动设备应用,是目前最流行的基于Node.js的Web开发框架，并且支持Ejs、jade等多种模板，可以快速地搭建一个具有完整功能的网站。</p>
<p>好，下面开始吧！</p>
<p>1.NPM安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></p>
<p>2.获取、引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure></p>
<p>通过变量“app”我们就可以调用express的各种方法了。</p>
<h3 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h3><hr>
<p>认识了Express框架，我们开始创建我们的第一个express应用。</p>
<p>在我们的默认项目主文件app.js添加如下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">   response.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;); </span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-get请求"><a href="#3-get请求" class="headerlink" title="3.get请求"></a>3.get请求</h3><hr>
<p>前面我们实现了一个简单的express应用，下面我们就开始具体讲述它的具体实现，首先我们先来学习Express的常用方法。</p>
<p>get方法 —— 根据请求路径来处理客户端发出的GET请求。</p>
<p>格式：app.get(path,function(request, response));</p>
<p>path为请求的路径，第二个参数为处理请求的回调函数，有两个参数分别是request和response，代表请求信息和响应信息。</p>
<p>如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">   response.send(<span class="string">'Welcome to the homepage!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">   response.send(<span class="string">'Welcome to the about page!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.send(<span class="string">"404 error!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面示例中，指定了about页面路径、根路径和所有路径的处理方法。并且在回调函数内部，使用HTTP回应的send方法，表示向浏览器发送一个字符串。</p>
<h3 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h3><hr>
<p>1.什么是中间件？</p>
<p>中间件(middleware)就是处理HTTP请求的函数，用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。 它最大的特点就是，一个中间件处理完，可以把相应数据再传递给下一个中间件。</p>
<p>2.一个不进行任何操作、只传递request对象的中间件，大概是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Middleware</span>(<span class="params">request, response, next</span>) </span>&#123; </span><br><span class="line">   next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的next为中间件的回调函数。如果它带有参数，则代表抛出一个错误，参数为错误文本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Middleware</span>(<span class="params">request, response, next</span>) </span>&#123; </span><br><span class="line">   next(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。如果没有调用next方法,后面注册的函数也是不会执行的。</p>
<h3 id="5-all方法"><a href="#5-all方法" class="headerlink" title="5.all方法"></a>5.all方法</h3><hr>
<h4 id="all函数的基本用法"><a href="#all函数的基本用法" class="headerlink" title="all函数的基本用法"></a>all函数的基本用法</h4><p>和get函数不同app.all()函数可以匹配所有的HTTP动词，也就是说它可以过滤所有路径的请求，如果使用all函数定义中间件，那么就相当于所有请求都必须先通过此该中间件。</p>
<p>格式：app.all(path,function(request, response));</p>
<p>如下所示，我们使用all函数在请求之前设置响应头属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html;charset=utf-8"</span> &#125;);      <span class="comment">//设置响应头属性值</span></span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"欢迎来到首页!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"欢迎来到about页面!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"404 - 未找到!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码参数中的“*”表示对所有路径有效，这个方法在给特定前缀路径或者任意路径上处理时会特别有用，不管我们请求任何路径都会事先经过all函数。</p>
<h3 id="6-use方法1"><a href="#6-use方法1" class="headerlink" title="6.use方法1"></a>6.use方法1</h3><hr>
<h4 id="use基本用法1"><a href="#use基本用法1" class="headerlink" title="use基本用法1"></a>use基本用法1</h4><p>use是express调用中间件的方法，它返回一个函数。</p>
<p>格式：app.use([path], function(request, response, next){});</p>
<p>可选参数path默认为”/“。</p>
<p>1.使用中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'/'</span>)));</span><br></pre></td></tr></table></figure></p>
<p>如上，我们就使用use函数调用express中间件设定了静态文件目录的访问路径(这里假设为根路径)。</p>
<p>如何连续调用两个中间件呢，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"method："</span>+request.method+<span class="string">" ==== "</span>+<span class="string">"url："</span>+request.url);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html;charset=utf-8"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">'示例：连续调用两个中间件'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>回调函数的next参数，表示接受其他中间件的调用，函数体中的next()，表示将请求数据传递给下一个中间件。</p>
<p>上面代码先调用第一个中间件，在控制台输出一行信息，然后通过next()，调用第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以req对象就不再向后传递了。</p>
<h3 id="7-use方法2"><a href="#7-use方法2" class="headerlink" title="7.use方法2"></a>7.use方法2</h3><hr>
<h4 id="use基本用法2"><a href="#use基本用法2" class="headerlink" title="use基本用法2"></a>use基本用法2</h4><p>use方法不仅可以调用中间件，还可以根据请求的网址，返回不同的网页内容，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.url == <span class="string">"/"</span>) &#123;</span><br><span class="line">      response.send(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">     response.send(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     next();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.send(<span class="string">"404 error!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。</p>
<h3 id="8-回调函数"><a href="#8-回调函数" class="headerlink" title="8.回调函数"></a>8.回调函数</h3><hr>
<p>Express回调函数有两个参数，分别是request(简称req)和response(简称res)，request代表客户端发来的HTTP请求，response代表发向客户端的HTTP回应，这两个参数都是对象。示例如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-获取主机、路径名"><a href="#9-获取主机、路径名" class="headerlink" title="9.获取主机、路径名"></a>9.获取主机、路径名</h3><hr>
<p>如何使用req对象来处理客户端发来的HTTP请求。</p>
<p>1.req.host返回请求头里取的主机名(不包含端口号)。</p>
<p>2.req.path返回请求的URL的路径名。</p>
<p>如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.path);</span><br><span class="line">    res.send(<span class="string">"req.host获取主机名，req.path获取请求路径名!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-Get请求-query"><a href="#10-Get请求-query" class="headerlink" title="10.Get请求 - query"></a>10.Get请求 - query</h3><hr>
<p>query是一个可获取客户端get请求路径参数的对象属性，包含着被解析过的请求参数对象，默认为{}。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query.参数名);</span><br><span class="line">    res.send(<span class="string">"测试query属性!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过req.query获取get请求路径的对象参数值。</p>
<p>格式：req.query.参数名；请求路径如下示例：</p>
<p>例1： /search?n=Hanmeimei<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.query.n  <span class="comment">// "Hanmeimei"</span></span><br></pre></td></tr></table></figure></p>
<p>例2： /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.query.order  <span class="comment">// "desc"</span></span><br><span class="line">req.query.shoe.color  <span class="comment">// "blue"</span></span><br><span class="line">req.query.shoe.type  <span class="comment">// "converse"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="11-Get请求-param"><a href="#11-Get请求-param" class="headerlink" title="11.Get请求 - param"></a>11.Get请求 - param</h3><hr>
<p>和属性query一样，通过req.param我们也可以获取被解析过的请求参数对象的值。</p>
<p>格式：req.param(“参数名”)；请求路径如下示例：</p>
<p>例1： 获取请求根路径的参数值，如/?n=Lenka，方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.param(<span class="string">"n"</span>)); <span class="comment">//Lenka</span></span><br><span class="line">    res.send(<span class="string">"使用req.param属性获取请求根路径的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>例2：我们也可以获取具有相应路由规则的请求对象，假设路由规则为 /user/:name/，请求路径/user/mike,如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/user/:name/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.param(<span class="string">"name"</span>)); <span class="comment">//mike</span></span><br><span class="line">    res.send(<span class="string">"使用req.param属性获取具有路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>PS：所谓“路由”，就是指为不同的访问路径，指定不同的处理方法。</p>
<h3 id="12-Get请求-params"><a href="#12-Get请求-params" class="headerlink" title="12.Get请求 - params"></a>12.Get请求 - params</h3><hr>
<p>和param相似，但params是一个可以解析包含着有复杂命名路由规则的请求对象的属性。</p>
<p>格式：req.params.参数名；</p>
<p>例1. 如上课时请求根路径的例子，我们就可以这样获取，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/user/:name/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.name); <span class="comment">//mike</span></span><br><span class="line">    res.send(<span class="string">"使用req.params属性获取具有路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>查看运行结果，和param属性功能是一样的，同样获取name参数值。</p>
<p>例2：当然我们也可以请求复杂的路由规则，如/user/:name/:id，假设请求地址为：/user/mike/123，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/user/:name/:id"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id); <span class="comment">//"123"</span></span><br><span class="line">    res.send(<span class="string">"使用req.params属性复杂路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于请求地址具有路由规则的路径来说，属性params比param属性是不是又强大了那么一点点呢！</p>
<h3 id="13-send"><a href="#13-send" class="headerlink" title="13.send"></a>13.send</h3><hr>
<p>send()方法向浏览器发送一个响应信息，并可以智能处理不同类型的数据。格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.send([body|status], [body]);</span><br></pre></td></tr></table></figure></p>
<p>1.当参数为一个String时，Content-Type默认设置为”text/html”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.send(&apos;Hello World&apos;); //Hello World</span><br></pre></td></tr></table></figure></p>
<p>2.当参数为Array或Object时，Express会返回一个JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.send(&#123; user: &apos;tobi&apos; &#125;); //&#123;&quot;user&quot;:&quot;tobi&quot;&#125;</span><br><span class="line">res.send([1,2,3]); //[1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>3.当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应体，比如：200会返回字符”OK”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.send(200); // OK</span><br><span class="line">res.send(404); // Not Found</span><br><span class="line">res.send(500); // Internal Server Error</span><br></pre></td></tr></table></figure></p>
<p>send方法在输出响应时会自动进行一些设置，比如HEAD信息、HTTP缓存支持等等。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-06T07:45:23.000Z"><a href="/2014/04/06/MongoDB/MongoDB(2)文档的增删改查/">2014-04-06</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/06/MongoDB/MongoDB(2)文档的增删改查/">二.文档的增删改查</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简单插入文档"><a href="#1-简单插入文档" class="headerlink" title="1.简单插入文档"></a>1.简单插入文档</h3><hr>
<p>在数据库中，数据插入是最基本的操作，在MongoDB使用db.collection.insert(document)语句来插入文档，如下图：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkinsert1.png" alt=""></p>
<p>document是文档数据，collection是存放文档数据的集合。</p>
<p>例如：所有用户的信息存放在users集合中，每个用户的信息为一个user文档，插入数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert(user);</span><br></pre></td></tr></table></figure></p>
<p>如果collection存在，document会添加到collection目录下， 如果collection不存在，数据库会先创建collection，然后再保存document。</p>
<h3 id="2-批量插入文档"><a href="#2-批量插入文档" class="headerlink" title="2.批量插入文档"></a>2.批量插入文档</h3><hr>
<p>nsert语句不但可以插入单个文档，还可以一次性插入多个文档。</p>
<p>插入多个文档时，insert命令的参数为一个数组，数组元素为BSON格式的文档。</p>
<p>多个文档可以放在一个数组内，一次插入多条数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert([&#123;name:&quot;tommy&quot;&#125;,&#123;name:&quot;xiaoming&quot;&#125;])</span><br></pre></td></tr></table></figure></p>
<p>文档批量插入非常方便，但是使用批量插入时也有一些问题需要注意，因为BSON格式的限制，一次插入的数据量不能超过16M，在一个insert命令中插入多条数据时，MongoDB不保证完全成功或完全失败。</p>
<h3 id="3-查询与投影"><a href="#3-查询与投影" class="headerlink" title="3.查询与投影"></a>3.查询与投影</h3><hr>
<p>在MongoDB中，查询指向特定的文档集合，查询设定条件，指明MongoDB需要返回的文档；查询也可以包含一个投影，指定返回的字段。</p>
<p>如下图，在查询过程指定了一个查询条件和一个排序修饰。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkquery.jpg" alt=""></p>
<p>在关系型数据库中，投影指的是对列的筛选，类似的，在MongoDB中，投影指的是对出现在结果集中的对象属性的筛选。</p>
<h3 id="4-find-方法"><a href="#4-find-方法" class="headerlink" title="4.find()方法"></a>4.find()方法</h3><hr>
<p>MongoDB中查询检索数据时使用find命令，使用方法如下：</p>
<p>语法：<br>db.collection.find(criteria,projection);<br>参数：<br>criteria – 查询条件，文档类型，可选。</p>
<p>projection– 返回的字段，文档类型，可选,若需返回所有字段，则忽略此参数。</p>
<p>find命令两个可选参数，criteria为查询条件，projection为返回的字段，如果不传入条件数据库会返回该集合的所有文档。</p>
<p>如下图简单示例：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkfind.jpg" alt=""></p>
<h3 id="5-修改文档-update命令"><a href="#5-修改文档-update命令" class="headerlink" title="5.修改文档 - update命令"></a>5.修改文档 - update命令</h3><hr>
<p>update命令可以更新指定文档的特定字段值，也可以替换整个文档，如果更新操作会增加文档大小，MongoDB将重新分配空间并重新定位。</p>
<p>语法：<br>db.collection.update(query,update,{upsert:boolean,multi:boolean});<br>参数：<br>query：查询条件，文档，和find中的查询条件写法一致。</p>
<p>update：修改内容，文档。</p>
<p>upsert(可选)：如果值为true，那么当集合中没有匹配文档时，创建文档。默认false。</p>
<p>multi(可选)：如果值为true，那么将更新全部符合条件的文档，否则仅更新一个文档，默认false。</p>
<p>如下示例：将users集合中所有符合条件”age&gt;18”文档的status字段更新为”A”。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkupdate.jpg" alt=""></p>
<h3 id="6-修改文档-save命令"><a href="#6-修改文档-save命令" class="headerlink" title="6.修改文档 - save命令"></a>6.修改文档 - save命令</h3><hr>
<p>save命令可以更新或插入一个新文档，与update命令不同的是，save只能对一个文档进行操作。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save();</span><br></pre></td></tr></table></figure></p>
<p>参数：<br>document：新的文档；</p>
<h3 id="7-删除文档-remove命令"><a href="#7-删除文档-remove命令" class="headerlink" title="7.删除文档 - remove命令"></a>7.删除文档 - remove命令</h3><hr>
<p>需要删除文档时使用remove命令，删除文档可以清理掉不需要的数据，释放存储空间，提升检索效率，但是错误的删除会是一场灾难，因此在执行数据删除操作时需要非常的谨慎！</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">    query,</span><br><span class="line">    justOne</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p>
<p>参数：<br>query：BSON类型，删除文档的条件。</p>
<p>justOne：布尔类型，true：只删除一个文档，false：默认值，删除所有符合条件的文档。</p>
<p>下面是一个是将users集合中所有status=”D”的文档删除操作，对比一下MongoDB和传统SQL数据库删除的操作，看看有哪些不同之处。</p>
<p>与传统SQL比较 - 删除文档</p>
<p>MongoDB</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkremove.jpg" alt=""></p>
<p>传统SQL</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkremove-sql.jpg" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-03T06:45:23.000Z"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">2014-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">一.简单介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是MongoDB"><a href="#1-什么是MongoDB" class="headerlink" title="1.什么是MongoDB"></a>1.什么是MongoDB</h3><hr>
<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个高性能，开源，无模式的文档型数据库，官方给自己的定义是Key-value存储(高性能和高扩展)和传统RDBMS(丰富的查询和功能)之间的一座桥梁。</p>
<h3 id="2-Document和BSON"><a href="#2-Document和BSON" class="headerlink" title="2.Document和BSON"></a>2.Document和BSON</h3><hr>
<p>MongoDB中保存的数据格式为BSON，如：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbson.jpg" alt=""></p>
<p>MongoDB中数据的基本单元称为文档(Document)，它是MongoDB的核心概念，由多个键极其关联的值有序的放置在一起组成，数据库中它对应于关系型数据库的行。</p>
<p>数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p>
<p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON，BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p>
<p>BSON的优点是灵活性高，但它的缺点是空间利用率不是很理想，BSON有三个特点：轻量性、可遍历性、高效性。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-27T12:45:23.000Z"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">2014-03-27</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">六.属性方法</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-ObjectId类型"><a href="#1-ObjectId类型" class="headerlink" title="1.ObjectId类型"></a>1.ObjectId类型</h3><hr>
<h4 id="ObjectId简述"><a href="#ObjectId简述" class="headerlink" title="ObjectId简述"></a>ObjectId简述</h4><p>存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。</p>
<p>使用过MySQL等关系型数据库的友友们都知道，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，MongoDB采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，一次代表：</p>
<p>4字节：UNIX时间戳<br>3字节：表示运行MongoDB的机器<br>2字节：表示生成此_id的进程<br>3字节：由一个随机数开始的计数器生成的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var tSchema = new mongoose.Schema(&#123;&#125;); //默认_id:ObjectId类型</span><br></pre></td></tr></table></figure></p>
<p>每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。</p>
<h3 id="2-添加属性"><a href="#2-添加属性" class="headerlink" title="2.添加属性"></a>2.添加属性</h3><hr>
<h4 id="Schema添加属性值"><a href="#Schema添加属性值" class="headerlink" title="Schema添加属性值"></a>Schema添加属性值</h4><p>前面我们已经讲述了如何定义一个Schema并赋予某些属性值,那能不能先定义后添加属性呢，答案是可以的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var TempSchema = new mongoose.Schema;</span><br><span class="line">TempSchema.add(&#123; name: &apos;String&apos;, email: &apos;String&apos;, age: &apos;Number&apos; &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3.实例方法"></a>3.实例方法</h3><hr>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var saySchema = new mongoose.Schema(&#123;name : String&#125;);</span><br><span class="line">saySchema.method(&apos;say&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;Trouble Is A Friend&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">var say = mongoose.model(&apos;say&apos;, saySchema);</span><br><span class="line">var lenka = new say();</span><br><span class="line">lenka.say(); //Trouble Is A Friend</span><br></pre></td></tr></table></figure></p>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4.静态方法"></a>4.静态方法</h3><hr>
<h4 id="Schema静态方法"><a href="#Schema静态方法" class="headerlink" title="Schema静态方法"></a>Schema静态方法</h4><p>接下来将讲述怎么为Schema创建静态方法。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); </span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.static(&apos;findByName&apos;, function (name, callback) &#123;</span><br><span class="line">    return this.find(&#123; name: name &#125;, callback);</span><br><span class="line">&#125;);</span><br><span class="line">var TestModel = db.model(&quot;test1&quot;, TestSchema );</span><br><span class="line">TestModel.findByName(&apos;tom&apos;, function (err, docs) &#123;</span><br><span class="line"> //docs所有名字叫tom的文档结果集</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-追加方法"><a href="#5-追加方法" class="headerlink" title="5.追加方法"></a>5.追加方法</h3><hr>
<h4 id="Schema追加方法"><a href="#Schema追加方法" class="headerlink" title="Schema追加方法"></a>Schema追加方法</h4><p>有时场景的需要，我们甚至可以为Schema模型追加方法。</p>
<p>为Schema模型追加speak方法，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);</span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.methods.speak = function()&#123;</span><br><span class="line">  console.log(&apos;我的名字叫&apos;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">var TestModel = db.model(&apos;test1&apos;,TestSchema);</span><br><span class="line">var TestEntity = new TestModel(&#123;name:&apos;Lenka&apos;&#125;);</span><br><span class="line">TestEntity.speak();//我的名字叫Lenka</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-22T06:45:23.000Z"><a href="/2014/03/22/Mongoose/Mongoose(5)游标/">2014-03-22</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/22/Mongoose/Mongoose(5)游标/">五.游标</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p>
<p>最常用的查询选项就是限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)。所有这些选项一点要在查询被发送到服务器之前指定。</p>
<h3 id="2-限制返回数量"><a href="#2-限制返回数量" class="headerlink" title="2.限制返回数量"></a>2.限制返回数量</h3><hr>
<h4 id="limit函数的基本用法"><a href="#limit函数的基本用法" class="headerlink" title="limit函数的基本用法"></a>limit函数的基本用法</h4><p>在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那么我们就可以使用limit函数，通过它来限制结果数量。</p>
<p>1.限制数量：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;limit:20&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果匹配的结果不到20个，则返回匹配数量的结果，也就是说limit函数指定的是上限而非下限。</p>
<h3 id="3-跳过结果数量"><a href="#3-跳过结果数量" class="headerlink" title="3.跳过结果数量"></a>3.跳过结果数量</h3><hr>
<h4 id="skip函数的基本用法"><a href="#skip函数的基本用法" class="headerlink" title="skip函数的基本用法"></a>skip函数的基本用法</h4><p>skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。如下示例：</p>
<p>1.跳过数量：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;skip:4&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果查询结果数量中少于4个的话，则不会返回任何结果。</p>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h3><hr>
<h4 id="sort函数的基本用法"><a href="#sort函数的基本用法" class="headerlink" title="sort函数的基本用法"></a>sort函数的基本用法</h4><p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。</p>
<p>1.结果排序：find(Conditions,fields,options,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">  //查询所有数据，并按照age降序顺序返回数据docs</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>sort函数可根据用户自定义条件有选择性的来进行排序显示数据结果。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>limit函数：限制返回结果的数量。</p>
</li>
<li><p>skip函数：略过指定的返回结果数量。</p>
</li>
<li><p>sort函数：对返回结果进行有效排序。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-19T00:45:23.000Z"><a href="/2014/03/19/Mongoose/Mongoose(4)高级查询/">2014-03-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/19/Mongoose/Mongoose(4)高级查询/">四.高级查询</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1.条件查询"></a>1.条件查询</h3><hr>
<p>接下来我们来看一些在查询时会用的常用操作符，通过操作符的使用，我们就可对数据进行更细致性的查询，一起来看一下吧。</p>
<p>“$lt”(小于)，”$lte”(小于等于),”$gt”(大于)，”$gte”(大于等于)，”$ne”(不等于)，”$in”(可单值和多个值的匹配)，”$or”(查询多个键值的任意给定值)，”$exists”(表示是否存在的意思)”$all”。</p>
<h3 id="2-大、小于"><a href="#2-大、小于" class="headerlink" title="2.大、小于"></a>2.大、小于</h3><hr>
<h4 id="gt、-lt简述"><a href="#gt、-lt简述" class="headerlink" title="$gt、$lt简述"></a>$gt、$lt简述</h4><p>查询时我们经常会碰到要根据某些字段进行条件筛选查询，比如说Number类型，怎么办呢，我们就可以使用$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)操作符进行排除性的查询，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage大于18的数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage小于60的数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18,&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询所有nage大于18小于60的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果我们要对类似age字段的数据进行筛选，使用$gt、$lt是不是很方便快捷呢！</p>
<h3 id="3-不匹配"><a href="#3-不匹配" class="headerlink" title="3.不匹配"></a>3.不匹配</h3><hr>
<h4 id="ne简述"><a href="#ne简述" class="headerlink" title="$ne简述"></a>$ne简述</h4><p>$ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定，具体使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123; age:&#123; $ne:24&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    //查询age不等于24的所有数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;name:&#123;$ne:&quot;tom&quot;&#125;,age:&#123;$gte:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询name不等于tom、age&gt;=18的所有数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>$ne可以匹配单个值，也可以匹配不同类型的值。</p>
<h3 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4.匹配"></a>4.匹配</h3><hr>
<h4 id="in简述"><a href="#in简述" class="headerlink" title="$in简述"></a>$in简述</h4><p>和$ne操作符相反，$in相当于包含、等于，查询时查找包含于指定字段条件的数据。具体使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123; age:&#123; $in: 20&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   //查询age等于20的所有数据</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123; age:&#123;$in:[20,30]&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //可以把多个值组织成一个数组</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>$in和$ne除了条件判定不同，用法是不是很相似呀！</p>
<h3 id="5-或者"><a href="#5-或者" class="headerlink" title="5.或者"></a>5.或者</h3><hr>
<h4 id="or"><a href="#or" class="headerlink" title="$or"></a>$or</h4><p>$or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&quot;$or&quot;:[&#123;&quot;name&quot;:&quot;yaya&quot;&#125;,&#123;&quot;age&quot;:28&#125;]&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询name为yaya或age为28的全部文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-存在"><a href="#6-存在" class="headerlink" title="6.存在"></a>6.存在</h3><hr>
<h4 id="exists"><a href="#exists" class="headerlink" title="$exists"></a>$exists</h4><p>$exists操作符，可用于判断某些关键字段是否存在来进行条件查询。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;name: &#123;$exists: true&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询所有存在name属性的文档</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123;telephone: &#123;$exists: false&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  //查询所有不存在telephone属性的文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>$gt(&gt;),$lt(&lt;),$lte(&lt;=),$gte(&gt;=)操作符：针对Number类型的查询具体超强的排除性。</p>
</li>
<li><p>$ne(!=)操作符：相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。</p>
</li>
<li><p>$in操作符：和$ne操作符用法相同，但意义相反。</p>
</li>
<li><p>$or操作符：可查询多个条件，只要满足其中一个就可返回结果值。</p>
</li>
<li><p>$exists操作符：主要用于判断某些属性是否存在。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-14T06:45:23.000Z"><a href="/2014/03/14/Mongoose/Mongoose(3)简单查询/">2014-03-14</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/14/Mongoose/Mongoose(3)简单查询/">三.简单查询</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>查询就是返回一个集合中的文档的子集，Mongoose 模型提供了find、findOne、和findById方法用于文档查询。</p>
<p>这里先添加一些测试数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TestModel.create([</span><br><span class="line">                  &#123; name:&quot;test1&quot;, age:20 &#125;,</span><br><span class="line">                  &#123; name:&quot;test2&quot;, age:30 &#125;,</span><br><span class="line">                  &#123; name:&quot;test3&quot;, age:24 &#125;,</span><br><span class="line">                  &#123; name:&quot;test4&quot;, age:18 &#125;,</span><br><span class="line">                  &#123; name:&quot;test5&quot;, age:60 &#125;,</span><br><span class="line">                  &#123; name:&quot;test6&quot;, age:50, email:&quot;t6@qq.com&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test7&quot;, age:40, email:&quot;t7@163.com&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test8&quot;, age:27 &#125;,</span><br><span class="line">                  &#123; name:&quot;test9&quot;, age:27, email:&quot;t9@yeah.net&quot; &#125;,</span><br><span class="line">                  &#123; name:&quot;test10&quot;,age:65 &#125;</span><br><span class="line">                 ], function(error,docs) &#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;save ok&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-find过滤查询"><a href="#2-find过滤查询" class="headerlink" title="2.find过滤查询"></a>2.find过滤查询</h3><hr>
<p>了解和掌握它的过滤功能，怎么个过滤法呢，请看如下介绍。</p>
<p>1.属性过滤 find(Conditions,field,callback);</p>
<p>field省略或为Null，则返回所有属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回只包含一个键值name、age的所有记录</span><br><span class="line">Model.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;，function(err,docs)&#123;</span><br><span class="line">   //docs 查询结果集</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的，_id是默认返回，如果不要显示加上(“_id”:0)，但是，对其他不需要显示的属性且不是_id，如果设置为0的话将会抛异常或查询无果。</p>
<h3 id="3-findOne查询"><a href="#3-findOne查询" class="headerlink" title="3.findOne查询"></a>3.findOne查询</h3><hr>
<p>与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果。</p>
<p>1.单条数据 findOne(Conditions,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestModel.findOne(&#123; age: 27&#125;, function (err, doc)&#123;</span><br><span class="line">   // 查询符合age等于27的第一条数据</span><br><span class="line">   // doc是查询结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>findOne方法，只返回第一个符合条件的文档数据。</p>
<h3 id="4-findById"><a href="#4-findById" class="headerlink" title="4.findById"></a>4.findById</h3><hr>
<p>与findOne相同，但它只接收文档的_id作为参数，返回单个文档。</p>
<p>1.单条数据 findById(_id, callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestModel.findById(&apos;obj._id&apos;, function (err, doc)&#123;</span><br><span class="line"> //doc 查询结果文档</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同样是单条数据，findById和findOne还是有些区别的。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>find过滤查询 ：find查询时我们可以过滤返回结果所显示的属性个数。</p>
</li>
<li><p>findOne查询 ：只返回符合条件的首条文档数据。</p>
</li>
<li><p>findById查询：根据文档_id来查询文档。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-12T02:45:23.000Z"><a href="/2014/03/12/Mongoose/Mongoose(2)增删改查/">2014-03-12</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/12/Mongoose/Mongoose(2)增删改查/">二.增删改查</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h3><hr>
<p>查询分很多种类型，如条件查询，过滤查询等等，先看最基本的find查询。<br>1.find查询： obj.find(查询条件,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Model.find(&#123;&#125;,function(error,docs)&#123;</span><br><span class="line">   //若没有向find传递参数，默认的是显示所有文档</span><br><span class="line">&#125;);</span><br><span class="line">Model.find(&#123; &quot;age&quot;: 28 &#125;, function (error, docs) &#123;</span><br><span class="line">  if(error)&#123;</span><br><span class="line">    console.log(&quot;error :&quot; + error);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(docs); //docs: age为28的所有文档</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Model保存"><a href="#2-Model保存" class="headerlink" title="2.Model保存"></a>2.Model保存</h3><hr>
<p>Model提供了一个create方法来对数据进行保存。下面我们来看一下示例：</p>
<ol>
<li>Model.create(文档数据, callback))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Model.create(&#123; name:&quot;model_create&quot;, age:26&#125;, function(error,doc)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-Entity保存"><a href="#3-Entity保存" class="headerlink" title="3.Entity保存"></a>3.Entity保存</h3><hr>
<p>entity的保存方法。如下示例：</p>
<ol>
<li>Entity.save(文档数据, callback))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Entity = new Model(&#123;name:&quot;entity_save&quot;,age: 27&#125;);</span><br><span class="line">Entity.save(function(error,doc) &#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>model调用的是create方法，entity调用的是save方法。</p>
<h3 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h3><hr>
<p>数据更新！</p>
<p>1.示例：obj.update(查询条件,更新对象,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var conditions = &#123;name : &apos;test_update&apos;&#125;;</span><br><span class="line">var update = &#123;$set : &#123; age : 16 &#125;&#125;;</span><br><span class="line">TestModel.update(conditions, update, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Update success!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>更新后find一下，此时数据已经修改成功了！</p>
<h3 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h3><hr>
<p>有了数据的保存、更新，就差删除了。</p>
<p>1.示例：obj.remove(查询条件,callback);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var conditions = &#123; name: &apos;tom&apos; &#125;;</span><br><span class="line">TestModel.remove(conditions, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Delete success!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>和update类似吧，有了remove方法我们就可以进行删除操作了。</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><hr>
<p>简单回顾：</p>
<ol>
<li><p>查询：find查询返回符合条件一个、多个或者空数组文档结果。</p>
</li>
<li><p>保存：model调用create方法，entity调用的save方法。</p>
</li>
<li><p>更新：obj.update(查询条件,更新对象,callback)，根据条件更新相关数据。</p>
</li>
<li><p>删除：obj.remove(查询条件,callback)，根据条件删除相关数据。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-09T06:45:23.000Z"><a href="/2014/03/09/Mongoose/Mongoose(1)基础介绍/">2014-03-09</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/09/Mongoose/Mongoose(1)基础介绍/">一.基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-认识Mongoose"><a href="#1-认识Mongoose" class="headerlink" title="1.认识Mongoose"></a>1.认识Mongoose</h3><hr>
<p>什么是Mongoose呢，它于MongoDB又是什么关系呢，它可以用来做什么呢，介绍Mongoose之前，我们先简单了解一下MongoDB。</p>
<p>MongoDB是一个开源的NoSQL数据库，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储(文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，数据格式就是JSON。</p>
<p>介绍了MongoDB，我们下面就要认识Mongoose了。</p>
<ol>
<li>Mongoose是什么？</li>
</ol>
<p>Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。</p>
<ol start="2">
<li>Mongoose能做什么？</li>
</ol>
<p>Mongoose，因为封装了对MongoDB对文档操作的常用处理方法，让NodeJS操作Mongodb数据库变得easy、easy、So easy!</p>
<h3 id="2-使用Mongoose"><a href="#2-使用Mongoose" class="headerlink" title="2.使用Mongoose"></a>2.使用Mongoose</h3><hr>
<ol>
<li><p>安装mongoose：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用mongoose：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用”mongoose”连接数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var db = mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下面代码检查默认数据库test，是否可以正常连接成功?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line">db.connection.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据库连接失败："</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.on(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"------数据库连接成功！------"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-了解集合"><a href="#3-了解集合" class="headerlink" title="3.了解集合"></a>3.了解集合</h3><hr>
<p>MongoDB —— 是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，后面我们会学习如何创建文档并插入内容。</p>
<p>在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。</p>
<p>我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的“文档”，文档又是什么意思呢，请看如下介绍。</p>
<p>文档 —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。</p>
<p>集合 —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。</p>
<p>如果我们要通过Mongoose去创建一个“集合”并对其进行增删改查，该怎么实现呢，到这里我们就要先了解Schema(数据属性模型)、Model、Entity了。</p>
<h3 id="4-Schema"><a href="#4-Schema" class="headerlink" title="4.Schema"></a>4.Schema</h3><hr>
<p>Schema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p>
<p>那如何去定义一个Schema呢，请看示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,<span class="comment">//属性name,类型为String</span></span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,<span class="comment">//属性age,类型为Number,默认为0</span></span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">default</span>:<span class="string">''</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>基本属性类型有：字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等。</p>
<h3 id="5-Model"><a href="#5-Model" class="headerlink" title="5.Model"></a>5.Model</h3><hr>
<p>Model —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。</p>
<p>如何通过Schema来创建Model呢，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);</span><br></pre></td></tr></table></figure></p>
<p>// 创建Model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var TestModel = db.model(&quot;test1&quot;, TestSchema);</span><br></pre></td></tr></table></figure></p>
<p>test1：数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后在保存数据。</p>
<p>拥有了Model，我们也就拥有了操作数据库的金钥匙。</p>
<p>如果你想对某个集合有所作为，那就交给Model模型来处理吧，创建一个Model模型，我们需要指定：1.集合名称，2.集合的Schema结构对象，满足这两个条件，我们就会拥有一个操作数据库的金钥匙。</p>
<h3 id="6-Entity"><a href="#6-Entity" class="headerlink" title="6.Entity"></a>6.Entity</h3><hr>
<p>Entity —— 由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p>
<p>使用Model创建Entity，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var TestEntity = new TestModel(&#123;</span><br><span class="line">       name : &quot;Lenka&quot;,</span><br><span class="line">       age  : 36,</span><br><span class="line">       email: &quot;lenka@qq.com&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(TestEntity.name); // Lenka</span><br><span class="line">console.log(TestEntity.age); // 36</span><br></pre></td></tr></table></figure></p>
<p>创建成功之后，Schema属性就变成了Model和Entity的公共属性了。</p>
<h3 id="7-创建集合"><a href="#7-创建集合" class="headerlink" title="7.创建集合"></a>7.创建集合</h3><hr>
<p>下面是关于一些基础数据的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"><span class="keyword">var</span> db = mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/test"</span>);</span><br><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    age  : &#123; <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="attr">default</span>:<span class="number">0</span> &#125;,</span><br><span class="line">    email: &#123; <span class="attr">type</span>:<span class="built_in">String</span> &#125;,</span><br><span class="line">    time : &#123; <span class="attr">type</span>:<span class="built_in">Date</span>, <span class="attr">default</span>:<span class="built_in">Date</span>.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> TestModel = db.model(<span class="string">"test1"</span>, TestSchema );</span><br><span class="line"><span class="keyword">var</span> TestEntity = <span class="keyword">new</span> TestModel(&#123;</span><br><span class="line">    name : <span class="string">"helloworld"</span>,</span><br><span class="line">    age  : <span class="number">28</span>,</span><br><span class="line">    email: <span class="string">"helloworld@qq.com"</span></span><br><span class="line">&#125;);</span><br><span class="line">TestEntity.save(<span class="function"><span class="keyword">function</span>(<span class="params">error,doc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(error)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"error :"</span> + error);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。</p>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h3><hr>
<p>学习了如何通过Mongoose去创建一个数据库“集合”，还有定义“集合”的基本组成结构并使其具有相应的操作数据库能力。</p>
<p>简单回顾：</p>
<ol>
<li><p>Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。</p>
</li>
<li><p>Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。</p>
</li>
<li><p>Entity：通过Model创建的实体，它也可以操作数据库。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-13T06:45:23.000Z"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">2014-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">三.async</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><hr>
<p>async是一个流程控制库，它就像黑夜中的明灯照亮那陷入callback嵌套泥潭的人们。 这么说虽然有些夸张，但是async确实为我们带来了丰富的嵌套解决方案。</p>
<p>项目地址：</p>
<p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a></p>
<p>npm 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install async</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-serires-tasks-callback"><a href="#2-serires-tasks-callback" class="headerlink" title="2.serires(tasks, callback)"></a>2.serires(tasks, callback)</h3><hr>
<p>首先登场的是series函数，它的作用是串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">    one: function(callback)&#123;</span><br><span class="line">        callback(null, 1);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: function(callback)&#123;</span><br><span class="line">        callback(null, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,function(err, results) &#123; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>series函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式，如示例中的参数为数组，返回的results应该是这样的’[1,2]’。</p>
<h3 id="3-waterfall-tasks-callback"><a href="#3-waterfall-tasks-callback" class="headerlink" title="3.waterfall(tasks,[callback])"></a>3.waterfall(tasks,[callback])</h3><hr>
<p>waterfall和series函数有很多相似之处，都是按顺序依次执行一组函数，不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([  </span><br><span class="line">    function(callback)&#123; </span><br><span class="line">      //task1 </span><br><span class="line">      callback(null,1);       </span><br><span class="line">    &#125;,function(data,callback)&#123;</span><br><span class="line">      //task2 </span><br><span class="line">      callback(null,2); </span><br><span class="line">    &#125; </span><br><span class="line">],function(err,results)&#123;  </span><br><span class="line">    console.log(results); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是waterfall的tasks参数只能是数组类型。</p>
<h3 id="4-parallel-tasks-callback"><a href="#4-parallel-tasks-callback" class="headerlink" title="4.parallel(tasks,[callback])"></a>4.parallel(tasks,[callback])</h3><hr>
<p>parallel函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。 传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>tasks参数可以是一个数组或是json对象，和series函数一样，tasks参数类型不同，返回的results格式会不一样。</p>
<h3 id="5-paralleLimit-tasks-limit-callback"><a href="#5-paralleLimit-tasks-limit-callback" class="headerlink" title="5.paralleLimit(tasks,limit,[callback])"></a>5.paralleLimit(tasks,limit,[callback])</h3><hr>
<p>parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.parallelLimit([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">2,</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-whilst-test-fn-callback"><a href="#6-whilst-test-fn-callback" class="headerlink" title="6.whilst(test,fn,callback)"></a>6.whilst(test,fn,callback)</h3><hr>
<p>相当于while，但其中的异步调用将在完成后才会进行下一次循环。当你需要循环异步的操作的时候，它可以帮助你。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.whilst(</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件。</p>
<p>fn参数就是我们要异步执行的作业，每次fn执行完毕后才会进入下一次循环。</p>
<h3 id="7-doWhilst"><a href="#7-doWhilst" class="headerlink" title="7.doWhilst"></a>7.doWhilst</h3><hr>
<p>相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.doWhilst(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-until-test-fn-callback"><a href="#8-until-test-fn-callback" class="headerlink" title="8.until(test,fn,callback)"></a>8.until(test,fn,callback)</h3><hr>
<p>until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.until(</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-doUntil-fn-test-callback"><a href="#9-doUntil-fn-test-callback" class="headerlink" title="9.doUntil(fn,test,callback)"></a>9.doUntil(fn,test,callback)</h3><hr>
<p>doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.doUntil(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-forever-fn-errback"><a href="#10-forever-fn-errback" class="headerlink" title="10.forever(fn,errback)"></a>10.forever(fn,errback)</h3><hr>
<p>forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async.forever(</span><br><span class="line">    function(next) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-compose-fn1-fn2…"><a href="#11-compose-fn1-fn2…" class="headerlink" title="11.compose(fn1,fn2…)"></a>11.compose(fn1,fn2…)</h3><hr>
<p>使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值。</p>
<p>我们可以使用compose把异步函数f、g、h，组合成f(g(h()))的形式，通过callback得到返回值，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unction fn1(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n * 3);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var demo = async.compose(fn2, fn1);</span><br><span class="line">demo(4, function (err, result) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-auto-tasks-callback"><a href="#12-auto-tasks-callback" class="headerlink" title="12.auto(tasks,[callback])"></a>12.auto(tasks,[callback])</h3><hr>
<p>用来处理有依赖关系的多个任务的执行。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async.auto(&#123;</span><br><span class="line">    getData: function(callback)&#123;</span><br><span class="line">        callback(null, &apos;data&apos;, &apos;converted to array&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    makeFolder: function(callback)&#123;        </span><br><span class="line">        callback(null, &apos;folder&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback, results)&#123;        </span><br><span class="line">        callback(null, &apos;filename&apos;);</span><br><span class="line">    &#125;],</span><br><span class="line">    emailLink: [&apos;writeFile&apos;, function(callback, results)&#123;</span><br><span class="line">        callback(null, &#123;&apos;file&apos;:results.writeFile, &apos;email&apos;:&apos;user@example.com&apos;&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, function(err, results) &#123;</span><br><span class="line">    console.log(&apos;err = &apos;, err);</span><br><span class="line">    console.log(&apos;results = &apos;, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中writeFile依赖getData和makeFolder,emailLink依赖writeFile。</p>
<h3 id="13-queue-worker-concurrency"><a href="#13-queue-worker-concurrency" class="headerlink" title="13.queue(worker,concurrency)"></a>13.queue(worker,concurrency)</h3><hr>
<p>queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。</p>
<p>它有多个点可供回调，如无等候任务时(empty)、全部执行完时(drain)等。</p>
<p>示例：定义一个queue，其worker数量为2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;worker is processing task: &apos;, task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当最后一个任务交给worker执行时，会调用empty函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.empty = function() &#123;</span><br><span class="line">    console.log(&apos;no more tasks wating&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-apply-function-arguments…"><a href="#14-apply-function-arguments…" class="headerlink" title="14.apply(function,arguments…)"></a>14.apply(function,arguments…)</h3><hr>
<p>apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(callback) &#123; </span><br><span class="line">    test(3, callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用apply改写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async.apply(test, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="15-iterator-tasks"><a href="#15-iterator-tasks" class="headerlink" title="15.iterator(tasks)"></a>15.iterator(tasks)</h3><hr>
<p>将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var iter = async.iterator([</span><br><span class="line">    function() &#123; console.log(&apos;111&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;222&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;333&apos;) &#125;</span><br><span class="line">]);</span><br><span class="line">iter();</span><br></pre></td></tr></table></figure>
<p>直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator。</p>
<p>对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null。</p>
<h3 id="16-小结"><a href="#16-小结" class="headerlink" title="16.小结"></a>16.小结</h3><hr>
<p>async模块在流程控制方面给我们带来了比较全面的解决办法，下面我们来回顾一下都有哪几种方案：</p>
<p>串行控制： series、waterfall、compose;</p>
<p>并行控制：</p>
<p>parallel、parallelLimit、queue;</p>
<p>循环控制：<br>whilst、doWhilst、until、doUntil、forever;</p>
<p>其他控制：<br>apply、applyEach、iterator、auto;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/Mocha/">Mocha</a><small>4</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js入门/">Node.js入门</a><small>9</small></li>
  
    <li><a href="/tags/Node错误处理和调试/">Node错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/异步编程/">异步编程</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>