<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>第 13 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog">

  
    <meta property="og:image" content>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-26T12:45:23.000Z"><a href="/2014/01/26/Node.js/入门—Node.js入门(7)实用工具/">2014-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/26/Node.js/入门—Node.js入门(7)实用工具/">入门—七.实用工具</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="UTIL模块的基本介绍"><a href="#UTIL模块的基本介绍" class="headerlink" title="UTIL模块的基本介绍"></a>UTIL模块的基本介绍</h4><p>util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证。</p>
<h3 id="2-转换字符串"><a href="#2-转换字符串" class="headerlink" title="2.转换字符串"></a>2.转换字符串</h3><h4 id="inspect函数的基本用法"><a href="#inspect函数的基本用法" class="headerlink" title="inspect函数的基本用法"></a>inspect函数的基本用法</h4><p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的函数，通常用于调试和错误输出。它至少接受一个参数object，即要转换的对象,我们来学习它的简单用法。使用语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.inspect(<span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Function</span>: <span class="built_in">Object</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3.字符串格式化"></a>3.字符串格式化</h3><hr>
<h4 id="format函数的基本用法"><a href="#format函数的基本用法" class="headerlink" title="format函数的基本用法"></a>format函数的基本用法</h4><p>format函数根据第一个参数，返回一个格式化字符串，第一个参数是一个可包含零个或多个占位符的字符串。每一个占位符被替换为与其对应的转换后的值，支持的占位符有：”%s(字符串)”、”%d(数字&lt;整型和浮点型&gt;)”、”%j(JSON)”、”%(单独一个百分号则不作为一个参数)”。</p>
<p>1：如果占位符没有相对应的参数，占位符将不会被替换.如示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="string">'%s:%s'</span>, <span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo:%s'</span></span><br></pre></td></tr></table></figure>
<p>2：如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔。如示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="string">'%s:%s'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo:bar baz'</span></span><br></pre></td></tr></table></figure>
<p>3：如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串。如示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1 2 3'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-数组验证"><a href="#4-数组验证" class="headerlink" title="4.数组验证"></a>4.数组验证</h3><hr>
<h4 id="isArray函数的基本用法"><a href="#isArray函数的基本用法" class="headerlink" title="isArray函数的基本用法"></a>isArray函数的基本用法</h4><p>isArray函数可以判断对象是否为数组类型，是则返回ture,否则为false。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isArray([]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-日期验证"><a href="#5-日期验证" class="headerlink" title="5.日期验证"></a>5.日期验证</h3><hr>
<h4 id="isDate函数的基本用法"><a href="#isDate函数的基本用法" class="headerlink" title="isDate函数的基本用法"></a>isDate函数的基本用法</h4><p>isDate函数可以判断对象是否为日期类型，是则返回ture,否则返回false。语法如下：</p>
<p>例1：querystring.parse(“字符串”，”分隔符”，”分配符”)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-正则验证"><a href="#6-正则验证" class="headerlink" title="6.正则验证"></a>6.正则验证</h3><hr>
<h4 id="isRegExp函数的基本用法"><a href="#isRegExp函数的基本用法" class="headerlink" title="isRegExp函数的基本用法"></a>isRegExp函数的基本用法</h4><p>isRegExp函数可以判断对象是否为正则类型，是则返回ture,否则返回false。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isRegExp(<span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>请自行验证。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-23T12:45:23.000Z"><a href="/2014/01/23/Node.js/入门—Node.js入门(6)字符串转换/">2014-01-23</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/23/Node.js/入门—Node.js入门(6)字符串转换/">入门—六.字符串转换</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="Query-String模块的基本用法"><a href="#Query-String模块的基本用法" class="headerlink" title="Query String模块的基本用法"></a>Query String模块的基本用法</h4><p>Query String模块用于实现URL参数字符串与参数对象之间的互相转换，提供了”stringify”、”parse”等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助。</p>
<h3 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h3><hr>
<h4 id="stringify函数的基础用法"><a href="#stringify函数的基础用法" class="headerlink" title="stringify函数的基础用法"></a>stringify函数的基础用法</h4><p>stringify函数的作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（”&amp;”）和分配符（”=”））。</p>
<p>例1：querystring.stringify(“对象”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring= <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.stringify(&#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">cool</span>:[<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=bar&amp;cool=xux&amp;cool=yys</span><br></pre></td></tr></table></figure></p>
<h3 id="3-序列化-lt-多参数-gt"><a href="#3-序列化-lt-多参数-gt" class="headerlink" title="3.序列化&lt;多参数&gt;"></a>3.序列化&lt;多参数&gt;</h3><hr>
<h4 id="stringify函数的多参数用法"><a href="#stringify函数的多参数用法" class="headerlink" title="stringify函数的多参数用法"></a>stringify函数的多参数用法</h4><p>stringify函数的多参数用法，上节我们知道了对象被序列化为字符串之后默认是通过分割符（”&amp;”）和分配符（”=”）组成的，那可不可以改变呢，这节我们就来了解一下，是否可以自己去定义组合结果，看下面的小例子</p>
<p>例1：querystring.stringify(“对象”，”分隔符”，”分配符”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.stringify(&#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">cool</span>:[<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;,<span class="string">'*'</span>,<span class="string">'$'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo$bar*cool$xux*cool$yys'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-反序列化"><a href="#4-反序列化" class="headerlink" title="4.反序列化"></a>4.反序列化</h3><hr>
<h4 id="parse函数的基本用法"><a href="#parse函数的基本用法" class="headerlink" title="parse函数的基本用法"></a>parse函数的基本用法</h4><p>接下来就来学习反序列化函数——parse函数，parse函数的作用就是反序列化字符串（默认是由”=”、”&amp;”拼接而成），转换得到一个对象类型。如下示例：</p>
<p>例1：querystring.parse(“字符串”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.parse(<span class="string">'foo=bar&amp;cool=xux&amp;cool=yys'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">cool</span>: [<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-反序列化-lt-多参数-gt"><a href="#5-反序列化-lt-多参数-gt" class="headerlink" title="5.反序列化&lt;多参数&gt;"></a>5.反序列化&lt;多参数&gt;</h3><hr>
<h4 id="parse函数的多参数用法"><a href="#parse函数的多参数用法" class="headerlink" title="parse函数的多参数用法"></a>parse函数的多参数用法</h4><p>和上节stringify函数的多参数用法不同的是，parse函数可以根据用户所自定义的分割符、分配符来反序列化字符串，从而得到相应的对象结果.如下示例：</p>
<p>例1：querystring.parse(“字符串”，”分隔符”，”分配符”)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.parse(<span class="string">'foo@bar$cool@xux$cool@yys'</span>,<span class="string">'@'</span>,<span class="string">'$'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="string">''</span>, <span class="attr">bar</span>: <span class="string">'cool'</span>, <span class="attr">xux</span>: <span class="string">'cool'</span>, <span class="attr">yys</span>: <span class="string">''</span> &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-21T12:45:23.000Z"><a href="/2014/01/21/Node.js/入门—Node.js入门(5)path优化/">2014-01-21</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/Node.js/入门—Node.js入门(5)path优化/">入门—五.path优化</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="path模块的基本用法"><a href="#path模块的基本用法" class="headerlink" title="path模块的基本用法"></a>path模块的基本用法</h4><p>本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率.</p>
<h3 id="2-格式化路径"><a href="#2-格式化路径" class="headerlink" title="2.格式化路径"></a>2.格式化路径</h3><hr>
<h4 id="normalize函数的基础用法"><a href="#normalize函数的基础用法" class="headerlink" title="normalize函数的基础用法"></a>normalize函数的基础用法</h4><p>normalize函数将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与..外，还能去掉多余的斜杠。<br>如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);  </span><br><span class="line"><span class="keyword">var</span> data = path.normalize(<span class="string">'/path///normalize/hi/..'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/path/normalize/'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-组合路径"><a href="#3-组合路径" class="headerlink" title="3.组合路径"></a>3.组合路径</h3><hr>
<h4 id="join函数的基本用法"><a href="#join函数的基本用法" class="headerlink" title="join函数的基本用法"></a>join函数的基本用法</h4><p>join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐. 如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.join(<span class="string">'///you'</span>, <span class="string">'/are'</span>, <span class="string">'//beautiful'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/you/are/beautiful'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-dirname"><a href="#4-dirname" class="headerlink" title="4.dirname"></a>4.dirname</h3><hr>
<h4 id="dirname函数的基本用法"><a href="#dirname函数的基本用法" class="headerlink" title="dirname函数的基本用法"></a>dirname函数的基本用法</h4><p>dirname函数用来返回路径中的目录名. 如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.dirname(<span class="string">'/foo/strong/cool/nice'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/foo/strong/cool'</span></span><br></pre></td></tr></table></figure>
<h3 id="5-basename"><a href="#5-basename" class="headerlink" title="5.basename"></a>5.basename</h3><hr>
<h4 id="basename函数的基础用法"><a href="#basename函数的基础用法" class="headerlink" title="basename函数的基础用法"></a>basename函数的基础用法</h4><p>basename函数可返回路径中的最后一部分，并且可以对其进行条件排除. 如下示例：</p>
<p>例1：path.basename(‘路径字符串’);</p>
<p>例2：path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);    </span><br><span class="line"><span class="keyword">var</span> data1 = path.basename(<span class="string">'/foo/strong/basename/index.html'</span>);</span><br><span class="line"><span class="keyword">var</span> data2 = path.basename(<span class="string">'/foo/strong/basename/index.html'</span>,<span class="string">'.html'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data1 + <span class="string">' "and" '</span> + data2);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'index.html "and" index'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-extname"><a href="#6-extname" class="headerlink" title="6.extname"></a>6.extname</h3><hr>
<h4 id="extname函数的基础用法"><a href="#extname函数的基础用法" class="headerlink" title="extname函数的基础用法"></a>extname函数的基础用法</h4><p>extname函数返回路径中文件的扩展名(以最后一个’.’开始,返回’.’以及’.’以后的所有字符串,如没有’.’,则返回空字符串). 如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.extname(<span class="string">'index.html'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'.html'</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-18T12:45:23.000Z"><a href="/2014/01/18/Node.js/入门—Node.js入门(4)url处理/">2014-01-18</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/18/Node.js/入门—Node.js入门(4)url处理/">入门—四.url处理</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="url模块的基本用法"><a href="#url模块的基本用法" class="headerlink" title="url模块的基本用法"></a>url模块的基本用法</h4><p>node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。</p>
<h3 id="2-parse"><a href="#2-parse" class="headerlink" title="2.parse"></a>2.parse</h3><hr>
<h4 id="parse函数的基础用法"><a href="#parse函数的基础用法" class="headerlink" title="parse函数的基础用法"></a>parse函数的基础用法</h4><p>parse函数的作用是解析url，返回一个json格式的数组，请看如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com'</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">null</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="literal">null</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="literal">null</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="literal">null</span>,</span><br><span class="line">  query: <span class="literal">null</span>,</span><br><span class="line">  pathname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  path: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-条件解析"><a href="#3-条件解析" class="headerlink" title="3.条件解析"></a>3.条件解析</h3><hr>
<h4 id="parse函数-——-条件解析"><a href="#parse函数-——-条件解析" class="headerlink" title="parse函数 —— 条件解析"></a>parse函数 —— 条件解析</h4><p>parse函数的第二个参数是布尔类型，当参数为true时，会将查询条件也解析成json格式的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com?page=1'</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="string">'?page=1'</span>,</span><br><span class="line">  query: &#123; <span class="attr">page</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/'</span>,</span><br><span class="line">  path: <span class="string">'/?page=1'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com/?page=1'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意query值的不同</p>
<h3 id="4-解析主机"><a href="#4-解析主机" class="headerlink" title="4.解析主机"></a>4.解析主机</h3><hr>
<h4 id="parse函数-——-解析主机"><a href="#parse函数-——-解析主机" class="headerlink" title="parse函数 —— 解析主机"></a>parse函数 —— 解析主机</h4><p>parse函数的第三个参数也是布尔类型的，当参数为true，解析时会将url的”//“和第一个”/“之间的部分解析为主机名，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com/news'</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="literal">null</span>,</span><br><span class="line">  query: <span class="literal">null</span>,</span><br><span class="line">  pathname: <span class="string">'/news'</span>,</span><br><span class="line">  path: <span class="string">'/news'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com/news'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-格式化"><a href="#5-格式化" class="headerlink" title="5.格式化"></a>5.格式化</h3><hr>
<h4 id="format函数的基础用法"><a href="#format函数的基础用法" class="headerlink" title="format函数的基础用法"></a>format函数的基础用法</h4><p>format函数的作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址，请看如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.format(&#123;</span><br><span class="line">	protocol: <span class="string">'http:'</span>,</span><br><span class="line">	hostname:<span class="string">'www.baidu.com'</span>,</span><br><span class="line">	port:<span class="string">'80'</span>,</span><br><span class="line">	pathname :<span class="string">'/news'</span>,</span><br><span class="line">	query:&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.baidu.com/news?page=1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-reslove"><a href="#6-reslove" class="headerlink" title="6.reslove"></a>6.reslove</h3><hr>
<h4 id="resolve函数的基础用法"><a href="#resolve函数的基础用法" class="headerlink" title="resolve函数的基础用法"></a>resolve函数的基础用法</h4><p>resolve函数的参数是两个路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径，返回值是一个组装好的url，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>)  <span class="comment">// 'http://example.com/one'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/one'</span>, <span class="string">'/two'</span>) <span class="comment">// 'http://example.com/two'</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-14T09:45:23.000Z"><a href="/2014/01/14/Node.js/入门—Node.js入门(3)文件I:O/">2014-01-14</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/14/Node.js/入门—Node.js入门(3)文件I:O/">入门—三.文件I/O</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="fs模块的基本用法"><a href="#fs模块的基本用法" class="headerlink" title="fs模块的基本用法"></a>fs模块的基本用法</h4><p>开发中我们经常会有文件I/O的需求，node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。</p>
<h3 id="2-写入文件"><a href="#2-写入文件" class="headerlink" title="2.写入文件"></a>2.写入文件</h3><hr>
<h4 id="writeFile函数的基本用法"><a href="#writeFile函数的基本用法" class="headerlink" title="writeFile函数的基本用法"></a>writeFile函数的基本用法</h4><p>文件I/O，写入是必修课之一。fs模块提供writeFile函数，可以异步的将数据写入一个文件, 如果文件已经存在则会被替换。用法如下：</p>
<p>例：fs.writeFile(filename, data, callback)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.writeFile(<span class="string">'test.txt'</span>, <span class="string">'Hello Node'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Saved successfully'</span>); <span class="comment">//文件被保存</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>数据参数可以是string或者是Buffer,编码格式参数可选，默认为”utf8”，回调函数只有一个参数err。</p>
<h3 id="3-追加文件"><a href="#3-追加文件" class="headerlink" title="3.追加文件"></a>3.追加文件</h3><hr>
<h4 id="appendFile函数的基本用法"><a href="#appendFile函数的基本用法" class="headerlink" title="appendFile函数的基本用法"></a>appendFile函数的基本用法</h4><p>writeFile函数虽然可以写入文件，但是如果文件已经存在，我们只是想添加一部分内容，它就不能满足我们的需求了，很幸运，fs模块中还有appendFile函数，它可以将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件。使用方法如下：</p>
<p>例：fs.appendFile(文件名,数据,编码,回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>); </span><br><span class="line">fs.appendFile(<span class="string">'test.txt'</span>, <span class="string">'data to append'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err; </span><br><span class="line">    <span class="comment">//数据被添加到文件的尾部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The "data to append" was appended to file!'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>编码格式默认为”utf8”</p>
<h3 id="4-是否存在"><a href="#4-是否存在" class="headerlink" title="4.是否存在"></a>4.是否存在</h3><hr>
<h4 id="exists函数的基本用法"><a href="#exists函数的基本用法" class="headerlink" title="exists函数的基本用法"></a>exists函数的基本用法</h4><p>如何检查一个文件是否存在呢？我想exists函数可以帮助你，用法如下：</p>
<p>例：fs.exists(文件，回调函数(exists));</p>
<p>exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.exists(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">exists</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(exists ? <span class="string">"存在"</span> : <span class="string">"不存在!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-修改名称"><a href="#5-修改名称" class="headerlink" title="5.修改名称"></a>5.修改名称</h3><hr>
<h4 id="rename函数的基本用法"><a href="#rename函数的基本用法" class="headerlink" title="rename函数的基本用法"></a>rename函数的基本用法</h4><p>修改文件名称是我们经常会遇见的事情，rename函数提供修改名称服务：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.rename(旧文件，新文件，回调函数(err)&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Successful modification,'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-移动文件"><a href="#6-移动文件" class="headerlink" title="6.移动文件"></a>6.移动文件</h3><hr>
<p>移动文件也是我们经常会遇见的，可是fs没有专门移动文件的函数，但是我们可以通过rename函数来达到移动文件的目的，示例如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.rename(oldPath,newPath,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'renamed complete'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-读取文件"><a href="#7-读取文件" class="headerlink" title="7.读取文件"></a>7.读取文件</h3><hr>
<h4 id="readFile函数的基本用法"><a href="#readFile函数的基本用法" class="headerlink" title="readFile函数的基本用法"></a>readFile函数的基本用法</h4><p>读取文件是最常用到的功能之一，使用fs模块读取文件语法如下：</p>
<p>例：fs.readFile(文件,编码,回调函数);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(文件名, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数里面的data,就是读取的文件内容。</p>
<h3 id="8-删除文件"><a href="#8-删除文件" class="headerlink" title="8.删除文件"></a>8.删除文件</h3><hr>
<h4 id="unlink函数的基本用法"><a href="#unlink函数的基本用法" class="headerlink" title="unlink函数的基本用法"></a>unlink函数的基本用法</h4><p>面对一堆垃圾的文件总是有想删除的冲动，我有强迫症？你才有呢。<br>好在有unlink函数，终于得救了，示例如下：<br>例：fs.unlink(文件,回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.unlink(文件, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'successfully deleted'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-创建目录"><a href="#9-创建目录" class="headerlink" title="9.创建目录"></a>9.创建目录</h3><hr>
<h4 id="mkdir函数的基本用法"><a href="#mkdir函数的基本用法" class="headerlink" title="mkdir函数的基本用法"></a>mkdir函数的基本用法</h4><p>除了针对文件的操作，目录的创建、删除也经常遇到的，下面我们来看看node.js中如何创建目录：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(路径，权限，回调函数(err));</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<p>1.路径：新创建的目录。<br>2.权限：可选参数，只在linux下有效，表示目录的权限，默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作。<br>3.回调函数：当发生错误时，错误信息会传递给回调函数的err参数。</p>
<h3 id="10-删除目录"><a href="#10-删除目录" class="headerlink" title="10.删除目录"></a>10.删除目录</h3><hr>
<h4 id="rmdir函数的基本用法"><a href="#rmdir函数的基本用法" class="headerlink" title="rmdir函数的基本用法"></a>rmdir函数的基本用法</h4><p>删除目录也是必不可少的功能，rmdir函数可以删除指定的目录：</p>
<p>例：fs.rmdir(路径，回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line">fs.rmdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-读取目录"><a href="#11-读取目录" class="headerlink" title="11.读取目录"></a>11.读取目录</h3><hr>
<h4 id="readdir函数的基本用法"><a href="#readdir函数的基本用法" class="headerlink" title="readdir函数的基本用法"></a>readdir函数的基本用法</h4><p>如果要读取目录下所有的文件应该怎么办呢？readdir函数可以读取到指定目录下所有的文件，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readdir(目录,回调函数(err,files));</span><br></pre></td></tr></table></figure></p>
<p>回调函数 (callback) 接受两个参数 (err, files) 其中 files 是一个存储目录中所包含的文件名称的数组，数组中不包括 ‘.’ 和 ‘..’。</p>
<h3 id="12-小结"><a href="#12-小结" class="headerlink" title="12.小结"></a>12.小结</h3><hr>
<p>文件I/O是最基本的操作，应该熟悉掌握。</p>
<p>fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-12T06:45:23.000Z"><a href="/2014/01/12/Node.js/入门—Node.js入门(2)进程管理/">2014-01-12</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/12/Node.js/入门—Node.js入门(2)进程管理/">入门—二.进程管理</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。</p>
<p>使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。</p>
<p>process对象的一些常用方法。</p>
<h3 id="2-cwd"><a href="#2-cwd" class="headerlink" title="2.cwd"></a>2.cwd</h3><hr>
<p>当我们想要查看应用程序当前目录时，可以使用cwd函数，使用语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.cwd();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-chdir"><a href="#3-chdir" class="headerlink" title="3.chdir"></a>3.chdir</h3><hr>
<p>如果需要改变应用程序目录，就要使用chdir函数了，它的用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.chdir(<span class="string">"目录"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-stdout"><a href="#4-stdout" class="headerlink" title="4.stdout"></a>4.stdout</h3><hr>
<p>stdout是标准输出流，它是干什么的呢？请下看下面的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    process.stdout.write(d+<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没错，它的作用就是将内容打印到输出设备上，console.log就是封装了它。</p>
<h3 id="5-stderr"><a href="#5-stderr" class="headerlink" title="5.stderr"></a>5.stderr</h3><hr>
<p>stderr是标准错误流，和stdout的作用差不多，不同的是它是用来打印错误信息的，我们可以通过它来捕获错误信息，基本使用方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stderr.write(输入内容);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-stdin"><a href="#6-stdin" class="headerlink" title="6.stdin"></a>6.stdin</h3><hr>
<p>stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中的chunk就是输入流中的内容。</p>
<h3 id="7-exit"><a href="#7-exit" class="headerlink" title="7.exit"></a>7.exit</h3><hr>
<p>如果你需要在程序内杀死进程，退出程序，可以使用exit函数，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.exit(code);</span><br></pre></td></tr></table></figure></p>
<p>参数code为退出后返回的代码，如果省略则默认返回0；</p>
<h3 id="8-注册事件"><a href="#8-注册事件" class="headerlink" title="8.注册事件"></a>8.注册事件</h3><hr>
<p>前面讲到如何在输入流中打印信息，当我们需要获取stdout内容的时候应该怎么做呢？请看如下的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为stdout注册data事件，我们就可以拿到它输出的内容了。</p>
<h3 id="9-设置编码"><a href="#9-设置编码" class="headerlink" title="9.设置编码"></a>9.设置编码</h3><hr>
<p>在我们的输入输出的内容中有中文的时候，可能会乱码的问题，这是因为编码不同造成的，所以在这种情况下需要为流设置编码，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(编码);</span><br><span class="line">process.stdout.setEncoding(编码);</span><br><span class="line">process.stderr.setEncoding(编码);</span><br></pre></td></tr></table></figure></p>
<p>常用的编码格式有”utf8”等</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-08T06:45:23.000Z"><a href="/2014/01/08/Node.js/入门—Node.js入门(1)快速入门/">2014-01-08</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/Node.js/入门—Node.js入门(1)快速入门/">入门—一.快速入门</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-hello-world"><a href="#1-hello-world" class="headerlink" title="1.hello world"></a>1.hello world</h3><hr>
<p>node使用javascript作为开发语言。没错，就是通常我们在前端页面里使用的javascript！如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><hr>
<p>由于node是一个异步事件驱动的平台，所以在代码中我们经常需要使用回调函数。下面是回调函数应用的经典示例：<br>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback is called'</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-标准回调函数"><a href="#3-标准回调函数" class="headerlink" title="3.标准回调函数"></a>3.标准回调函数</h3><hr>
<p>node.js中回调函数格式是约定俗成的，它有两个参数，第一个参数为err，第二个参数为data，顾名思义，err是错误信息，data则是返回的数据，示例如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-获取模块"><a href="#4-获取模块" class="headerlink" title="4.获取模块"></a>4.获取模块</h3><hr>
<p>为了支持快速开发，node平台上提供了大量的模块，封装了各自不同的功能，那么我们将如何调获取想要的模块呢， 在node中，我们可以使用require函数，具体语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"模块"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过require函数我们就可以获取相应模块进而使用它的任意功能了。</p>
<h3 id="5-使用模块"><a href="#5-使用模块" class="headerlink" title="5.使用模块"></a>5.使用模块</h3><hr>
<p>os模块可提供操作系统的一些基本信息，它的一些常用方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</span><br><span class="line"><span class="keyword">var</span> result = os.platform(); <span class="comment">//查看操作系统平台</span></span><br><span class="line">           <span class="comment">//os.release(); 查看操作系统版本</span></span><br><span class="line">           <span class="comment">//os.type();  查看操作系统名称</span></span><br><span class="line">           <span class="comment">//os.arch();  查看操作系统CPU架构</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-05T04:08:40.000Z"><a href="/2014/01/05/Node.js/入门—Node.js入门(0)安装Node.js开发环境/">2014-01-05</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/05/Node.js/入门—Node.js入门(0)安装Node.js开发环境/">入门—零.安装Node.js开发环境</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Mac下安装Node-js主要有以下几种方式"><a href="#Mac下安装Node-js主要有以下几种方式" class="headerlink" title="Mac下安装Node.js主要有以下几种方式"></a>Mac下安装Node.js主要有以下几种方式</h2><ul>
<li>Get source &amp; make</li>
<li>Official .pkg file</li>
<li>Homebrew</li>
<li>nvm</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-07-07T06:45:23.000Z"><a href="/2012/07/07/Unix/POSIX/">2012-07-07</a></time>
      
      
  
    <h1 class="title"><a href="/2012/07/07/Unix/POSIX/">POSIX</a></h1>
  

    </header>
    <div class="entry">
      
        <p>POSIX (Portable Operating System Interface) is a set of standard <a href="https://whatis.techtarget.com/definition/operating-system-OS" target="_blank" rel="noopener">operating system</a>interfaces based on the <a href="https://searchdatacenter.techtarget.com/definition/Unix" target="_blank" rel="noopener">Unix</a> operating system. The need for <a href="https://searchsqlserver.techtarget.com/definition/record-standardization" target="_blank" rel="noopener">standardization</a> arose because <a href="https://searchwindowsserver.techtarget.com/definition/enterprise" target="_blank" rel="noopener">enterprises</a> using computers wanted to be able to develop programs that could be moved among different manufacturer’s computer systems without having to be recoded. Unix was selected as the basis for a standard system interface partly because it was “manufacturer-neutral.” However, several major versions of Unix existed so there was a need to develop a common denominator system.</p>
<p>Informally, each standard in the POSIX set is defined by a decimal following the POSIX. Thus, POSIX.1 is the standard for an application program interface in the <a href="https://searchwindowsserver.techtarget.com/definition/C" target="_blank" rel="noopener">C</a> language. POSIX.2 is the standard <a href="https://searchdatacenter.techtarget.com/definition/shell" target="_blank" rel="noopener">shell</a> and <a href="https://whatis.techtarget.com/definition/utility" target="_blank" rel="noopener">utility</a> interface (that is to say, the <a href="https://searchwindowsserver.techtarget.com/definition/command-line-interface-CLI" target="_blank" rel="noopener">user’s command interface</a> with the operating system). These are the main two interfaces, but additional interfaces, such as POSIX.4 for <a href="https://whatis.techtarget.com/definition/thread" target="_blank" rel="noopener">thread</a> management, have been developed or are being developed. The POSIX interfaces were developed under the auspices of the Institute of Electrical and Electronics Engineers (<a href="https://whatis.techtarget.com/definition/IEEE-Institute-of-Electrical-and-Electronics-Engineers" target="_blank" rel="noopener">IEEE</a>).</p>
<p>POSIX.1 and POSIX.2 interfaces are included in a somewhat larger interface known as the X/Open Programming Guide (also known as the “Single UNIX Specification” and “<a href="https://whatis.techtarget.com/definition/Single-UNIX-Specification" target="_blank" rel="noopener">UNIX 03</a>“). <a href="https://searchoracle.techtarget.com/definition/The-Open-Group" target="_blank" rel="noopener">The Open Group</a>, an industry standards group, owns the UNIX trademark and can thus “brand” operating systems that conform to the interface as “UNIX” systems. IBM’s <a href="https://searchdatacenter.techtarget.com/definition/OS-390" target="_blank" rel="noopener">OS/390</a> is an example of an operating system that includes a branded UNIX interface. (Note that the trademark is “UNIX”; the generic terms for these operating systems is “Unix.”)</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-07-06T06:45:23.000Z"><a href="/2012/07/06/Unix/通过ulimit改善系统性能/">2012-07-06</a></time>
      
      
  
    <h1 class="title"><a href="/2012/07/06/Unix/通过ulimit改善系统性能/">通过ulimit改善系统性能</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>系统性能一直是一个受关注的话题，如何通过最简单的设置来实现最有效的性能调优，如何在有限资源的条件下保证程序的运作，ulimit 是我们在处理这些问题时，经常使用的一种简单手段。ulimit 是一种 linux 系统的内键功能，它具有一套参数集，用于为由它生成的 shell 进程及其子进程的资源使用设置限制。本文将在后面的章节中详细说明 ulimit 的功能，使用以及它的影响，并以具体的例子来详细地阐述它在限制资源使用方面的影响。</p>
<h2 id="ulimit-的功能和用法"><a href="#ulimit-的功能和用法" class="headerlink" title="ulimit 的功能和用法"></a>ulimit 的功能和用法</h2><h3 id="ulimit-功能简述"><a href="#ulimit-功能简述" class="headerlink" title="ulimit 功能简述"></a>ulimit 功能简述</h3><p>假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。</p>
<p>而实际应用的环境要比这种假设复杂的多，例如在一个嵌入式开发环境中，各方面的资源都是非常紧缺的，对于开启文件描述符的数量，分配堆栈的大小，CPU 时间，虚拟内存大小，等等，都有非常严格的要求。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。这时，ulimit 可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式。</p>
<p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p>
<h5 id="图-1-ulimit-的使用"><a href="#图-1-ulimit-的使用" class="headerlink" title="图 1. ulimit 的使用"></a>图 1. ulimit 的使用</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit01_180706.jpg" alt><br>在下面的章节中，将详细介绍如何使用 ulimit 做相应的资源限制。</p>
<h3 id="如何使用-ulimit"><a href="#如何使用-ulimit" class="headerlink" title="如何使用 ulimit"></a>如何使用 ulimit</h3><p>ulimit 通过一些参数选项来管理不同种类的系统资源。在本节，我们将讲解这些参数的使用。</p>
<p>ulimit 命令的格式为：ulimit [options] [limit]</p>
<p>具体的 options 含义以及简单示例可以参考以下表格。</p>
<h5 id="表-1-ulimit-参数说明"><a href="#表-1-ulimit-参数说明" class="headerlink" title="表 1. ulimit 参数说明"></a>表 1. ulimit 参数说明</h5><table>
<thead>
<tr>
<th>选项 [options]</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>-H</td>
<td>设置硬资源限制，一旦设置不能增加。</td>
<td>ulimit – Hs 64；限制硬资源，线程栈大小为 64K。</td>
</tr>
<tr>
<td>-S</td>
<td>设置软资源限制，设置后可以增加，但是不能超过硬资源设置。</td>
<td>ulimit – Sn 32；限制软资源，32 个文件描述符。</td>
</tr>
<tr>
<td>-a</td>
<td>显示当前所有的 limit 信息。</td>
<td>ulimit – a；显示当前所有的 limit 信息。</td>
</tr>
<tr>
<td>-c</td>
<td>最大的 core 文件的大小， 以 blocks 为单位。</td>
<td>ulimit – c unlimited； 对生成的 core 文件的大小不进行限制。</td>
</tr>
<tr>
<td>-d</td>
<td>进程最大的数据段的大小，以 Kbytes 为单位。</td>
<td>ulimit -d unlimited；对进程的数据段大小不进行限制。</td>
</tr>
<tr>
<td>-f</td>
<td>进程可以创建文件的最大值，以 blocks 为单位。</td>
<td>ulimit – f 2048；限制进程可以创建的最大文件大小为 2048 blocks。</td>
</tr>
<tr>
<td>-l</td>
<td>最大可加锁内存大小，以 Kbytes 为单位。</td>
<td>ulimit – l 32；限制最大可加锁内存大小为 32 Kbytes。</td>
</tr>
<tr>
<td>-m</td>
<td>最大内存大小，以 Kbytes 为单位。</td>
<td>ulimit – m unlimited；对最大内存不进行限制。</td>
</tr>
<tr>
<td>-n</td>
<td>可以打开最大文件描述符的数量。</td>
<td>ulimit – n 128；限制最大可以使用 128 个文件描述符。</td>
</tr>
<tr>
<td>-p</td>
<td>管道缓冲区的大小，以 Kbytes 为单位。</td>
<td>ulimit – p 512；限制管道缓冲区的大小为 512 Kbytes。</td>
</tr>
<tr>
<td>-s</td>
<td>线程栈大小，以 Kbytes 为单位。</td>
<td>ulimit – s 512；限制线程栈的大小为 512 Kbytes。</td>
</tr>
<tr>
<td>-t</td>
<td>最大的 CPU 占用时间，以秒为单位。</td>
<td>ulimit – t unlimited；对最大的 CPU 占用时间不进行限制。</td>
</tr>
<tr>
<td>-u</td>
<td>用户最大可用的进程数。</td>
<td>ulimit – u 64；限制用户最多可以使用 64 个进程。</td>
</tr>
<tr>
<td>-v</td>
<td>进程最大可用的虚拟内存，以 Kbytes 为单位。</td>
<td>ulimit – v 200000；限制最大可用的虚拟内存为 200000 Kbytes。</td>
</tr>
</tbody>
</table>
<p>我们可以通过以下几种方式来使用 ulimit：</p>
<ul>
<li><p>在用户的启动脚本中</p>
<p>如果用户使用的是 bash，就可以在用户的目录下的 .bashrc 文件中，加入 ulimit – u 64，来限制用户最多可以使用 64 个进程。此外，可以在与 .bashrc 功能相当的启动脚本中加入 ulimt。</p>
</li>
<li><p>在应用程序的启动脚本中</p>
<p>如果用户要对某个应用程序 myapp 进行限制，可以写一个简单的脚本 startmyapp。</p>
<p><code>ulimit – s 512 `</code>myapp`</p>
<p>以后只要通过脚本 startmyapp 来启动应用程序，就可以限制应用程序 myapp 的线程栈大小为 512K。</p>
</li>
<li><p>直接在控制台输入</p>
<p><code>user@tc511-ui:~&gt;ulimit – p 256</code></p>
<p>限制管道的缓冲区为 256K。</p>
</li>
</ul>
<h2 id="用户进程的有效范围"><a href="#用户进程的有效范围" class="headerlink" title="用户进程的有效范围"></a>用户进程的有效范围</h2><p>ulimit 作为对资源使用限制的一种工作，是有其作用范围的。那么，它限制的对象是单个用户，单个进程，还是整个系统呢？事实上，ulimit 限制的是当前 shell 进程以及其派生的子进程。举例来说，如果用户同时运行了两个 shell 终端进程，只在其中一个环境中执行了 ulimit – s 100，则该 shell 进程里创建文件的大小收到相应的限制，而同时另一个 shell 终端包括其上运行的子程序都不会受其影响：</p>
<h5 id="Shell-进程-1"><a href="#Shell-进程-1" class="headerlink" title="Shell 进程 1"></a>Shell 进程 1</h5><p><code>ulimit – s 100 `</code>cat testFile &gt; newFile <code></code>File size limit exceeded`</p>
<h5 id="Shell-进程-2"><a href="#Shell-进程-2" class="headerlink" title="Shell 进程 2"></a>Shell 进程 2</h5><p><code>cat testFile &gt; newFile `</code>ls – s newFile <code></code>323669 newFile`</p>
<p>那么，是否有针对某个具体用户的资源加以限制的方法呢？答案是有的，方法是通过修改系统的 /etc/security/limits 配置文件。该文件不仅能限制指定用户的资源使用，还能限制指定组的资源使用。该文件的每一行都是对限定的一个描述，格式如下：</p>
<p><code>&lt;`</code>domain<code>&gt; &lt;</code>type<code>&gt; &lt;</code>item<code>&gt; &lt;</code>value<code></code>&gt;`</p>
<p>domain 表示用户或者组的名字，还可以使用 * 作为通配符。Type 可以有两个值，soft 和 hard。Item 则表示需要限定的资源，可以有很多候选值，如 stack，cpu，nofile 等等，分别表示最大的堆栈大小，占用的 cpu 时间，以及打开的文件数。通过添加对应的一行描述，则可以产生相应的限制。例如：</p>
<p><code>* hard noflle 100</code></p>
<p>该行配置语句限定了任意用户所能创建的最大文件数是 100。</p>
<p>现在已经可以对进程和用户分别做资源限制了，看似已经足够了，其实不然。很多应用需要对整个系统的资源使用做一个总的限制，这时候我们需要修改 /proc 下的配置文件。/proc 目录下包含了很多系统当前状态的参数，例如 /proc/sys/kernel/pid_max，/proc/sys/net/ipv4/ip_local_port_range 等等，从文件的名字大致可以猜出所限制的资源种类。由于该目录下涉及的文件众多，在此不一一介绍。有兴趣的读者可打开其中的相关文件查阅说明。</p>
<h2 id="ulimit-管理系统资源的例子"><a href="#ulimit-管理系统资源的例子" class="headerlink" title="ulimit 管理系统资源的例子"></a>ulimit 管理系统资源的例子</h2><p>ulimit 提供了在 shell 进程中限制系统资源的功能。本章列举了一些使用 ulimit 对用户进程进行限制的例子，详述了这些限制行为以及对应的影响，以此来说明 ulimit 如何对系统资源进行限制，从而达到调节系统性能的功能。</p>
<h3 id="使用-ulimit-限制-shell-的内存使用"><a href="#使用-ulimit-限制-shell-的内存使用" class="headerlink" title="使用 ulimit 限制 shell 的内存使用"></a>使用 ulimit 限制 shell 的内存使用</h3><p>在这一小节里向读者展示如何使用 – d，– m 和 – v 选项来对 shell 所使用的内存进行限制。</p>
<p>首先我们来看一下不设置 ulimit 限制时调用 ls 命令的情况：</p>
<h5 id="图-2-未设置-ulimit-时-ls-命令使用情况"><a href="#图-2-未设置-ulimit-时-ls-命令使用情况" class="headerlink" title="图 2. 未设置 ulimit 时 ls 命令使用情况"></a>图 2. 未设置 ulimit 时 ls 命令使用情况</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit02_180706.jpg" alt><br>大家可以看到此时的 ls 命令运行正常。下面设置 ulimit：</p>
<p><code>&gt;ulimit -d 1000 -m 1000 -v 1000</code></p>
<p>这里再温习一下前面章节里介绍过的这三个选项的含义：</p>
<p>-d：设置数据段的最大值。单位：KB。</p>
<p>-m：设置可以使用的常驻内存的最大值。单位：KB。</p>
<p>-v：设置虚拟内存的最大值。单位：KB。</p>
<p>通过上面的 ulimit 设置我们已经把当前 shell 所能使用的最大内存限制在 1000KB 以下。接下来我们看看这时运行 ls 命令会得到什么样的结果：</p>
<p><code>haohe@sles10-hehao:~/code/ulimit&gt; ls test -l `</code>/bin/ls: error while loading shared libraries: libc.so.6: failed to map segment <code></code>from shared object: Cannot allocate memory`</p>
<p>从上面的结果可以看到，此时 ls 运行失败。根据系统给出的错误信息我们可以看出是由于调用 libc 库时内存分配失败而导致的 ls 出错。那么我们来看一下这个 libc 库文件到底有多大：</p>
<h5 id="图-3-查看-libc-文件大小"><a href="#图-3-查看-libc-文件大小" class="headerlink" title="图 3. 查看 libc 文件大小"></a>图 3. 查看 libc 文件大小</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit03_180706.jpg" alt><br>从上面的信息可以看出，这个 libc 库文件的大小是 1.5MB。而我们用 ulimit 所设置的内存使用上限是 1000KB，小于 1.5MB，这也就充分证明了 ulimit 所起到的限制 shell 内存使用的功能。</p>
<h3 id="使用-ulimit-限制-shell-创建的文件的大小"><a href="#使用-ulimit-限制-shell-创建的文件的大小" class="headerlink" title="使用 ulimit 限制 shell 创建的文件的大小"></a>使用 ulimit 限制 shell 创建的文件的大小</h3><p>接下来向读者展示如何使用 -f 选项来对 shell 所能创建的文件大小进行限制。</p>
<p>首先我们来看一下，没有设置 ulimit -f 时的情况：</p>
<h5 id="图-4-查看文件"><a href="#图-4-查看文件" class="headerlink" title="图 4. 查看文件"></a>图 4. 查看文件</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit04_180706.jpg" alt><br>现有一个文件 testFile 大小为 323669 bytes，现在使用 cat 命令来创建一个 testFile 的 copy：</p>
<h5 id="图-5-未设置-ulimit-时创建复本"><a href="#图-5-未设置-ulimit-时创建复本" class="headerlink" title="图 5. 未设置 ulimit 时创建复本"></a>图 5. 未设置 ulimit 时创建复本</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit05_180706.jpg" alt><br>从上面的输出可以看出，我们成功的创建了 testFile 的拷贝 newFile。</p>
<p>下面我们设置 ulimt – f 100：</p>
<p><code>&gt; ulimit -f 100</code></p>
<p>-f 选项的含义是：用来设置 shell 可以创建的文件的最大值。单位是 blocks。</p>
<p>现在我们再来执行一次相同的拷贝命令看看会是什么结果：</p>
<h5 id="图-6-设置-ulimit-时创建复本"><a href="#图-6-设置-ulimit-时创建复本" class="headerlink" title="图 6. 设置 ulimit 时创建复本"></a>图 6. 设置 ulimit 时创建复本</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit06_180706.jpg" alt><br>这次创建 testFile 的拷贝失败了，系统给出的出错信息时文件大小超出了限制。在 Linux 系统下一个 block 的默认大小是 512 bytes。所以上面的 ulimit 的含义就是限制 shell 所能创建的文件最大值为 512 x 100 = 51200 bytes，小于 323669 bytes，所以创建文件失败，符合我们的期望。这个例子说明了如何使用 ulimit 来控制 shell 所能创建的最大文件。</p>
<h3 id="使用-ulimit-限制程序所能创建的-socket-数量"><a href="#使用-ulimit-限制程序所能创建的-socket-数量" class="headerlink" title="使用 ulimit 限制程序所能创建的 socket 数量"></a>使用 ulimit 限制程序所能创建的 socket 数量</h3><p>考虑一个现实中的实际需求。对于一个 C/S 模型中的 server 程序来说，它会为多个 client 程序请求创建多个 socket 端口给与响应。如果恰好有大量的 client 同时向 server 发出请求，那么此时 server 就会需要创建大量的 socket 连接。但在一个系统当中，往往需要限制单个 server 程序所能使用的最大 socket 数，以供其他的 server 程序所使用。那么我们如何来做到这一点呢？答案是我们可以通过 ulimit 来实现！细心的读者可能会发现，通过前面章节的介绍似乎没有限制 socket 使用的 ulimit 选项。是的，ulimit 并没有哪个选项直接说是用来限制 socket 的数量的。但是，我们有 -n 这个选项，它是用于限制一个进程所能打开的文件描述符的最大值。在 Linux 下一切资源皆文件，普通文件是文件，磁盘打印机是文件，socket 当然也是文件。在 Linux 下创建一个新的 socket 连接，实际上就是创建一个新的文件描述符。如下图所示（查看某个进程当前打开的文件描述符信息）：</p>
<h5 id="图-7-查看进程打开文件描述符"><a href="#图-7-查看进程打开文件描述符" class="headerlink" title="图 7. 查看进程打开文件描述符"></a>图 7. 查看进程打开文件描述符</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit07_180706.jpg" alt><br>因此，我们可以通过使用 ulimit – n 来限制程序所能打开的最大文件描述符数量，从而达到限制 socket 创建的数量。</p>
<h3 id="使用-ulimit-限制-shell-多线程程序堆栈的大小（增加可用线程数量）"><a href="#使用-ulimit-限制-shell-多线程程序堆栈的大小（增加可用线程数量）" class="headerlink" title="使用 ulimit 限制 shell 多线程程序堆栈的大小（增加可用线程数量）"></a>使用 ulimit 限制 shell 多线程程序堆栈的大小（增加可用线程数量）</h3><p>在最后一个例子中，向大家介绍如何使用 -s（单位 KB）来对线程的堆栈大小进行限制，从而减少整个多线程程序的内存使用，增加可用线程的数量。这个例子取自于一个真实的案例。我们所遇到的问题是系统对我们的多线程程序有如下的限制：</p>
<p>ulimit -v 200000</p>
<p>根据本文前面的介绍，这意味着我们的程序最多只能使用不到 200MB 的虚拟内存。由于我们的程序是一个多线程程序，程序在运行时会根据需要创建新的线程，这势必会增加总的内存需求量。一开始我们对堆栈大小的限制是 1024 （本例子中使用 1232 来说明）：</p>
<p><code># ulimit – s 1232</code></p>
<p>当我们的程序启动后，通过 pmap 来查看其内存使用情况，可以看到多个占用 1232KB 的数据段，这些就是程序所创建的线程所使用的堆栈：</p>
<h5 id="图-8-程序线程所使用的堆栈"><a href="#图-8-程序线程所使用的堆栈" class="headerlink" title="图 8. 程序线程所使用的堆栈"></a>图 8. 程序线程所使用的堆栈</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit08_180706.jpg" alt><br>每当一个新的线程被创建时都需要新分配一段大小为 1232KB 的内存空间，而我们总的虚拟内存限制是 200MB，所以如果我们需要创建更多的线程，那么一个可以改进的方法就是减少每个线程的固定堆栈大小，这可以通过 ulimit – s 来实现：</p>
<p><code># ulimit -s 512</code></p>
<p>我们将堆栈大小设置为 512KB，这时再通过 pmap 查看一下我们的设置是否起作用：</p>
<h5 id="图-9-设置-ulimit-后堆栈大小"><a href="#图-9-设置-ulimit-后堆栈大小" class="headerlink" title="图 9. 设置 ulimit 后堆栈大小"></a>图 9. 设置 ulimit 后堆栈大小</h5><p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ulimit09_180706.jpg" alt><br>从上面的信息可以看出，我们已经成功的将线程的堆栈大小改为 512KB 了，这样在总内存使用限制不变的情况下，我们可以通过本小节介绍的方法来增加可以创建的线程数，从而达到改善程序的多线程性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，linux 系统中的 ulimit 指令，对资源限制和系统性能优化提供了一条便捷的途径。从用户的 shell 启动脚本，应用程序启动脚本，以及直接在控制台，都可以通过该指令限制系统资源的使用，包括所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存，等等方面。本文中的示例非常直观的说明了 ulimit 的使用及其产生的效果，显而易见，ulimit 对我们在 Linux 平台的应用和开发工作是非常实用的。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/index.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/12/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/14/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Docker/">Docker</a><small>3</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Linux性能优化/">Linux性能优化</a><small>5</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/MySQL实战/">MySQL实战</a><small>5</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>58</small></li>
  
    <li><a href="/tags/Redis/">Redis</a><small>2</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>4</small></li>
  
    <li><a href="/tags/从0开始学大数据/">从0开始学大数据</a><small>2</small></li>
  
    <li><a href="/tags/区块链/">区块链</a><small>1</small></li>
  
    <li><a href="/tags/数据分析实战/">数据分析实战</a><small>3</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>2</small></li>
  
    <li><a href="/tags/数据结构与算法/">数据结构与算法</a><small>13</small></li>
  
    <li><a href="/tags/程序员的数学基础课/">程序员的数学基础课</a><small>5</small></li>
  
    <li><a href="/tags/网络安全/">网络安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
    <li><a href="/tags/趣谈网络协议/">趣谈网络协议</a><small>8</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>