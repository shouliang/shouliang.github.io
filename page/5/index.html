<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 5 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-13T06:45:23.000Z"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">2014-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">三.async</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><hr>
<p>async是一个流程控制库，它就像黑夜中的明灯照亮那陷入callback嵌套泥潭的人们。 这么说虽然有些夸张，但是async确实为我们带来了丰富的嵌套解决方案。</p>
<p>项目地址：</p>
<p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a></p>
<p>npm 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install async</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-serires-tasks-callback"><a href="#2-serires-tasks-callback" class="headerlink" title="2.serires(tasks, callback)"></a>2.serires(tasks, callback)</h3><hr>
<p>首先登场的是series函数，它的作用是串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">    one: function(callback)&#123;</span><br><span class="line">        callback(null, 1);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: function(callback)&#123;</span><br><span class="line">        callback(null, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,function(err, results) &#123; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>series函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式，如示例中的参数为数组，返回的results应该是这样的’[1,2]’。</p>
<h3 id="3-waterfall-tasks-callback"><a href="#3-waterfall-tasks-callback" class="headerlink" title="3.waterfall(tasks,[callback])"></a>3.waterfall(tasks,[callback])</h3><hr>
<p>waterfall和series函数有很多相似之处，都是按顺序依次执行一组函数，不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([  </span><br><span class="line">    function(callback)&#123; </span><br><span class="line">      //task1 </span><br><span class="line">      callback(null,1);       </span><br><span class="line">    &#125;,function(data,callback)&#123;</span><br><span class="line">      //task2 </span><br><span class="line">      callback(null,2); </span><br><span class="line">    &#125; </span><br><span class="line">],function(err,results)&#123;  </span><br><span class="line">    console.log(results); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是waterfall的tasks参数只能是数组类型。</p>
<h3 id="4-parallel-tasks-callback"><a href="#4-parallel-tasks-callback" class="headerlink" title="4.parallel(tasks,[callback])"></a>4.parallel(tasks,[callback])</h3><hr>
<p>parallel函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。 传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>tasks参数可以是一个数组或是json对象，和series函数一样，tasks参数类型不同，返回的results格式会不一样。</p>
<h3 id="5-paralleLimit-tasks-limit-callback"><a href="#5-paralleLimit-tasks-limit-callback" class="headerlink" title="5.paralleLimit(tasks,limit,[callback])"></a>5.paralleLimit(tasks,limit,[callback])</h3><hr>
<p>parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.parallelLimit([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">2,</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-whilst-test-fn-callback"><a href="#6-whilst-test-fn-callback" class="headerlink" title="6.whilst(test,fn,callback)"></a>6.whilst(test,fn,callback)</h3><hr>
<p>相当于while，但其中的异步调用将在完成后才会进行下一次循环。当你需要循环异步的操作的时候，它可以帮助你。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.whilst(</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件。</p>
<p>fn参数就是我们要异步执行的作业，每次fn执行完毕后才会进入下一次循环。</p>
<h3 id="7-doWhilst"><a href="#7-doWhilst" class="headerlink" title="7.doWhilst"></a>7.doWhilst</h3><hr>
<p>相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.doWhilst(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-until-test-fn-callback"><a href="#8-until-test-fn-callback" class="headerlink" title="8.until(test,fn,callback)"></a>8.until(test,fn,callback)</h3><hr>
<p>until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.until(</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-doUntil-fn-test-callback"><a href="#9-doUntil-fn-test-callback" class="headerlink" title="9.doUntil(fn,test,callback)"></a>9.doUntil(fn,test,callback)</h3><hr>
<p>doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.doUntil(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-forever-fn-errback"><a href="#10-forever-fn-errback" class="headerlink" title="10.forever(fn,errback)"></a>10.forever(fn,errback)</h3><hr>
<p>forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async.forever(</span><br><span class="line">    function(next) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-compose-fn1-fn2…"><a href="#11-compose-fn1-fn2…" class="headerlink" title="11.compose(fn1,fn2…)"></a>11.compose(fn1,fn2…)</h3><hr>
<p>使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值。</p>
<p>我们可以使用compose把异步函数f、g、h，组合成f(g(h()))的形式，通过callback得到返回值，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unction fn1(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n * 3);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var demo = async.compose(fn2, fn1);</span><br><span class="line">demo(4, function (err, result) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-auto-tasks-callback"><a href="#12-auto-tasks-callback" class="headerlink" title="12.auto(tasks,[callback])"></a>12.auto(tasks,[callback])</h3><hr>
<p>用来处理有依赖关系的多个任务的执行。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async.auto(&#123;</span><br><span class="line">    getData: function(callback)&#123;</span><br><span class="line">        callback(null, &apos;data&apos;, &apos;converted to array&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    makeFolder: function(callback)&#123;        </span><br><span class="line">        callback(null, &apos;folder&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback, results)&#123;        </span><br><span class="line">        callback(null, &apos;filename&apos;);</span><br><span class="line">    &#125;],</span><br><span class="line">    emailLink: [&apos;writeFile&apos;, function(callback, results)&#123;</span><br><span class="line">        callback(null, &#123;&apos;file&apos;:results.writeFile, &apos;email&apos;:&apos;user@example.com&apos;&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, function(err, results) &#123;</span><br><span class="line">    console.log(&apos;err = &apos;, err);</span><br><span class="line">    console.log(&apos;results = &apos;, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中writeFile依赖getData和makeFolder,emailLink依赖writeFile。</p>
<h3 id="13-queue-worker-concurrency"><a href="#13-queue-worker-concurrency" class="headerlink" title="13.queue(worker,concurrency)"></a>13.queue(worker,concurrency)</h3><hr>
<p>queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。</p>
<p>它有多个点可供回调，如无等候任务时(empty)、全部执行完时(drain)等。</p>
<p>示例：定义一个queue，其worker数量为2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;worker is processing task: &apos;, task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当最后一个任务交给worker执行时，会调用empty函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.empty = function() &#123;</span><br><span class="line">    console.log(&apos;no more tasks wating&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-apply-function-arguments…"><a href="#14-apply-function-arguments…" class="headerlink" title="14.apply(function,arguments…)"></a>14.apply(function,arguments…)</h3><hr>
<p>apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(callback) &#123; </span><br><span class="line">    test(3, callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用apply改写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async.apply(test, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="15-iterator-tasks"><a href="#15-iterator-tasks" class="headerlink" title="15.iterator(tasks)"></a>15.iterator(tasks)</h3><hr>
<p>将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var iter = async.iterator([</span><br><span class="line">    function() &#123; console.log(&apos;111&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;222&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;333&apos;) &#125;</span><br><span class="line">]);</span><br><span class="line">iter();</span><br></pre></td></tr></table></figure>
<p>直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator。</p>
<p>对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null。</p>
<h3 id="16-小结"><a href="#16-小结" class="headerlink" title="16.小结"></a>16.小结</h3><hr>
<p>async模块在流程控制方面给我们带来了比较全面的解决办法，下面我们来回顾一下都有哪几种方案：</p>
<p>串行控制： series、waterfall、compose;</p>
<p>并行控制：</p>
<p>parallel、parallelLimit、queue;</p>
<p>循环控制：<br>whilst、doWhilst、until、doUntil、forever;</p>
<p>其他控制：<br>apply、applyEach、iterator、auto;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-09T06:45:23.000Z"><a href="/2014/02/09/Node.js异步编程/Node.js异步编程(2)函数式编程/">2014-02-09</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/09/Node.js异步编程/Node.js异步编程(2)函数式编程/">二.函数式编程</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1.高阶函数"></a>1.高阶函数</h3><hr>
<p>高阶函数是异步编程的基础，那么什么是高阶函数呢?</p>
<p>高阶二字听起来有点高大上的感觉，其实不然，高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值，请看如下示例。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(v)&#123;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    return v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例中是一个最简单的高阶函数，如你所见，高阶函数test的返回值是一个匿名函数。</p>
<h3 id="2-现实应用"><a href="#2-现实应用" class="headerlink" title="2.现实应用"></a>2.现实应用</h3><hr>
<p>虽然有可能是第一次真正的去了解什么是高阶函数，但是其实我们在日常开发中经常会用到它，只是我们没有去留意或者说不知道它的称谓而已。</p>
<p>示例：数组的排序(sort)函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [23,54,3,12,78];</span><br><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>有没有很熟悉的感觉,想一想常见的还有哪些高阶函数。</p>
<h3 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3.偏函数"></a>3.偏函数</h3><hr>
<p>什么是偏函数？</p>
<p>假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数，有点拗口？请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var isType = function(type)&#123;</span><br><span class="line">  return function(obj)&#123;</span><br><span class="line">    return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var isString = isType(&apos;String&apos;);</span><br><span class="line">var isFunction = isType(&apos;Function&apos;);</span><br></pre></td></tr></table></figure></p>
<p>isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><hr>
<p>高阶函数和偏函数是异步编程的基础，熟练运用高阶函数和偏函数是非常必要的。</p>
<p><strong>高阶函数</strong></p>
<p>1.函数作为参数；<br>2.函数作为返回值；<br><strong>偏函数</strong></p>
<p>1.一个创建函数的工厂函数；<br>2.通过指定部分参数，定制新的函数；</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-04T06:45:23.000Z"><a href="/2014/02/04/Node.js异步编程/Node.js异步编程(1)简介/">2014-02-04</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/04/Node.js异步编程/Node.js异步编程(1)简介/">一.简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hi!&apos;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">   console.log(&apos;hello!&apos;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">console.log(&apos;wow!&apos;);</span><br></pre></td></tr></table></figure></p>
<p>从示例中可以看到，hello是在wow输出后才输出的，因为setTimeout函数设置了延迟1000毫秒才异步执行，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function()&#123; console.log(&apos;hello&apos;); &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是异步回调函数，这样的编程风格就是异步编程。</p>
<h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h3><hr>
<p>为什么选择node.js？它有哪些优势呢？</p>
<p>1.性能：相对于多线程，异步I/O没有了线程间的上下文切换开销，由此带来可观的性能提升是选择它的主要原因。</p>
<p>2.成本：由于性能的提升，相同的硬件可以发挥更大的作用，变相的降低了运营成本，由于node.js采用javascript作为开发语言，而javascript的使用已经非常广泛，所以降低了node.js的学习成本。</p>
<p>3.效率：node.js采用javascript作为开发语言，使前后端开发语言统一，不需要切换开发语言，使开发效率更高，加之javascript使用者众多，使得node.js迅速的流行起来。</p>
<h3 id="3-思维习惯"><a href="#3-思维习惯" class="headerlink" title="3.思维习惯"></a>3.思维习惯</h3><hr>
<p><strong>不符合线性思维习惯</strong><br>虽然异步会带来很多好处，但是也衍生了很多问题。 异步编程在流程控制中业务表达不太适合自然语言的线性思维习惯。</p>
<p>实例 - 获取数据<br>线性表达<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = getData(id);</span><br></pre></td></tr></table></figure></p>
<p>异步编程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getData(id,function(data)&#123;</span><br><span class="line">   //在回调函数中才能获取到data数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-异常捕获"><a href="#4-异常捕获" class="headerlink" title="4.异常捕获"></a>4.异常捕获</h3><hr>
<p>异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常。</p>
<p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        var data = a/1; //错误的计算</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;catch (e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为计算并不会马上执行，所以即便是发生了错误，也无法捕获到相关信息，那么异步编程中应该如何处理异常的呢？请看示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        var data = a/1; //错误的计算</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-函数嵌套"><a href="#5-函数嵌套" class="headerlink" title="5.函数嵌套"></a>5.函数嵌套</h3><hr>
<p>os模块可提供操作系统的一些基本信息，它的一些常用方法如下：<br>函数嵌套<br>刚刚接触node.js的朋友们都有一个共同的烦恼，在进行较复杂的业务处理时，茫茫多的callback看得人头昏眼花，写着写着自己都糊涂了，更何况普遍患有强迫症的程序猿，面对如此难看的代码，如何能忍？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test1(function(v1)&#123;</span><br><span class="line">  test2(funciton(v1,function(v2)&#123;</span><br><span class="line">    test3(function(v2,fcuntion(v3)&#123;</span><br><span class="line">      test4(v3,function(v4)&#123;</span><br><span class="line">        callback(v4);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>异步编程中，函数嵌套是一个普遍存在的问题，也因此常常被人诟病，如何解决函数嵌套，且看下回分解。</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><hr>
<p>非线性的思维只是因为和以前的习惯不太一样，才会觉得不太适应，但是长期使用锻炼你也会发现它并非一无是处。</p>
<p>异常捕获在node.js中也有了统一的约定，将异常信息作为回调函数的第一个实参传递给回调函数。 深层嵌套的问题也有很多解决办法。</p>
<p>思维方式 ===&gt; 非线性思维需要多使用锻炼，适应这种思维方式。<br>异常捕获 ===&gt; 遵守node.js统一的回调函数格式，将异常信息传入回调函数。<br>函数嵌套 ===&gt; 相应解决方案，专门课程讲解。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-29T12:45:23.000Z"><a href="/2014/01/29/Node.js入门/Node.js入门(8)子进程/">2014-01-29</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/29/Node.js入门/Node.js入门(8)子进程/">八.子进程</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="child-process模块的基本介绍"><a href="#child-process模块的基本介绍" class="headerlink" title="child_process模块的基本介绍"></a>child_process模块的基本介绍</h4><p>众所周知node.js是基于单线程模型架构，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了child_process模块，通过多进程来实现对多核CPU的利用. child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。</p>
<h3 id="2-创建子进程"><a href="#2-创建子进程" class="headerlink" title="2.创建子进程"></a>2.创建子进程</h3><h4 id="spawn函数的基本用法"><a href="#spawn函数的基本用法" class="headerlink" title="spawn函数的基本用法"></a>spawn函数的基本用法</h4><p>spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出。如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> child = child_process.spawn( command );</span><br><span class="line">child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>通过执行命令得到返回结果，我们就可以拿到标准输出流数据了。</p>
<h3 id="3-exec"><a href="#3-exec" class="headerlink" title="3.exec"></a>3.exec</h3><hr>
<h4 id="exec函数的简单用法"><a href="#exec函数的简单用法" class="headerlink" title="exec函数的简单用法"></a>exec函数的简单用法</h4><p>exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数，回调函数有三个参数，分别是err, stdout , stderr，基本使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line">child_process.exec( command , <span class="function"><span class="keyword">function</span>(<span class="params">err, stdout , stderr </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( stdout );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-execFile"><a href="#4-execFile" class="headerlink" title="4.execFile"></a>4.execFile</h3><hr>
<h4 id="execFile函数的简单用法"><a href="#execFile函数的简单用法" class="headerlink" title="execFile函数的简单用法"></a>execFile函数的简单用法</h4><p>execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件，基本使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line">child_process.execFile( file , <span class="function"><span class="keyword">function</span>(<span class="params">err, stdout , stderr </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( stdout );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>execFile与spawn的参数相似，也需要分别指定执行的命令和参数，但可以接受一个回调函数，与exec的回调函数相同。</p>
<h3 id="5-fork"><a href="#5-fork" class="headerlink" title="5.fork"></a>5.fork</h3><hr>
<h4 id="fork函数的简单用法"><a href="#fork函数的简单用法" class="headerlink" title="fork函数的简单用法"></a>fork函数的简单用法</h4><p>fork函数可直接运行Node.js模块，所以我们可以直接通过指定模块路径而直接进行操作。使用方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line">child_process.fork( modulePath );</span><br></pre></td></tr></table></figure></p>
<p>该方法是spawn()的特殊情景，用于派生Node进程。除了普通ChildProcess实例所具有的所有方法，所返回的对象还具有内建的通讯通道。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-26T12:45:23.000Z"><a href="/2014/01/26/Node.js入门/Node.js入门(7)实用工具/">2014-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/26/Node.js入门/Node.js入门(7)实用工具/">七.实用工具</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="UTIL模块的基本介绍"><a href="#UTIL模块的基本介绍" class="headerlink" title="UTIL模块的基本介绍"></a>UTIL模块的基本介绍</h4><p>util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证。</p>
<h3 id="2-转换字符串"><a href="#2-转换字符串" class="headerlink" title="2.转换字符串"></a>2.转换字符串</h3><h4 id="inspect函数的基本用法"><a href="#inspect函数的基本用法" class="headerlink" title="inspect函数的基本用法"></a>inspect函数的基本用法</h4><p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的函数，通常用于调试和错误输出。它至少接受一个参数object，即要转换的对象,我们来学习它的简单用法。使用语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.inspect(<span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Function</span>: <span class="built_in">Object</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3.字符串格式化"></a>3.字符串格式化</h3><hr>
<h4 id="format函数的基本用法"><a href="#format函数的基本用法" class="headerlink" title="format函数的基本用法"></a>format函数的基本用法</h4><p>format函数根据第一个参数，返回一个格式化字符串，第一个参数是一个可包含零个或多个占位符的字符串。每一个占位符被替换为与其对应的转换后的值，支持的占位符有：”%s(字符串)”、”%d(数字&lt;整型和浮点型&gt;)”、”%j(JSON)”、”%(单独一个百分号则不作为一个参数)”。</p>
<p>1：如果占位符没有相对应的参数，占位符将不会被替换.如示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="string">'%s:%s'</span>, <span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo:%s'</span></span><br></pre></td></tr></table></figure>
<p>2：如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔。如示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="string">'%s:%s'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo:bar baz'</span></span><br></pre></td></tr></table></figure>
<p>3：如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串。如示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.format(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1 2 3'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-数组验证"><a href="#4-数组验证" class="headerlink" title="4.数组验证"></a>4.数组验证</h3><hr>
<h4 id="isArray函数的基本用法"><a href="#isArray函数的基本用法" class="headerlink" title="isArray函数的基本用法"></a>isArray函数的基本用法</h4><p>isArray函数可以判断对象是否为数组类型，是则返回ture,否则为false。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isArray([]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-日期验证"><a href="#5-日期验证" class="headerlink" title="5.日期验证"></a>5.日期验证</h3><hr>
<h4 id="isDate函数的基本用法"><a href="#isDate函数的基本用法" class="headerlink" title="isDate函数的基本用法"></a>isDate函数的基本用法</h4><p>isDate函数可以判断对象是否为日期类型，是则返回ture,否则返回false。语法如下：</p>
<p>例1：querystring.parse(“字符串”，”分隔符”，”分配符”)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-正则验证"><a href="#6-正则验证" class="headerlink" title="6.正则验证"></a>6.正则验证</h3><hr>
<h4 id="isRegExp函数的基本用法"><a href="#isRegExp函数的基本用法" class="headerlink" title="isRegExp函数的基本用法"></a>isRegExp函数的基本用法</h4><p>isRegExp函数可以判断对象是否为正则类型，是则返回ture,否则返回false。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> result = util.isRegExp(<span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>请自行验证。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-23T12:45:23.000Z"><a href="/2014/01/23/Node.js入门/Node.js入门(6)字符串转换/">2014-01-23</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/23/Node.js入门/Node.js入门(6)字符串转换/">六.字符串转换</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="Query-String模块的基本用法"><a href="#Query-String模块的基本用法" class="headerlink" title="Query String模块的基本用法"></a>Query String模块的基本用法</h4><p>Query String模块用于实现URL参数字符串与参数对象之间的互相转换，提供了”stringify”、”parse”等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助。</p>
<h3 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h3><hr>
<h4 id="stringify函数的基础用法"><a href="#stringify函数的基础用法" class="headerlink" title="stringify函数的基础用法"></a>stringify函数的基础用法</h4><p>stringify函数的作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（”&amp;”）和分配符（”=”））。</p>
<p>例1：querystring.stringify(“对象”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring= <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.stringify(&#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">cool</span>:[<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=bar&amp;cool=xux&amp;cool=yys</span><br></pre></td></tr></table></figure></p>
<h3 id="3-序列化-lt-多参数-gt"><a href="#3-序列化-lt-多参数-gt" class="headerlink" title="3.序列化&lt;多参数&gt;"></a>3.序列化&lt;多参数&gt;</h3><hr>
<h4 id="stringify函数的多参数用法"><a href="#stringify函数的多参数用法" class="headerlink" title="stringify函数的多参数用法"></a>stringify函数的多参数用法</h4><p>stringify函数的多参数用法，上节我们知道了对象被序列化为字符串之后默认是通过分割符（”&amp;”）和分配符（”=”）组成的，那可不可以改变呢，这节我们就来了解一下，是否可以自己去定义组合结果，看下面的小例子</p>
<p>例1：querystring.stringify(“对象”，”分隔符”，”分配符”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.stringify(&#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">cool</span>:[<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;,<span class="string">'*'</span>,<span class="string">'$'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'foo$bar*cool$xux*cool$yys'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-反序列化"><a href="#4-反序列化" class="headerlink" title="4.反序列化"></a>4.反序列化</h3><hr>
<h4 id="parse函数的基本用法"><a href="#parse函数的基本用法" class="headerlink" title="parse函数的基本用法"></a>parse函数的基本用法</h4><p>接下来就来学习反序列化函数——parse函数，parse函数的作用就是反序列化字符串（默认是由”=”、”&amp;”拼接而成），转换得到一个对象类型。如下示例：</p>
<p>例1：querystring.parse(“字符串”)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.parse(<span class="string">'foo=bar&amp;cool=xux&amp;cool=yys'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">cool</span>: [<span class="string">'xux'</span>, <span class="string">'yys'</span>]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-反序列化-lt-多参数-gt"><a href="#5-反序列化-lt-多参数-gt" class="headerlink" title="5.反序列化&lt;多参数&gt;"></a>5.反序列化&lt;多参数&gt;</h3><hr>
<h4 id="parse函数的多参数用法"><a href="#parse函数的多参数用法" class="headerlink" title="parse函数的多参数用法"></a>parse函数的多参数用法</h4><p>和上节stringify函数的多参数用法不同的是，parse函数可以根据用户所自定义的分割符、分配符来反序列化字符串，从而得到相应的对象结果.如下示例：</p>
<p>例1：querystring.parse(“字符串”，”分隔符”，”分配符”)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> result = querystring.parse(<span class="string">'foo@bar$cool@xux$cool@yys'</span>,<span class="string">'@'</span>,<span class="string">'$'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="string">''</span>, <span class="attr">bar</span>: <span class="string">'cool'</span>, <span class="attr">xux</span>: <span class="string">'cool'</span>, <span class="attr">yys</span>: <span class="string">''</span> &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-21T12:45:23.000Z"><a href="/2014/01/21/Node.js入门/Node.js入门(5)path优化/">2014-01-21</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/Node.js入门/Node.js入门(5)path优化/">五.path优化</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="path模块的基本用法"><a href="#path模块的基本用法" class="headerlink" title="path模块的基本用法"></a>path模块的基本用法</h4><p>本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率.</p>
<h3 id="2-格式化路径"><a href="#2-格式化路径" class="headerlink" title="2.格式化路径"></a>2.格式化路径</h3><hr>
<h4 id="normalize函数的基础用法"><a href="#normalize函数的基础用法" class="headerlink" title="normalize函数的基础用法"></a>normalize函数的基础用法</h4><p>normalize函数将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与..外，还能去掉多余的斜杠。<br>如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);  </span><br><span class="line"><span class="keyword">var</span> data = path.normalize(<span class="string">'/path///normalize/hi/..'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/path/normalize/'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-组合路径"><a href="#3-组合路径" class="headerlink" title="3.组合路径"></a>3.组合路径</h3><hr>
<h4 id="join函数的基本用法"><a href="#join函数的基本用法" class="headerlink" title="join函数的基本用法"></a>join函数的基本用法</h4><p>join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐. 如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.join(<span class="string">'///you'</span>, <span class="string">'/are'</span>, <span class="string">'//beautiful'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/you/are/beautiful'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-dirname"><a href="#4-dirname" class="headerlink" title="4.dirname"></a>4.dirname</h3><hr>
<h4 id="dirname函数的基本用法"><a href="#dirname函数的基本用法" class="headerlink" title="dirname函数的基本用法"></a>dirname函数的基本用法</h4><p>dirname函数用来返回路径中的目录名. 如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.dirname(<span class="string">'/foo/strong/cool/nice'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/foo/strong/cool'</span></span><br></pre></td></tr></table></figure>
<h3 id="5-basename"><a href="#5-basename" class="headerlink" title="5.basename"></a>5.basename</h3><hr>
<h4 id="basename函数的基础用法"><a href="#basename函数的基础用法" class="headerlink" title="basename函数的基础用法"></a>basename函数的基础用法</h4><p>basename函数可返回路径中的最后一部分，并且可以对其进行条件排除. 如下示例：</p>
<p>例1：path.basename(‘路径字符串’);</p>
<p>例2：path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);    </span><br><span class="line"><span class="keyword">var</span> data1 = path.basename(<span class="string">'/foo/strong/basename/index.html'</span>);</span><br><span class="line"><span class="keyword">var</span> data2 = path.basename(<span class="string">'/foo/strong/basename/index.html'</span>,<span class="string">'.html'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data1 + <span class="string">' "and" '</span> + data2);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'index.html "and" index'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-extname"><a href="#6-extname" class="headerlink" title="6.extname"></a>6.extname</h3><hr>
<h4 id="extname函数的基础用法"><a href="#extname函数的基础用法" class="headerlink" title="extname函数的基础用法"></a>extname函数的基础用法</h4><p>extname函数返回路径中文件的扩展名(以最后一个’.’开始,返回’.’以及’.’以后的所有字符串,如没有’.’,则返回空字符串). 如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> data = path.extname(<span class="string">'index.html'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'.html'</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-18T12:45:23.000Z"><a href="/2014/01/18/Node.js入门/Node.js入门(4)url处理/">2014-01-18</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/18/Node.js入门/Node.js入门(4)url处理/">四.url处理</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="url模块的基本用法"><a href="#url模块的基本用法" class="headerlink" title="url模块的基本用法"></a>url模块的基本用法</h4><p>node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。</p>
<h3 id="2-parse"><a href="#2-parse" class="headerlink" title="2.parse"></a>2.parse</h3><hr>
<h4 id="parse函数的基础用法"><a href="#parse函数的基础用法" class="headerlink" title="parse函数的基础用法"></a>parse函数的基础用法</h4><p>parse函数的作用是解析url，返回一个json格式的数组，请看如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com'</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">null</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="literal">null</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="literal">null</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="literal">null</span>,</span><br><span class="line">  query: <span class="literal">null</span>,</span><br><span class="line">  pathname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  path: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-条件解析"><a href="#3-条件解析" class="headerlink" title="3.条件解析"></a>3.条件解析</h3><hr>
<h4 id="parse函数-——-条件解析"><a href="#parse函数-——-条件解析" class="headerlink" title="parse函数 —— 条件解析"></a>parse函数 —— 条件解析</h4><p>parse函数的第二个参数是布尔类型，当参数为true时，会将查询条件也解析成json格式的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com?page=1'</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="string">'?page=1'</span>,</span><br><span class="line">  query: &#123; <span class="attr">page</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/'</span>,</span><br><span class="line">  path: <span class="string">'/?page=1'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com/?page=1'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意query值的不同</p>
<h3 id="4-解析主机"><a href="#4-解析主机" class="headerlink" title="4.解析主机"></a>4.解析主机</h3><hr>
<h4 id="parse函数-——-解析主机"><a href="#parse函数-——-解析主机" class="headerlink" title="parse函数 —— 解析主机"></a>parse函数 —— 解析主机</h4><p>parse函数的第三个参数也是布尔类型的，当参数为true，解析时会将url的”//“和第一个”/“之间的部分解析为主机名，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.parse(<span class="string">'http://www.baidu.com/news'</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="string">'www.baidu.com'</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="literal">null</span>,</span><br><span class="line">  query: <span class="literal">null</span>,</span><br><span class="line">  pathname: <span class="string">'/news'</span>,</span><br><span class="line">  path: <span class="string">'/news'</span>,</span><br><span class="line">  href: <span class="string">'http://www.baidu.com/news'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-格式化"><a href="#5-格式化" class="headerlink" title="5.格式化"></a>5.格式化</h3><hr>
<h4 id="format函数的基础用法"><a href="#format函数的基础用法" class="headerlink" title="format函数的基础用法"></a>format函数的基础用法</h4><p>format函数的作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址，请看如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.format(&#123;</span><br><span class="line">	protocol: <span class="string">'http:'</span>,</span><br><span class="line">	hostname:<span class="string">'www.baidu.com'</span>,</span><br><span class="line">	port:<span class="string">'80'</span>,</span><br><span class="line">	pathname :<span class="string">'/news'</span>,</span><br><span class="line">	query:&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.baidu.com/news?page=1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-reslove"><a href="#6-reslove" class="headerlink" title="6.reslove"></a>6.reslove</h3><hr>
<h4 id="resolve函数的基础用法"><a href="#resolve函数的基础用法" class="headerlink" title="resolve函数的基础用法"></a>resolve函数的基础用法</h4><p>resolve函数的参数是两个路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径，返回值是一个组装好的url，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>)  <span class="comment">// 'http://example.com/one'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/one'</span>, <span class="string">'/two'</span>) <span class="comment">// 'http://example.com/two'</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-14T09:45:23.000Z"><a href="/2014/01/14/Node.js入门/Node.js入门(3)文件I:O/">2014-01-14</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/14/Node.js入门/Node.js入门(3)文件I:O/">三.文件I/O</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<h4 id="fs模块的基本用法"><a href="#fs模块的基本用法" class="headerlink" title="fs模块的基本用法"></a>fs模块的基本用法</h4><p>开发中我们经常会有文件I/O的需求，node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。</p>
<h3 id="2-写入文件"><a href="#2-写入文件" class="headerlink" title="2.写入文件"></a>2.写入文件</h3><hr>
<h4 id="writeFile函数的基本用法"><a href="#writeFile函数的基本用法" class="headerlink" title="writeFile函数的基本用法"></a>writeFile函数的基本用法</h4><p>文件I/O，写入是必修课之一。fs模块提供writeFile函数，可以异步的将数据写入一个文件, 如果文件已经存在则会被替换。用法如下：</p>
<p>例：fs.writeFile(filename, data, callback)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.writeFile(<span class="string">'test.txt'</span>, <span class="string">'Hello Node'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Saved successfully'</span>); <span class="comment">//文件被保存</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>数据参数可以是string或者是Buffer,编码格式参数可选，默认为”utf8”，回调函数只有一个参数err。</p>
<h3 id="3-追加文件"><a href="#3-追加文件" class="headerlink" title="3.追加文件"></a>3.追加文件</h3><hr>
<h4 id="appendFile函数的基本用法"><a href="#appendFile函数的基本用法" class="headerlink" title="appendFile函数的基本用法"></a>appendFile函数的基本用法</h4><p>writeFile函数虽然可以写入文件，但是如果文件已经存在，我们只是想添加一部分内容，它就不能满足我们的需求了，很幸运，fs模块中还有appendFile函数，它可以将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件。使用方法如下：</p>
<p>例：fs.appendFile(文件名,数据,编码,回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>); </span><br><span class="line">fs.appendFile(<span class="string">'test.txt'</span>, <span class="string">'data to append'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err; </span><br><span class="line">    <span class="comment">//数据被添加到文件的尾部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The "data to append" was appended to file!'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>编码格式默认为”utf8”</p>
<h3 id="4-是否存在"><a href="#4-是否存在" class="headerlink" title="4.是否存在"></a>4.是否存在</h3><hr>
<h4 id="exists函数的基本用法"><a href="#exists函数的基本用法" class="headerlink" title="exists函数的基本用法"></a>exists函数的基本用法</h4><p>如何检查一个文件是否存在呢？我想exists函数可以帮助你，用法如下：</p>
<p>例：fs.exists(文件，回调函数(exists));</p>
<p>exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.exists(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">exists</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(exists ? <span class="string">"存在"</span> : <span class="string">"不存在!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-修改名称"><a href="#5-修改名称" class="headerlink" title="5.修改名称"></a>5.修改名称</h3><hr>
<h4 id="rename函数的基本用法"><a href="#rename函数的基本用法" class="headerlink" title="rename函数的基本用法"></a>rename函数的基本用法</h4><p>修改文件名称是我们经常会遇见的事情，rename函数提供修改名称服务：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs= <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.rename(旧文件，新文件，回调函数(err)&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Successful modification,'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-移动文件"><a href="#6-移动文件" class="headerlink" title="6.移动文件"></a>6.移动文件</h3><hr>
<p>移动文件也是我们经常会遇见的，可是fs没有专门移动文件的函数，但是我们可以通过rename函数来达到移动文件的目的，示例如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.rename(oldPath,newPath,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'renamed complete'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-读取文件"><a href="#7-读取文件" class="headerlink" title="7.读取文件"></a>7.读取文件</h3><hr>
<h4 id="readFile函数的基本用法"><a href="#readFile函数的基本用法" class="headerlink" title="readFile函数的基本用法"></a>readFile函数的基本用法</h4><p>读取文件是最常用到的功能之一，使用fs模块读取文件语法如下：</p>
<p>例：fs.readFile(文件,编码,回调函数);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(文件名, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数里面的data,就是读取的文件内容。</p>
<h3 id="8-删除文件"><a href="#8-删除文件" class="headerlink" title="8.删除文件"></a>8.删除文件</h3><hr>
<h4 id="unlink函数的基本用法"><a href="#unlink函数的基本用法" class="headerlink" title="unlink函数的基本用法"></a>unlink函数的基本用法</h4><p>面对一堆垃圾的文件总是有想删除的冲动，我有强迫症？你才有呢。<br>好在有unlink函数，终于得救了，示例如下：<br>例：fs.unlink(文件,回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.unlink(文件, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'successfully deleted'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-创建目录"><a href="#9-创建目录" class="headerlink" title="9.创建目录"></a>9.创建目录</h3><hr>
<h4 id="mkdir函数的基本用法"><a href="#mkdir函数的基本用法" class="headerlink" title="mkdir函数的基本用法"></a>mkdir函数的基本用法</h4><p>除了针对文件的操作，目录的创建、删除也经常遇到的，下面我们来看看node.js中如何创建目录：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(路径，权限，回调函数(err));</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<p>1.路径：新创建的目录。<br>2.权限：可选参数，只在linux下有效，表示目录的权限，默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作。<br>3.回调函数：当发生错误时，错误信息会传递给回调函数的err参数。</p>
<h3 id="10-删除目录"><a href="#10-删除目录" class="headerlink" title="10.删除目录"></a>10.删除目录</h3><hr>
<h4 id="rmdir函数的基本用法"><a href="#rmdir函数的基本用法" class="headerlink" title="rmdir函数的基本用法"></a>rmdir函数的基本用法</h4><p>删除目录也是必不可少的功能，rmdir函数可以删除指定的目录：</p>
<p>例：fs.rmdir(路径，回调函数(err));<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line">fs.rmdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-读取目录"><a href="#11-读取目录" class="headerlink" title="11.读取目录"></a>11.读取目录</h3><hr>
<h4 id="readdir函数的基本用法"><a href="#readdir函数的基本用法" class="headerlink" title="readdir函数的基本用法"></a>readdir函数的基本用法</h4><p>如果要读取目录下所有的文件应该怎么办呢？readdir函数可以读取到指定目录下所有的文件，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readdir(目录,回调函数(err,files));</span><br></pre></td></tr></table></figure></p>
<p>回调函数 (callback) 接受两个参数 (err, files) 其中 files 是一个存储目录中所包含的文件名称的数组，数组中不包括 ‘.’ 和 ‘..’。</p>
<h3 id="12-小结"><a href="#12-小结" class="headerlink" title="12.小结"></a>12.小结</h3><hr>
<p>文件I/O是最基本的操作，应该熟悉掌握。</p>
<p>fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-12T06:45:23.000Z"><a href="/2014/01/12/Node.js入门/Node.js入门(2)进程管理/">2014-01-12</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/12/Node.js入门/Node.js入门(2)进程管理/">二.进程管理</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><hr>
<p>process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。</p>
<p>使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。</p>
<p>process对象的一些常用方法。</p>
<h3 id="2-cwd"><a href="#2-cwd" class="headerlink" title="2.cwd"></a>2.cwd</h3><hr>
<p>当我们想要查看应用程序当前目录时，可以使用cwd函数，使用语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.cwd();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-chdir"><a href="#3-chdir" class="headerlink" title="3.chdir"></a>3.chdir</h3><hr>
<p>如果需要改变应用程序目录，就要使用chdir函数了，它的用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.chdir(<span class="string">"目录"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-stdout"><a href="#4-stdout" class="headerlink" title="4.stdout"></a>4.stdout</h3><hr>
<p>stdout是标准输出流，它是干什么的呢？请下看下面的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    process.stdout.write(d+<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没错，它的作用就是将内容打印到输出设备上，console.log就是封装了它。</p>
<h3 id="5-stderr"><a href="#5-stderr" class="headerlink" title="5.stderr"></a>5.stderr</h3><hr>
<p>stderr是标准错误流，和stdout的作用差不多，不同的是它是用来打印错误信息的，我们可以通过它来捕获错误信息，基本使用方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stderr.write(输入内容);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-stdin"><a href="#6-stdin" class="headerlink" title="6.stdin"></a>6.stdin</h3><hr>
<p>stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中的chunk就是输入流中的内容。</p>
<h3 id="7-exit"><a href="#7-exit" class="headerlink" title="7.exit"></a>7.exit</h3><hr>
<p>如果你需要在程序内杀死进程，退出程序，可以使用exit函数，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.exit(code);</span><br></pre></td></tr></table></figure></p>
<p>参数code为退出后返回的代码，如果省略则默认返回0；</p>
<h3 id="8-注册事件"><a href="#8-注册事件" class="headerlink" title="8.注册事件"></a>8.注册事件</h3><hr>
<p>前面讲到如何在输入流中打印信息，当我们需要获取stdout内容的时候应该怎么做呢？请看如下的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为stdout注册data事件，我们就可以拿到它输出的内容了。</p>
<h3 id="9-设置编码"><a href="#9-设置编码" class="headerlink" title="9.设置编码"></a>9.设置编码</h3><hr>
<p>在我们的输入输出的内容中有中文的时候，可能会乱码的问题，这是因为编码不同造成的，所以在这种情况下需要为流设置编码，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(编码);</span><br><span class="line">process.stdout.setEncoding(编码);</span><br><span class="line">process.stderr.setEncoding(编码);</span><br></pre></td></tr></table></figure></p>
<p>常用的编码格式有”utf8”等</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/4/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/6/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/Mocha/">Mocha</a><small>4</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js入门/">Node.js入门</a><small>9</small></li>
  
    <li><a href="/tags/Node错误处理和调试/">Node错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/异步编程/">异步编程</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>