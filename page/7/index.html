<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-15T06:45:23.000Z"><a href="/2014/06/15/Git/Git(1)简介/">2014-06-15</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/15/Git/Git(1)简介/">一.简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-Git的诞生"><a href="#1-Git的诞生" class="headerlink" title="1.Git的诞生"></a>1.Git的诞生</h3><hr>
<p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>　　Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>　　到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linux Torvalds）基于使用 BitKcheper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p>
<p>速度<br>简单的设计<br>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）<br>完全分布式<br>　　有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>　　自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p>
<p>　　Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<h3 id="2-Git介绍"><a href="#2-Git介绍" class="headerlink" title="2.Git介绍"></a>2.Git介绍</h3><hr>
<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>　　Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>　　最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面的样子了：<br>　　<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkold_version.jpg" alt=""></p>
<h3 id="3-Git特点"><a href="#3-Git特点" class="headerlink" title="3.Git特点"></a>3.Git特点</h3><hr>
<p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p>
<ul>
<li>直接记录快照，而非差异比较 ： Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。</li>
<li>近乎所有操作都是本地执行 ：在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。</li>
<li>时刻保持数据完整性 ：在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</li>
<li>多数操作仅添加数据 ：常用的 Git 操作大多仅仅是把数据添加到数据库。<br>开发流程示意图：</li>
</ul>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkdevelop.jpg" alt=""></p>
<h3 id="4-集中式"><a href="#4-集中式" class="headerlink" title="4.集中式"></a>4.集中式</h3><hr>
<p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p>
<p>　　集中式版本控制系统，版本库是集中存放在中央服务器的，一起工作的人需要用自己的电脑从服务器上同步更新或上传自己的修改。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkfos.jpg" alt="">　　</p>
<p>但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。</p>
<p>　　而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。　　</p>
<h3 id="5-分布式"><a href="#5-分布式" class="headerlink" title="5.分布式"></a>5.分布式</h3><hr>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？</p>
<p>　分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网就可以工作。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你和同事在各自电脑修改相同文件，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>　　分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库。大家之间可以相互复制。</p>
<p>　　分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkdis.jpg" alt=""></p>
<h3 id="6-Git安装"><a href="#6-Git安装" class="headerlink" title="6.Git安装"></a>6.Git安装</h3><hr>
<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>　　在Linux上安装Git</p>
<p>　　首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br></pre></td></tr></table></figure></p>
<p>　　像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>　　如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。如果想查看是否安装成功，通过git –version。</p>
<p>　　如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-13T11:45:23.000Z"><a href="/2014/06/13/Node.js_测试/Mocha(4)为项目开发一个BDD测试/">2014-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/13/Node.js_测试/Mocha(4)为项目开发一个BDD测试/">四.为项目开发一个BDD测试</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-辅助模块"><a href="#1-辅助模块" class="headerlink" title="1.辅助模块"></a>1.辅助模块</h3><hr>
<p>我们进行单元测试，一般都需要组合几个工具来来使用的。下面我们开始介绍：</p>
<p>chai断言库<br>chai 断言库支持BDD 的 expect/should 语法风格 和TDD的 assert 语法风格。</p>
<p>superagent<br>在用Node做Web开发的时候，模拟HTTP请求时必不可少的。这也就引出了superagent这个模块，它是一个模拟http请求的库。它作用是简化发起请求的库。</p>
<p>项目的package.json 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mocha-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node app.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;superagent&quot;: &quot;1.4.0&quot;,</span><br><span class="line">    &quot;chai&quot;: &quot;3.4.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-项目描述"><a href="#2-项目描述" class="headerlink" title="2.项目描述"></a>2.项目描述</h3><hr>
<p>首先我们创建一个app.js文件。内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;),</span><br><span class="line">    PORT = 3000; </span><br><span class="line">function onRequest(request, response) &#123;</span><br><span class="line">    console.log(&quot;Request received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></p>
<p>描述：为了让项目尽可能的简单，我们没有用到任何的框架。只是创建了一个http服务器监听了3000端口。</p>
<h3 id="3-项目重构"><a href="#3-项目重构" class="headerlink" title="3.项目重构"></a>3.项目重构</h3><hr>
<p>我们的app.js需要最外部暴露两个方法。所以要对我们右边的项目进行修改。</p>
<p>需要修改的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></p>
<p>重构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">var boot = function () &#123;</span><br><span class="line">    server.listen(PORT, function () &#123;</span><br><span class="line">        console.info(&apos;Express server listening on port &apos; + PORT);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">var shutdown = function () &#123;</span><br><span class="line">    server.close();</span><br><span class="line">&#125;;</span><br><span class="line">if (require.main === module) &#123;</span><br><span class="line">    boot();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.info(&apos;Running app as a module&apos;);</span><br><span class="line">    exports.boot = boot;</span><br><span class="line">    exports.shutdown = shutdown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重构描述：现在我们把启动服务和关闭服务分别进行了封装并且对外进行了暴露。</p>
<h3 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4.测试用例"></a>4.测试用例</h3><hr>
<p>现在，我们创建一个名字为 tests 的测试文件夹，并创建一个index.js的文件。测试用例前需要启动服务器，结束后关闭服务。这个时候就用到了前面暴露的 boot() 和 shutdown() 方法。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var boot = require(&apos;../app&apos;).boot,</span><br><span class="line">    shutdown = require(&apos;../app&apos;).shutdown,</span><br><span class="line">    request = require(&apos;superagent&apos;),</span><br><span class="line">    expect = require(&apos;chai&apos;).expect;</span><br><span class="line"> </span><br><span class="line">describe(&apos;server&apos;, function () &#123;</span><br><span class="line">    before(function () &#123;</span><br><span class="line">        boot();</span><br><span class="line">    &#125;);</span><br><span class="line">    describe(&apos;index&apos;, function () &#123;</span><br><span class="line">        it(&apos;should respond to GET&apos;, function (done) &#123;</span><br><span class="line">            request</span><br><span class="line">                .get(&apos;http://localhost:3000&apos;)</span><br><span class="line">                .end(function (err, res) &#123;</span><br><span class="line">                    expect(res.status).to.equal(200);</span><br><span class="line">                    done();</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    after(function () &#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行命令：mocha tests</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-10T08:45:23.000Z"><a href="/2014/06/10/Node.js_测试/Mocha(3)hook机制和测试技巧/">2014-06-10</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/10/Node.js_测试/Mocha(3)hook机制和测试技巧/">三.hook机制和测试技巧</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-hook机制"><a href="#1-hook机制" class="headerlink" title="1.hook机制"></a>1.hook机制</h3><hr>
<p>hook 就是在测试流程的不同时段触发，比如在整个测试流程之前，或在每个独立测试之前等。</p>
<p>hook也可以理解为是一些逻辑，通常表现为一个函数或者一些声明，当特定的事件触发时 hook 才执行。</p>
<p>提供方法有：before()、beforeEach() after() 和 afterEach()。</p>
<p><strong>方法解析：</strong></p>
<ul>
<li>before()：所有测试用例的统一前置动作</li>
<li>after()：所有测试用例的统一后置动作</li>
<li>beforeEach()：每个测试用例的前置动作</li>
<li>afterEach()：每个测试用例的后置动作<br>用法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;hooks&apos;, function() &#123;</span><br><span class="line">  before(function() &#123;</span><br><span class="line">    //在执行本区块的所有测试之前执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  after(function() &#123;</span><br><span class="line">    //在执行本区块的所有测试之后执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    //在执行本区块的每个测试之前都执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  afterEach(function() &#123;</span><br><span class="line">    //在执行本区块的每个测试之后都执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  //测试用例</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-描述hook"><a href="#2-描述hook" class="headerlink" title="2.描述hook"></a>2.描述hook</h3><hr>
<p>所有的 hook 都可以加上描述，这样可以更好地定位到测试用例中的错误。如果 hook 函数指定了名称，会在没有描述时使用函数名，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(function() &#123;</span><br><span class="line">  //beforeEach hook</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">beforeEach(function needFun() &#123;</span><br><span class="line">  //beforeEach: namedFun</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">beforeEach(&apos;some description&apos;, function() &#123;</span><br><span class="line">  //beforeEach:some description</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>补充：上述示例中 注释的内容就是对 hook 的描述。</p>
<h3 id="3-测试占位"><a href="#3-测试占位" class="headerlink" title="3.测试占位"></a>3.测试占位</h3><hr>
<p>测试用例占位只要添加一个没有回调的 it() 方法即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"> </span><br><span class="line">describe(&apos;Array&apos;, function() &#123;</span><br><span class="line"> </span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">    //同步测试</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function() &#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(5));</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(0));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  describe(&apos;Array&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">      //下面是一个挂起的测试</span><br><span class="line">      it(&apos;当值不存在时应该返回 -1&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-仅执行指定测试"><a href="#4-仅执行指定测试" class="headerlink" title="4.仅执行指定测试"></a>4.仅执行指定测试</h3><hr>
<p>仅执行指定测试的特性可以让你通过添加 .only() 来指定唯一要执行的测试套件或测试用例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe.only(&apos;#indexOf()&apos;, function()&#123;    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>或一个指定的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it.only(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;) </span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>PS:注意只能出现一个 .only()</p>
<h3 id="5-忽略指定测试"><a href="#5-忽略指定测试" class="headerlink" title="5.忽略指定测试"></a>5.忽略指定测试</h3><hr>
<p>该特性和 .only() 非常相似，通过添加 .skip() 你可以告诉 Mocha 忽略的测试套件或者测试用例（可以有多个）。该操作使得这些操作处于挂起的状态，这比使用注释来的要好，因为你可能会忘记把注释给取消掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe.skip(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>或一个指定的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it.skip(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="6-动态生成测试"><a href="#6-动态生成测试" class="headerlink" title="6.动态生成测试"></a>6.动态生成测试</h3><hr>
<p>由于mocha 可以使用 function.prototype.call 和function 表达式定义测试套件和测试用例，所以可以动态生成测试用例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"> </span><br><span class="line">function add() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments).reduce(function(prev, curr) &#123;</span><br><span class="line">    return prev + curr;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">describe(&apos;add()&apos;, function() &#123;</span><br><span class="line">  var tests = [</span><br><span class="line">    &#123;args: [1, 2],       expected: 3&#125;,</span><br><span class="line">    &#123;args: [1, 2, 3],    expected: 6&#125;,</span><br><span class="line">    &#123;args: [1, 2, 3, 4], expected: 10&#125;</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  tests.forEach(function(test) &#123;</span><br><span class="line">    it(&apos;correctly adds &apos; + test.args.length + &apos; args&apos;, function() &#123;</span><br><span class="line">      var res = add.apply(null, test.args);</span><br><span class="line">      assert.equal(res, test.expected);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-08T07:45:23.000Z"><a href="/2014/06/08/Node.js_测试/Mocha(2)mocha接口/">2014-06-08</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/08/Node.js_测试/Mocha(2)mocha接口/">二.mocha接口</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-BDD行为驱动开发"><a href="#1-BDD行为驱动开发" class="headerlink" title="1.BDD行为驱动开发"></a>1.BDD行为驱动开发</h3><hr>
<p>mocha “接口” 系统允许开发者选择自身喜爱的特定领域语言风格, mocha 提供 TDD（测试驱动开发）、BDD (行为驱动开发) 和 exports 风格的接口。</p>
<p>BDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。</p>
<p>BDD认为，不应该针对代码的实现细节写测试，而是要针对行为写测试。BDD测试的是行为，即软件应该怎样运行。</p>
<p>BDD接口提供以下方法：</p>
<ul>
<li>describe()：测试套件</li>
<li>it()：测试用例</li>
<li>before()：所有测试用例的统一前置动作</li>
<li>after()：所有测试用例的统一后置动作</li>
<li>beforeEach()：每个测试用例的前置动作</li>
<li>afterEach()：每个测试用例的后置动作<br>BDD的特征就是使用describe()和it() 这两个方法。</li>
</ul>
<p>before()、after()、beforeEach()和afterEach() 是为测试做辅助的作用域，它们合起来组成了hook的概念。</p>
<h3 id="2-方法解析"><a href="#2-方法解析" class="headerlink" title="2.方法解析"></a>2.方法解析</h3><hr>
<h4 id="descript"><a href="#descript" class="headerlink" title="descript()"></a>descript()</h4><p>describe()方法接收两个参数：第一个参数是一个字符串，表示测试套件的名字或标题，表示将要测试什么。第二个参数是一个函数，用来实现这个测试套件。</p>
<p>上述中引出了一个概念：测试套件。那什么是测试套件呢？</p>
<p>测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A suite&quot;, function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="it"><a href="#it" class="headerlink" title="it()"></a>it()</h4><p>要想理解it()，首先我们要知道什么是测试用例? 测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。</p>
<p>测试用例由it函数构成，它与describe函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。</p>
<h4 id="BDD风格用例"><a href="#BDD风格用例" class="headerlink" title="BDD风格用例"></a>BDD风格用例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  before(function()&#123;</span><br><span class="line">    console.log(&apos;在测试之前运行&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      expect([1,2,3].indexOf(4)).to.equal(-1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-TDD测试驱动开发"><a href="#3-TDD测试驱动开发" class="headerlink" title="3.TDD测试驱动开发"></a>3.TDD测试驱动开发</h3><hr>
<h4 id="TDD风格"><a href="#TDD风格" class="headerlink" title="TDD风格"></a>TDD风格</h4><p>TDD（测试驱动开发）组织方式是使用测试集（suite）和测试（test）。</p>
<p>每个测试集都有 setup 和 teardown 函数。这些方法会在测试集中的测试执行前执行，它们的作用是为了避免代码重复以及最大限度使得测试之间相互独立。</p>
<p>TDD接口：</p>
<ul>
<li>suite：类似BDD中 describe()</li>
<li>test：类似BDD中 it()</li>
<li>setup：类似BDD中 before()</li>
<li>teardown：类似BDD中 after()</li>
<li>suiteSetup：类似BDD中 beforeEach()</li>
<li>suiteTeardown：类似BDD中 afterEach()<br>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&quot;assert&quot;);</span><br><span class="line"></span><br><span class="line">suite(&apos;Array&apos;, function()&#123;</span><br><span class="line">  setup(function()&#123;</span><br><span class="line">    console.log(&apos;测试执行前执行&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  suite(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    test(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(4));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行mocha：</p>
<p> <strong>mocha –ui tdd *.js</strong> (*表示的是文件名)</p>
<p>PS：mocha 默认是使用 bdd 的接口，所以在这里我们告诉mocha我们用的是tdd.</p>
<h3 id="4-exports风格"><a href="#4-exports风格" class="headerlink" title="4.exports风格"></a>4.exports风格</h3><hr>
<p>exports类似于nodejs里的模块语法,关键字 before, after, beforeEach, 和 afterEach 是特殊保留的，值为对象时是一个测试套件，为函数时则是一个测试用例。</p>
<h4 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  before: function()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;, </span><br><span class="line">  </span><br><span class="line">  &apos;Array&apos;: &#123;</span><br><span class="line">     &apos;#indexOf()&apos;: &#123;</span><br><span class="line">        &apos;当值不存在时应该返回 -1&apos;: function()&#123;</span><br><span class="line">          expect([1,2,3].indexOf(4)).to.equal(-1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="运行-mocha"><a href="#运行-mocha" class="headerlink" title="运行 mocha"></a>运行 mocha</h4><p>mocha –ui exports *.js</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>我们在前文中讲到了 mocha 提供 TDD（测试驱动开发）、BDD (行为驱动开发) 和 exports 风格的接口。其实还有 QUnit 和 require 风格的接口。</p>
<p>但是比较常用就是 BDD 和 TDD，mocha 默认的也是BDD，且 BDD 是 TDD 的一个专业版本，它指定了从业务需求的角度出发需要哪些单元测试。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-05T06:45:23.000Z"><a href="/2014/06/05/Node.js_测试/Mocha(1)快速开始/">2014-06-05</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/05/Node.js_测试/Mocha(1)快速开始/">一.快速开始</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是mocha"><a href="#1-什么是mocha" class="headerlink" title="1.什么是mocha"></a>1.什么是mocha</h3><hr>
<p>mocha 是一个功能丰富的javascript测试框架，可以运行在nodejs和浏览器环境，使异步测试变得简单有趣。mocha 串联运行测试，允许灵活和精确地报告结果，同时映射未捕获的异常用来纠正测试用例。</p>
<p>支持TDD/BDD 的 开发方式，结合 should.js/expect/chai/better-assert 断言库，能轻松构建各种风格的测试用例。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>简单</li>
<li>灵活</li>
<li>有趣<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4>通过npm全局安装： npm install -g mocha</li>
</ul>
<h3 id="2-第一个测试用例"><a href="#2-第一个测试用例" class="headerlink" title="2.第一个测试用例"></a>2.第一个测试用例</h3><hr>
<p>我们首先来见识一下mocha最基本的测试用例是怎么的结构,如下。</p>
<p>测试用例：</p>
<p>//模块依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&quot;assert&quot;);</span><br></pre></td></tr></table></figure></p>
<p>//断言条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(5));</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(0));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例解析：测试用例首先需要引用断言模块，如上文中var assert = require(‘assert’);，代码 assert.equal(-1, [1,2,3].indexOf(5)); 中使用的是assert.equal(actual, expected, [message]) 语法。作用等同于使用’==’进行相等判断。actual为实际值，expected 为期望值。message为返回的信息。</p>
<p>运行 Mocha：$ mocha</p>
<h3 id="3-assert断言"><a href="#3-assert断言" class="headerlink" title="3.assert断言"></a>3.assert断言</h3><hr>
<p>断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。</p>
<p>断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为true，测试用例才会通过。</p>
<p>比如上节示例中的：</p>
<p>assert.equal(-1, [1,2,3].indexOf(5));</p>
<p>assert.equal(-1, [1,2,3].indexOf(0));</p>
<p>实际值（-1）和期望值（[1,2,3].indexOf(5)）是一样的，断言为true，所以这个测试用例成功了。</p>
<p>mocha 允许开发者使用任意的断言库，当这些断言库抛出了一个错误异常时，mocha将会捕获并进行相应处理。这意味着你可以利用如 should.js断言库、 Node.js 常规的 assert 模块或其它类似的断言代码库。以下是众所周知的适用于Node.js或浏览器的断言库：</p>
<ul>
<li>should.js</li>
<li>expect.js</li>
<li>chai.js</li>
<li>better-assert</li>
<li>assert：nodejs原生模块，在前文示例中我们有应用到。</li>
</ul>
<h3 id="4-chai-js断言库"><a href="#4-chai-js断言库" class="headerlink" title="4.chai.js断言库"></a>4.chai.js断言库</h3><hr>
<p>Chai 是一个非常灵活的断言库，它可以让你使用如下三种主要断言方式的任何一种：</p>
<h4 id="assert："><a href="#assert：" class="headerlink" title="assert："></a>assert：</h4><p>这是来自老派测试驱动开发的经典的assert方式。比如：</p>
<p>assert.equal(variable, “value”);</p>
<h4 id="expect："><a href="#expect：" class="headerlink" title="expect："></a>expect：</h4><p>这种链式的断言方式在行为驱动开发中最为常见。比如：</p>
<p>expect(variable).to.equal(“value”);</p>
<h4 id="should："><a href="#should：" class="headerlink" title="should："></a>should：</h4><p>这也是在测试驱动开发中比较常用的方式之一。举例：</p>
<p>variable.should.equal(“value”);</p>
<h3 id="5-expect语法"><a href="#5-expect语法" class="headerlink" title="5.expect语法"></a>5.expect语法</h3><hr>
<p>expect 库应用是非常广泛的，它拥有很好的链式结构和仿自然语言的方法。通常写同一个断言会有几个方法，比如expect(response).to.be(true) 和 expect(response).equal(true)。以下列举了 expect 常用的主要方法：</p>
<ul>
<li>ok ：检查是否为真</li>
<li>true：检查对象是否为真</li>
<li>to.be、to：作为连接两个方法的链式方法</li>
<li>not：链接一个否定的断言，如 expect(false).not.to.be(true)</li>
<li>a/an：检查类型（也适用于数组类型）</li>
<li>include/contain：检查数组或字符串是否包含某个元素</li>
<li>below/above：检查是否大于或者小于某个限定值<br>mocha支持TDD/BDD 的 开发方式，结合 should.js、expect、chai、better-assert 断言库，能轻松构建各种风格的测试用例。这里面有两个知识点，一个是断言库，另一个是 TDD/BDD 。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-07T07:45:23.000Z"><a href="/2014/05/07/express/express(2)示例准备登陆/">2014-05-07</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/07/express/express(2)示例准备登陆/">二.准备登陆</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-安装模板"><a href="#1-安装模板" class="headerlink" title="1.安装模板"></a>1.安装模板</h3><hr>
<p>我们要使用express框架实现一个简单的用户登陆功能，先准备一下相关资源。</p>
<p>在nodejs中使用express框架，它默认的是ejs和jade渲染模板，以ejs模板为例，讲述模板渲染网页模板的基础功能。</p>
<p>ejs模板安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure></p>
<p>1.目录下安装好了之后，如何调用呢，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 指定渲染模板文件的后缀名为ejs</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br></pre></td></tr></table></figure></p>
<p>2.默认ejs模板只支持渲染以ejs为扩展名的文件，可能在使用的时候会觉得它的代码书写方式很不爽还是想用html的形式去书写，该怎么办呢，这时就得去修改模板引擎了，也就会用到express的engine函数。</p>
<p>3.engine注册模板引擎的函数，处理指定的后缀名文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改模板文件的后缀名为html</span><br><span class="line">app.set( &apos;view engine&apos;, &apos;html&apos; );</span><br><span class="line">// 运行ejs模块</span><br><span class="line">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</span><br></pre></td></tr></table></figure></p>
<p>“__express”，ejs模块的一个公共属性，表示要渲染的文件扩展名。</p>
<h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2.静态资源"></a>2.静态资源</h3><hr>
<p>如果要在网页中加载静态文件（css、js、img），就需要另外指定一个存放静态文件的目录，当浏览器发出非HTML文件请求时，服务器端就会到这个目录下去寻找相关文件。</p>
<p>项目目录下添加一个存放静态文件的目录为public。</p>
<p>在public目录下在添加三个存放js、css、img的目录，相应取名为javascripts、stylesheets、images。</p>
<p>然后就可以把相关文件放到相应的目录下了。</p>
<p>比如，浏览器发出如下的样式表请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"/stylesheets/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"screen"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务器端就到public/stylesheets/目录中寻找bootstrap.min.css文件。</p>
<p>有了静态目录文件，我们还得在启动文件里告诉它这个静态文件路径，需要指定一下，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(require(&apos;path&apos;).join(__dirname, &apos;public&apos;)));</span><br></pre></td></tr></table></figure></p>
<p>PS：express.static —— 指定静态文件的查找目录。</p>
<p>使用use函数调用中间件指定express静态访问目录，’public’就是我们我们新建的用来存放静态文件的总目录。</p>
<h3 id="3-添加视图"><a href="#3-添加视图" class="headerlink" title="3.添加视图"></a>3.添加视图</h3><hr>
<p>下面我们就来添加网页模板了，项目中我们会新建一个目录用来单独存放模板文件，这里我们就统一放到根路径上了。</p>
<p>下面开始新建index.html、login.html、home.html三个页面。</p>
<p>1.index.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:400px;width:550px;margin:50px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin-left: 35px;&quot;&gt;</span><br><span class="line">        # 首页</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; style=&quot;margin-top: 90px;margin-left: 60px;&quot;&gt; </span><br><span class="line">            # 欢迎进入首页！</span><br><span class="line">            &lt;div style=&quot;margin-top: 145px;&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; value=&quot;登 陆&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.login.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">... </span><br><span class="line">&lt;div style=&quot;height:300px;width:350px;margin:100px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width:200px;margin:auto;margin-top:50px;&quot;&gt; </span><br><span class="line">        # 用户登录</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; method=&quot;post&quot; &gt;</span><br><span class="line">            &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; style=&quot;margin: 20px 0px;&quot; /&gt;</span><br><span class="line">            &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; /&gt;</span><br><span class="line">            &lt;div style=&quot;margin-top:30px;margin-left:125px;&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; value=&quot;登 陆&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.home.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:400px;width:550px;margin:50px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin-left: 45px;&quot;&gt;</span><br><span class="line">        # 主页</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; style=&quot;margin-top: 90px;&quot;&gt;</span><br><span class="line">            # 登陆成功！</span><br><span class="line">            &lt;div style=&quot;margin-top: 145px;&quot;&gt;</span><br><span class="line">                &lt;input  type=&quot;button&quot; value=&quot;退 出&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>和静态文件一样，我们也要设置views存放的目录，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设定views变量，意为视图存放的目录</span><br><span class="line">app.set(&apos;views&apos;, __dirname);</span><br></pre></td></tr></table></figure></p>
<p>有了网页模板和指定目录，下面就可以访问它们了。</p>
<h3 id="4-渲染视图"><a href="#4-渲染视图" class="headerlink" title="4.渲染视图"></a>4.渲染视图</h3><hr>
<p>我们要如何对网页模板进行访问呢，这就要用到res对象的render函数了。</p>
<p>render函数，对网页模板进行渲染。</p>
<p>格式：res.render(view, [locals], callback);</p>
<p>参数view就是模板的文件名callback用来处理返回的渲染后的字符串，options、callback可省略，在渲染模板时locals可为其模板传入变量值，在模板中就可以调用所传变量了。</p>
<p>比如渲染我们刚刚添加的index.html页面，我们就可以在app.js中写入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">app.set(&apos;views&apos;, __dirname);</span><br><span class="line">app.set( &apos;view engine&apos;, &apos;html&apos; );</span><br><span class="line">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</span><br><span class="line">app.get(&apos;/&apos;, function(req, res) &#123;</span><br><span class="line">    res.render(&apos;index&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(80);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-url重定向"><a href="#5-url重定向" class="headerlink" title="5.url重定向"></a>5.url重定向</h3><hr>
<h4 id="redirect基本用法"><a href="#redirect基本用法" class="headerlink" title="redirect基本用法"></a>redirect基本用法</h4><p>redirect方法允许网址的重定向，跳转到指定的url并且可以指定status，默认为302方式。</p>
<p>格式：res.redirect([status], url);</p>
<p>例1：使用一个完整的url跳转到一个完全不同的域名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.redirect(&quot;http://www.hubwiz.com&quot;);</span><br></pre></td></tr></table></figure></p>
<p>例2：跳转指定页面，比如登陆页，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.redirect(&quot;login&quot;);</span><br></pre></td></tr></table></figure></p>
<p>后面我们开始实现登陆功能，先试一下redirect重定向</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-04T06:45:23.000Z"><a href="/2014/05/04/express/express(1)基础知识/">2014-05-04</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/04/express/express(1)基础知识/">一.基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-认识express"><a href="#1-认识express" class="headerlink" title="1.认识express"></a>1.认识express</h3><hr>
<p>npm提供了大量的第三方模块，其中不乏许多Web框架，比如其中的一个轻量级的Web框架 ——— Express。</p>
<p>Express是一个简洁、灵活的node.js Web应用开发框架, 它提供一系列强大的功能，比如：模板解析、静态文件服务、中间件、路由控制等等,并且还可以使用插件或整合其他模块来帮助你创建各种 Web和移动设备应用,是目前最流行的基于Node.js的Web开发框架，并且支持Ejs、jade等多种模板，可以快速地搭建一个具有完整功能的网站。</p>
<p>好，下面开始吧！</p>
<p>1.NPM安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></p>
<p>2.获取、引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure></p>
<p>通过变量“app”我们就可以调用express的各种方法了。</p>
<h3 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h3><hr>
<p>认识了Express框架，我们开始创建我们的第一个express应用。</p>
<p>在我们的默认项目主文件app.js添加如下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">   response.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;); </span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-get请求"><a href="#3-get请求" class="headerlink" title="3.get请求"></a>3.get请求</h3><hr>
<p>前面我们实现了一个简单的express应用，下面我们就开始具体讲述它的具体实现，首先我们先来学习Express的常用方法。</p>
<p>get方法 —— 根据请求路径来处理客户端发出的GET请求。</p>
<p>格式：app.get(path,function(request, response));</p>
<p>path为请求的路径，第二个参数为处理请求的回调函数，有两个参数分别是request和response，代表请求信息和响应信息。</p>
<p>如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">   response.send(<span class="string">'Welcome to the homepage!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">   response.send(<span class="string">'Welcome to the about page!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.send(<span class="string">"404 error!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面示例中，指定了about页面路径、根路径和所有路径的处理方法。并且在回调函数内部，使用HTTP回应的send方法，表示向浏览器发送一个字符串。</p>
<h3 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h3><hr>
<p>1.什么是中间件？</p>
<p>中间件(middleware)就是处理HTTP请求的函数，用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。 它最大的特点就是，一个中间件处理完，可以把相应数据再传递给下一个中间件。</p>
<p>2.一个不进行任何操作、只传递request对象的中间件，大概是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Middleware</span>(<span class="params">request, response, next</span>) </span>&#123; </span><br><span class="line">   next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的next为中间件的回调函数。如果它带有参数，则代表抛出一个错误，参数为错误文本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Middleware</span>(<span class="params">request, response, next</span>) </span>&#123; </span><br><span class="line">   next(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。如果没有调用next方法,后面注册的函数也是不会执行的。</p>
<h3 id="5-all方法"><a href="#5-all方法" class="headerlink" title="5.all方法"></a>5.all方法</h3><hr>
<h4 id="all函数的基本用法"><a href="#all函数的基本用法" class="headerlink" title="all函数的基本用法"></a>all函数的基本用法</h4><p>和get函数不同app.all()函数可以匹配所有的HTTP动词，也就是说它可以过滤所有路径的请求，如果使用all函数定义中间件，那么就相当于所有请求都必须先通过此该中间件。</p>
<p>格式：app.all(path,function(request, response));</p>
<p>如下所示，我们使用all函数在请求之前设置响应头属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html;charset=utf-8"</span> &#125;);      <span class="comment">//设置响应头属性值</span></span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"欢迎来到首页!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"欢迎来到about页面!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">"404 - 未找到!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码参数中的“*”表示对所有路径有效，这个方法在给特定前缀路径或者任意路径上处理时会特别有用，不管我们请求任何路径都会事先经过all函数。</p>
<h3 id="6-use方法1"><a href="#6-use方法1" class="headerlink" title="6.use方法1"></a>6.use方法1</h3><hr>
<h4 id="use基本用法1"><a href="#use基本用法1" class="headerlink" title="use基本用法1"></a>use基本用法1</h4><p>use是express调用中间件的方法，它返回一个函数。</p>
<p>格式：app.use([path], function(request, response, next){});</p>
<p>可选参数path默认为”/“。</p>
<p>1.使用中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'/'</span>)));</span><br></pre></td></tr></table></figure></p>
<p>如上，我们就使用use函数调用express中间件设定了静态文件目录的访问路径(这里假设为根路径)。</p>
<p>如何连续调用两个中间件呢，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"method："</span>+request.method+<span class="string">" ==== "</span>+<span class="string">"url："</span>+request.url);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html;charset=utf-8"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">'示例：连续调用两个中间件'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>回调函数的next参数，表示接受其他中间件的调用，函数体中的next()，表示将请求数据传递给下一个中间件。</p>
<p>上面代码先调用第一个中间件，在控制台输出一行信息，然后通过next()，调用第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以req对象就不再向后传递了。</p>
<h3 id="7-use方法2"><a href="#7-use方法2" class="headerlink" title="7.use方法2"></a>7.use方法2</h3><hr>
<h4 id="use基本用法2"><a href="#use基本用法2" class="headerlink" title="use基本用法2"></a>use基本用法2</h4><p>use方法不仅可以调用中间件，还可以根据请求的网址，返回不同的网页内容，如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.url == <span class="string">"/"</span>) &#123;</span><br><span class="line">      response.send(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">     response.send(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     next();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.send(<span class="string">"404 error!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。</p>
<h3 id="8-回调函数"><a href="#8-回调函数" class="headerlink" title="8.回调函数"></a>8.回调函数</h3><hr>
<p>Express回调函数有两个参数，分别是request(简称req)和response(简称res)，request代表客户端发来的HTTP请求，response代表发向客户端的HTTP回应，这两个参数都是对象。示例如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-获取主机、路径名"><a href="#9-获取主机、路径名" class="headerlink" title="9.获取主机、路径名"></a>9.获取主机、路径名</h3><hr>
<p>如何使用req对象来处理客户端发来的HTTP请求。</p>
<p>1.req.host返回请求头里取的主机名(不包含端口号)。</p>
<p>2.req.path返回请求的URL的路径名。</p>
<p>如下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.path);</span><br><span class="line">    res.send(<span class="string">"req.host获取主机名，req.path获取请求路径名!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-Get请求-query"><a href="#10-Get请求-query" class="headerlink" title="10.Get请求 - query"></a>10.Get请求 - query</h3><hr>
<p>query是一个可获取客户端get请求路径参数的对象属性，包含着被解析过的请求参数对象，默认为{}。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query.参数名);</span><br><span class="line">    res.send(<span class="string">"测试query属性!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过req.query获取get请求路径的对象参数值。</p>
<p>格式：req.query.参数名；请求路径如下示例：</p>
<p>例1： /search?n=Hanmeimei<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.query.n  <span class="comment">// "Hanmeimei"</span></span><br></pre></td></tr></table></figure></p>
<p>例2： /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.query.order  <span class="comment">// "desc"</span></span><br><span class="line">req.query.shoe.color  <span class="comment">// "blue"</span></span><br><span class="line">req.query.shoe.type  <span class="comment">// "converse"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="11-Get请求-param"><a href="#11-Get请求-param" class="headerlink" title="11.Get请求 - param"></a>11.Get请求 - param</h3><hr>
<p>和属性query一样，通过req.param我们也可以获取被解析过的请求参数对象的值。</p>
<p>格式：req.param(“参数名”)；请求路径如下示例：</p>
<p>例1： 获取请求根路径的参数值，如/?n=Lenka，方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.param(<span class="string">"n"</span>)); <span class="comment">//Lenka</span></span><br><span class="line">    res.send(<span class="string">"使用req.param属性获取请求根路径的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>例2：我们也可以获取具有相应路由规则的请求对象，假设路由规则为 /user/:name/，请求路径/user/mike,如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/user/:name/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.param(<span class="string">"name"</span>)); <span class="comment">//mike</span></span><br><span class="line">    res.send(<span class="string">"使用req.param属性获取具有路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>PS：所谓“路由”，就是指为不同的访问路径，指定不同的处理方法。</p>
<h3 id="12-Get请求-params"><a href="#12-Get请求-params" class="headerlink" title="12.Get请求 - params"></a>12.Get请求 - params</h3><hr>
<p>和param相似，但params是一个可以解析包含着有复杂命名路由规则的请求对象的属性。</p>
<p>格式：req.params.参数名；</p>
<p>例1. 如上课时请求根路径的例子，我们就可以这样获取，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">"/user/:name/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.name); <span class="comment">//mike</span></span><br><span class="line">    res.send(<span class="string">"使用req.params属性获取具有路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>查看运行结果，和param属性功能是一样的，同样获取name参数值。</p>
<p>例2：当然我们也可以请求复杂的路由规则，如/user/:name/:id，假设请求地址为：/user/mike/123，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/user/:name/:id"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id); <span class="comment">//"123"</span></span><br><span class="line">    res.send(<span class="string">"使用req.params属性复杂路由规则的参数对象值!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于请求地址具有路由规则的路径来说，属性params比param属性是不是又强大了那么一点点呢！</p>
<h3 id="13-send"><a href="#13-send" class="headerlink" title="13.send"></a>13.send</h3><hr>
<p>send()方法向浏览器发送一个响应信息，并可以智能处理不同类型的数据。格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.send([body|status], [body]);</span><br></pre></td></tr></table></figure></p>
<p>1.当参数为一个String时，Content-Type默认设置为”text/html”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.send(&apos;Hello World&apos;); //Hello World</span><br></pre></td></tr></table></figure></p>
<p>2.当参数为Array或Object时，Express会返回一个JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.send(&#123; user: &apos;tobi&apos; &#125;); //&#123;&quot;user&quot;:&quot;tobi&quot;&#125;</span><br><span class="line">res.send([1,2,3]); //[1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>3.当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应体，比如：200会返回字符”OK”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.send(200); // OK</span><br><span class="line">res.send(404); // Not Found</span><br><span class="line">res.send(500); // Internal Server Error</span><br></pre></td></tr></table></figure></p>
<p>send方法在输出响应时会自动进行一些设置，比如HEAD信息、HTTP缓存支持等等。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-06T07:45:23.000Z"><a href="/2014/04/06/MongoDB/MongoDB(2)文档的增删改查/">2014-04-06</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/06/MongoDB/MongoDB(2)文档的增删改查/">二.文档的增删改查</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-简单插入文档"><a href="#1-简单插入文档" class="headerlink" title="1.简单插入文档"></a>1.简单插入文档</h3><hr>
<p>在数据库中，数据插入是最基本的操作，在MongoDB使用db.collection.insert(document)语句来插入文档，如下图：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkinsert1.png" alt=""></p>
<p>document是文档数据，collection是存放文档数据的集合。</p>
<p>例如：所有用户的信息存放在users集合中，每个用户的信息为一个user文档，插入数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert(user);</span><br></pre></td></tr></table></figure></p>
<p>如果collection存在，document会添加到collection目录下， 如果collection不存在，数据库会先创建collection，然后再保存document。</p>
<h3 id="2-批量插入文档"><a href="#2-批量插入文档" class="headerlink" title="2.批量插入文档"></a>2.批量插入文档</h3><hr>
<p>nsert语句不但可以插入单个文档，还可以一次性插入多个文档。</p>
<p>插入多个文档时，insert命令的参数为一个数组，数组元素为BSON格式的文档。</p>
<p>多个文档可以放在一个数组内，一次插入多条数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert([&#123;name:&quot;tommy&quot;&#125;,&#123;name:&quot;xiaoming&quot;&#125;])</span><br></pre></td></tr></table></figure></p>
<p>文档批量插入非常方便，但是使用批量插入时也有一些问题需要注意，因为BSON格式的限制，一次插入的数据量不能超过16M，在一个insert命令中插入多条数据时，MongoDB不保证完全成功或完全失败。</p>
<h3 id="3-查询与投影"><a href="#3-查询与投影" class="headerlink" title="3.查询与投影"></a>3.查询与投影</h3><hr>
<p>在MongoDB中，查询指向特定的文档集合，查询设定条件，指明MongoDB需要返回的文档；查询也可以包含一个投影，指定返回的字段。</p>
<p>如下图，在查询过程指定了一个查询条件和一个排序修饰。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkquery.jpg" alt=""></p>
<p>在关系型数据库中，投影指的是对列的筛选，类似的，在MongoDB中，投影指的是对出现在结果集中的对象属性的筛选。</p>
<h3 id="4-find-方法"><a href="#4-find-方法" class="headerlink" title="4.find()方法"></a>4.find()方法</h3><hr>
<p>MongoDB中查询检索数据时使用find命令，使用方法如下：</p>
<p>语法：<br>db.collection.find(criteria,projection);<br>参数：<br>criteria – 查询条件，文档类型，可选。</p>
<p>projection– 返回的字段，文档类型，可选,若需返回所有字段，则忽略此参数。</p>
<p>find命令两个可选参数，criteria为查询条件，projection为返回的字段，如果不传入条件数据库会返回该集合的所有文档。</p>
<p>如下图简单示例：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkfind.jpg" alt=""></p>
<h3 id="5-修改文档-update命令"><a href="#5-修改文档-update命令" class="headerlink" title="5.修改文档 - update命令"></a>5.修改文档 - update命令</h3><hr>
<p>update命令可以更新指定文档的特定字段值，也可以替换整个文档，如果更新操作会增加文档大小，MongoDB将重新分配空间并重新定位。</p>
<p>语法：<br>db.collection.update(query,update,{upsert:boolean,multi:boolean});<br>参数：<br>query：查询条件，文档，和find中的查询条件写法一致。</p>
<p>update：修改内容，文档。</p>
<p>upsert(可选)：如果值为true，那么当集合中没有匹配文档时，创建文档。默认false。</p>
<p>multi(可选)：如果值为true，那么将更新全部符合条件的文档，否则仅更新一个文档，默认false。</p>
<p>如下示例：将users集合中所有符合条件”age&gt;18”文档的status字段更新为”A”。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkupdate.jpg" alt=""></p>
<h3 id="6-修改文档-save命令"><a href="#6-修改文档-save命令" class="headerlink" title="6.修改文档 - save命令"></a>6.修改文档 - save命令</h3><hr>
<p>save命令可以更新或插入一个新文档，与update命令不同的是，save只能对一个文档进行操作。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save();</span><br></pre></td></tr></table></figure></p>
<p>参数：<br>document：新的文档；</p>
<h3 id="7-删除文档-remove命令"><a href="#7-删除文档-remove命令" class="headerlink" title="7.删除文档 - remove命令"></a>7.删除文档 - remove命令</h3><hr>
<p>需要删除文档时使用remove命令，删除文档可以清理掉不需要的数据，释放存储空间，提升检索效率，但是错误的删除会是一场灾难，因此在执行数据删除操作时需要非常的谨慎！</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">    query,</span><br><span class="line">    justOne</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p>
<p>参数：<br>query：BSON类型，删除文档的条件。</p>
<p>justOne：布尔类型，true：只删除一个文档，false：默认值，删除所有符合条件的文档。</p>
<p>下面是一个是将users集合中所有status=”D”的文档删除操作，对比一下MongoDB和传统SQL数据库删除的操作，看看有哪些不同之处。</p>
<p>与传统SQL比较 - 删除文档</p>
<p>MongoDB</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkremove.jpg" alt=""></p>
<p>传统SQL</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkremove-sql.jpg" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-03T06:45:23.000Z"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">2014-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/03/MongoDB/MongoDB(1)简单介绍/">一.简单介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是MongoDB"><a href="#1-什么是MongoDB" class="headerlink" title="1.什么是MongoDB"></a>1.什么是MongoDB</h3><hr>
<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个高性能，开源，无模式的文档型数据库，官方给自己的定义是Key-value存储(高性能和高扩展)和传统RDBMS(丰富的查询和功能)之间的一座桥梁。</p>
<h3 id="2-Document和BSON"><a href="#2-Document和BSON" class="headerlink" title="2.Document和BSON"></a>2.Document和BSON</h3><hr>
<p>MongoDB中保存的数据格式为BSON，如：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbson.jpg" alt=""></p>
<p>MongoDB中数据的基本单元称为文档(Document)，它是MongoDB的核心概念，由多个键极其关联的值有序的放置在一起组成，数据库中它对应于关系型数据库的行。</p>
<p>数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p>
<p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON，BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p>
<p>BSON的优点是灵活性高，但它的缺点是空间利用率不是很理想，BSON有三个特点：轻量性、可遍历性、高效性。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-27T12:45:23.000Z"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">2014-03-27</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/27/Mongoose/Mongoose(6)属性方法/">六.属性方法</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-ObjectId类型"><a href="#1-ObjectId类型" class="headerlink" title="1.ObjectId类型"></a>1.ObjectId类型</h3><hr>
<h4 id="ObjectId简述"><a href="#ObjectId简述" class="headerlink" title="ObjectId简述"></a>ObjectId简述</h4><p>存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。</p>
<p>使用过MySQL等关系型数据库的友友们都知道，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，MongoDB采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，一次代表：</p>
<p>4字节：UNIX时间戳<br>3字节：表示运行MongoDB的机器<br>2字节：表示生成此_id的进程<br>3字节：由一个随机数开始的计数器生成的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var tSchema = new mongoose.Schema(&#123;&#125;); //默认_id:ObjectId类型</span><br></pre></td></tr></table></figure></p>
<p>每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。</p>
<h3 id="2-添加属性"><a href="#2-添加属性" class="headerlink" title="2.添加属性"></a>2.添加属性</h3><hr>
<h4 id="Schema添加属性值"><a href="#Schema添加属性值" class="headerlink" title="Schema添加属性值"></a>Schema添加属性值</h4><p>前面我们已经讲述了如何定义一个Schema并赋予某些属性值,那能不能先定义后添加属性呢，答案是可以的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var TempSchema = new mongoose.Schema;</span><br><span class="line">TempSchema.add(&#123; name: &apos;String&apos;, email: &apos;String&apos;, age: &apos;Number&apos; &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-实例方法"><a href="#3-实例方法" class="headerlink" title="3.实例方法"></a>3.实例方法</h3><hr>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">var saySchema = new mongoose.Schema(&#123;name : String&#125;);</span><br><span class="line">saySchema.method(&apos;say&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;Trouble Is A Friend&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">var say = mongoose.model(&apos;say&apos;, saySchema);</span><br><span class="line">var lenka = new say();</span><br><span class="line">lenka.say(); //Trouble Is A Friend</span><br></pre></td></tr></table></figure></p>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4.静态方法"></a>4.静态方法</h3><hr>
<h4 id="Schema静态方法"><a href="#Schema静态方法" class="headerlink" title="Schema静态方法"></a>Schema静态方法</h4><p>接下来将讲述怎么为Schema创建静态方法。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); </span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.static(&apos;findByName&apos;, function (name, callback) &#123;</span><br><span class="line">    return this.find(&#123; name: name &#125;, callback);</span><br><span class="line">&#125;);</span><br><span class="line">var TestModel = db.model(&quot;test1&quot;, TestSchema );</span><br><span class="line">TestModel.findByName(&apos;tom&apos;, function (err, docs) &#123;</span><br><span class="line"> //docs所有名字叫tom的文档结果集</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-追加方法"><a href="#5-追加方法" class="headerlink" title="5.追加方法"></a>5.追加方法</h3><hr>
<h4 id="Schema追加方法"><a href="#Schema追加方法" class="headerlink" title="Schema追加方法"></a>Schema追加方法</h4><p>有时场景的需要，我们甚至可以为Schema模型追加方法。</p>
<p>为Schema模型追加speak方法，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);</span><br><span class="line">var TestSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.methods.speak = function()&#123;</span><br><span class="line">  console.log(&apos;我的名字叫&apos;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">var TestModel = db.model(&apos;test1&apos;,TestSchema);</span><br><span class="line">var TestEntity = new TestModel(&#123;name:&apos;Lenka&apos;&#125;);</span><br><span class="line">TestEntity.speak();//我的名字叫Lenka</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/6/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/8/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/tags/ES6/">ES6</a><small>4</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-IO/">Node.js_IO</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-JS基础/">Node.js_JS基础</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-事件/">Node.js_事件</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-入门/">Node.js_入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js-异步编程/">Node.js_异步编程</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-模块/">Node.js_模块</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-测试/">Node.js_测试</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-网络/">Node.js_网络</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-进程/">Node.js_进程</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-错误处理和调试/">Node.js_错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/区块链/">区块链</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/安全/">安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>