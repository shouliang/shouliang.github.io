<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-04T06:45:23.000Z"><a href="/2016/09/04/计算机网络/HTTP 协议入门/">2016-09-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/04/计算机网络/HTTP 协议入门/">HTTP 协议入门</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="HTTP-协议入门"><a href="#HTTP-协议入门" class="headerlink" title="HTTP 协议入门"></a>HTTP 协议入门</h1><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。<br>本文介绍 HTTP 协议的历史演变和设计思路。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/http01.jpg" alt=""></p>
<h2 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener"><strong>应用层协议</strong></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h2 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>
<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p>
<p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>可以看到，这个格式与0.9版有很大变化。</p>
<p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p>
<p>下面是一些常见的<code>Content-Type</code>字段的值。</p>
<ul>
<li>text/plain</li>
<li>text/html</li>
<li>text/css</li>
<li>image/jpeg</li>
<li>image/png</li>
<li>image/svg+xml</li>
<li>audio/mp4</li>
<li>video/mp4</li>
<li>application/javascript</li>
<li>application/pdf</li>
<li>application/zip</li>
<li>application/atom+xml</li>
</ul>
<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p>除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">  &lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>
<p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h2 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p>
<p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">“分块传输编码”</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"> </span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">“队头堵塞”</a>（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>
<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h2 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h3 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h3><p><a href="http://kamranahmed.info/blog/2016/08/13/http-in-depth/" target="_blank" rel="noopener">Journey to HTTP/2</a>, by Kamran Ahmed<br><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">HTTP</a>, by Wikipedia<br><a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">HTTP/1.0 Specification</a><br><a href="https://http2.github.io/http2-spec/" target="_blank" rel="noopener">HTTP/2 Specification</a></p>
<h3 id="七、原文"><a href="#七、原文" class="headerlink" title="七、原文"></a>七、原文</h3><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-05T14:16:53.000Z"><a href="/2016/08/05/Node.js_事件/The Node.js Event Loop, Timers, and process.nextTick()/">2016-08-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/05/Node.js_事件/The Node.js Event Loop, Timers, and process.nextTick()/">The Node.js Event Loop, Timers, and process.nextTick()</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="The-Node-js-Event-Loop-Timers-and-process-nextTick"><a href="#The-Node-js-Event-Loop-Timers-and-process-nextTick" class="headerlink" title="The Node.js Event Loop, Timers, and process.nextTick()"></a>The Node.js Event Loop, Timers, and <code>process.nextTick()</code></h1><h2 id="What-is-the-Event-Loop"><a href="#What-is-the-Event-Loop" class="headerlink" title="What is the Event Loop?"></a>What is the Event Loop?</h2><p>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.</p>
<p>Since most modern kernels are <strong>multi-threaded</strong>, they can handle multiple operations executing in the background. When one of these operations completes, the kernel tells Node.js so that the appropriate callback may be added to the <strong>poll</strong> queue to eventually be executed. We’ll explain this in further detail later in this topic.</p>
<h2 id="Event-Loop-Explained"><a href="#Event-Loop-Explained" class="headerlink" title="Event Loop Explained"></a>Event Loop Explained</h2><p>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the <a href="https://nodejs.org/api/repl.html#repl_repl" target="_blank" rel="noopener">REPL</a>, which is not covered in this document) which may make async API calls, schedule timers, or call <code>process.nextTick()</code>, then begins processing the event loop.</p>
<p>The following diagram shows a simplified overview of the event loop’s order of operations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>
<p><em>note: each box will be referred to as a “phase” of the event loop.</em></p>
<p>Each phase has a FIFO queue of callbacks to execute. While each phase is special in its own way, generally, when the event loop enters a given phase, it will perform any operations specific to that phase, then execute callbacks in that phase’s queue until the queue has been <strong>exhausted</strong> or the <strong>maximu</strong>m number of callbacks has executed. When the queue has been exhausted or the callback limit is reached, the event loop will move to the next phase, and so on.</p>
<p>Since <strong>any</strong> of these operations <strong>may</strong> schedule <em>more</em> operations and new events processed in the <strong>poll</strong> phase are queued by the kernel, poll events can be queued while polling events are being processed. As a result, long running callbacks can allow the poll phase to run much longer than a timer’s threshold. See the <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#timers" target="_blank" rel="noopener"><strong>timers</strong></a> and <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#poll" target="_blank" rel="noopener"><strong>poll</strong></a> sections for more details.</p>
<p><strong>*NOTE:</strong> There is a slight discrepancy between the Windows and the Unix/Linux implementation, but that’s not important for this demonstration. The most important parts are here. There are actually seven or eight steps, but the ones we care about — ones that Node.js actually uses - are those above.*</p>
<h2 id="Phases-Overview"><a href="#Phases-Overview" class="headerlink" title="Phases Overview"></a>Phases Overview</h2><ul>
<li><strong>timers</strong>: this phase executes callbacks scheduled by <code>setTimeout()</code> and <code>setInterval()</code>.</li>
<li><strong>pending callbacks</strong>: executes I/O callbacks deferred to the next loop iteration.</li>
<li><strong>idle, prepare</strong>: only used internally.</li>
<li><strong>poll</strong>: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and <code>setImmediate()</code>); node will block here when appropriate.</li>
<li><strong>check</strong>: <code>setImmediate()</code> callbacks are invoked here.</li>
<li><strong>close callbacks</strong>: some close callbacks, e.g. <code>socket.on(&#39;close&#39;, ...)</code>.</li>
</ul>
<p>Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down cleanly if there are not any.</p>
<h2 id="Phases-in-Detail"><a href="#Phases-in-Detail" class="headerlink" title="Phases in Detail"></a>Phases in Detail</h2><h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>A timer specifies the <strong>threshold</strong> <em>after which</em> a provided callback <em>may be executed</em> rather than the <strong>exact</strong> time a person <em>wants it to be executed</em>. Timers callbacks will run as early as they can be scheduled after the specified amount of time has passed; however, Operating System scheduling or the running of other callbacks <strong>may delay</strong> them.</p>
<p><strong>*Note</strong>: Technically, the <strong>poll</strong> phase controls when timers are executed.*</p>
<p>For example, say you schedule a timeout to execute after a 100 ms threshold, then your script starts asynchronously reading a file which takes 95 ms:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation(callback) &#123;</span><br><span class="line">  // Assume this takes 95ms to complete</span><br><span class="line">  fs.readFile(&apos;/path/to/file&apos;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeoutScheduled = Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  const delay = Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// do someAsyncOperation which takes 95 ms to complete</span><br><span class="line">someAsyncOperation(() =&gt; &#123;</span><br><span class="line">  const startCallback = Date.now();</span><br><span class="line"></span><br><span class="line">  // do something that will take 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    // do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>When the event loop enters the <strong>poll</strong> phase, it has an empty queue (<code>fs.readFile()</code> has not completed), so it will wait for the number of ms remaining until the soonest timer’s threshold is reached. While it is waiting 95 ms pass, <code>fs.readFile()</code> finishes reading the file and its callback which takes 10 ms to complete is added to the <strong>poll</strong> queue and executed. When the callback finishes, there are no more callbacks in the queue, so the event loop will see that the threshold of the soonest timer has been reached then wrap back to the <strong>timers</strong> phase to execute the timer’s callback. In this example, you will see that the total delay between the timer being scheduled and its callback being executed will be 105ms.</p>
<p>Note: To prevent the <strong>poll</strong> phase from starving the event loop, <a href="http://libuv.org/" target="_blank" rel="noopener">libuv</a> (the C library that implements the Node.js event loop and all of the asynchronous behaviors of the platform) also has a hard maximum (system dependent) before it stops polling for more events.</p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>This phase executes callbacks for some system operations such as types of TCP errors. For example if a TCP socket receives <code>ECONNREFUSED</code> when attempting to connect, some *nix systems want to wait to report the error. This will be queued to execute in the <strong>pending callbacks</strong> phase.</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>The <strong>poll</strong> phase has two main functions:</p>
<ol>
<li>Calculating how long it should block and poll for I/O, then</li>
<li>Processing events in the <strong>poll</strong> queue.</li>
</ol>
<p>When the event loop enters the <strong>poll</strong> phase <em>and there are no timers scheduled</em>, one of two things will happen:</p>
<ul>
<li><em>If the **poll<strong> queue </strong>is not empty**</em>, the event loop will iterate through its queue of callbacks executing them synchronously until either the queue has been exhausted, or the system-dependent hard limit is reached.</li>
<li><em>If the **poll<strong> queue </strong>is empty**</em>, one of two more things will happen:<ul>
<li>If scripts have been scheduled by <code>setImmediate()</code>, the event loop will end the <strong>poll</strong> phase and continue to the <strong>check</strong> phase to execute those scheduled scripts.</li>
<li>If scripts <strong>have not</strong> been scheduled by <code>setImmediate()</code>, the event loop will wait for callbacks to be added to the queue, then execute them immediately.</li>
</ul>
</li>
</ul>
<p>Once the <strong>poll</strong> queue is empty the event loop will check for timers <em>whose time thresholds have been reached</em>. If one or more timers are ready, the event loop will wrap back to the <strong>timers</strong> phase to execute those timers’ callbacks.</p>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>This phase allows a person to execute callbacks immediately after the <strong>poll</strong> phase has <strong>completed</strong>. If the <strong>poll</strong> phase becomes idle and scripts have been queued with <code>setImmediate()</code>, the event loop may continue to the <strong>check</strong> phase rather than waiting.</p>
<p><code>setImmediate()</code> is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that schedules callbacks to execute after the <strong>poll</strong> phase has completed.</p>
<p>Generally, as the code is executed, the event loop will eventually hit the <strong>poll</strong> phase where it will wait for an incoming connection, request, etc. However, if a callback has been scheduled with <code>setImmediate()</code> and the <strong>poll</strong> phase becomes idle, it will end and continue to the <strong>check</strong> phase rather than waiting for <strong>poll</strong> events.</p>
<h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>If a socket or handle is closed abruptly (e.g. <code>socket.destroy()</code>), the <code>&#39;close&#39;</code> event will be emitted in this phase. Otherwise it will be emitted via <code>process.nextTick()</code>.</p>
<h2 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a><code>setImmediate()</code> vs <code>setTimeout()</code></h2><p><code>setImmediate</code> and <code>setTimeout()</code> are similar, but behave in different ways depending on when they are called.</p>
<ul>
<li><code>setImmediate()</code> is designed to execute a script once the current <strong>poll</strong> phase <strong>completes</strong>.</li>
<li><code>setTimeout()</code> schedules a script to be run after a minimum threshold in ms has elapsed.</li>
</ul>
<p>The order in which the timers are executed will vary depending on the context in which they are called. If both are called from within the main module, then timing will be bound by the performance of the process (which can be impacted by other applications running on the machine).</p>
<p>For example, if we run the following script which is not within an I/O cycle (i.e. the main module), the order in which the two timers are executed is <strong>non-deterministic</strong>, as it is bound by the performance of the process:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;immediate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>However, if you move the two calls within an I/O cycle, the immediate callback is always executed <strong>first</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;timeout&apos;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;immediate&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>The main advantage to using <code>setImmediate()</code> over <code>setTimeout()</code> is <code>setImmediate()</code>will always be executed before any timers if scheduled within an I/O cycle, independently of how many timers are present.</p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h2><h3 id="Understanding-process-nextTick"><a href="#Understanding-process-nextTick" class="headerlink" title="Understanding process.nextTick()"></a>Understanding <code>process.nextTick()</code></h3><p>You may have noticed that <code>process.nextTick()</code> was not displayed in the diagram, even though it’s a part of the asynchronous API. This is because <code>process.nextTick()</code> is not technically part of the event loop. Instead, the <code>nextTickQueue</code> will be processed after the current operation completes, regardless of the current phase of the event loop.</p>
<p>Looking back at our diagram, any time you call <code>process.nextTick()</code> in a given phase, all callbacks passed to <code>process.nextTick()</code> will be resolved <strong>before</strong> the event loop continues. This can create some bad situations because <strong>it allows you to “starve” your I/O by making recursive process.nextTick() calls</strong>, which prevents the event loop from reaching the <strong>poll</strong> phase.</p>
<h3 id="Why-would-that-be-allowed"><a href="#Why-would-that-be-allowed" class="headerlink" title="Why would that be allowed?"></a>Why would that be allowed?</h3><p>Why would something like this be included in Node.js? Part of it is a design philosophy where an API should always be asynchronous even where it doesn’t have to be. Take this code snippet for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function apiCall(arg, callback) &#123;</span><br><span class="line">  if (typeof arg !== &apos;string&apos;)</span><br><span class="line">    return process.nextTick(callback,</span><br><span class="line">                            new TypeError(&apos;argument should be string&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The snippet does an argument check and if it’s not correct, it will pass the error to the callback. The API updated fairly recently to allow passing arguments to <code>process.nextTick()</code> allowing it to take any arguments passed after the callback to be propagated as the arguments to the callback so you don’t have to nest functions.</p>
<p>What we’re doing is passing an error back to the user but only <em>after</em> we have allowed the rest of the user’s code to execute. By using <code>process.nextTick()</code> we guarantee that <code>apiCall()</code> always runs its callback <em>after</em> the rest of the user’s code and <em>before</em> the event loop is allowed to proceed. To achieve this, the JS call stack is allowed to unwind then immediately execute the provided callback which allows a person to make recursive calls to <code>process.nextTick()</code> without reaching a <code>RangeError: Maximum call stack size exceeded from v8</code>.</p>
<p>This philosophy can lead to some potentially problematic situations. Take this snippet for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">// this has an asynchronous signature, but calls callback synchronously</span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">// the callback is called before `someAsyncApiCall` completes.</span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line">  // since someAsyncApiCall has completed, bar hasn&apos;t been assigned any value</span><br><span class="line">  console.log(&apos;bar&apos;, bar); // undefined</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br></pre></td></tr></table></figure>
<p>The user defines <code>someAsyncApiCall()</code> to have an asynchronous signature, but it actually operates synchronously. When it is called, the callback provided to <code>someAsyncApiCall()</code>is called in the same phase of the event loop because <code>someAsyncApiCall()</code> doesn’t actually do anything asynchronously. As a result, the callback tries to reference <code>bar</code> even though it may not have that variable in scope yet, because the script has not been able to run to completion.</p>
<p>By placing the callback in a <code>process.nextTick()</code>, the script still has the ability to run to completion, allowing all the variables, functions, etc., to be initialized prior to the callback being called. It also has the advantage of not allowing the event loop to continue. It may be useful for the user to be alerted to an error before the event loop is allowed to continue. Here is the previous example using <code>process.nextTick()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br></pre></td></tr></table></figure>
<p>Here’s another real world example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&apos;listening&apos;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>When only a port is passed, the port is bound immediately. So, the <code>&#39;listening&#39;</code> callback could be called immediately. The problem is that the <code>.on(&#39;listening&#39;)</code> callback will not have been set by that time.</p>
<p>To get around this, the <code>&#39;listening&#39;</code> event is queued in a <code>nextTick()</code> to allow the script to run to completion. This allows the user to set any event handlers they want.</p>
<h2 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a><code>process.nextTick()</code> vs <code>setImmediate()</code></h2><p>We have two calls that are similar as far as users are concerned, but their names are confusing.</p>
<ul>
<li><code>process.nextTick()</code> fires immediately on the same phase</li>
<li><code>setImmediate()</code> fires on the following iteration or ‘tick’ of the event loop</li>
</ul>
<p>In essence, the names should be swapped. <code>process.nextTick()</code> fires more immediately than <code>setImmediate()</code>, but this is an artifact of the past which is unlikely to change. Making this switch would break a large percentage of the packages on npm. Every day more new modules are being added, which means every day we wait, more potential breakages occur. While they are confusing, the names themselves won’t change.</p>
<p><em>We recommend developers use setImmediate() in all cases because it’s easier to reason about (and it leads to code that’s compatible with a wider variety of environments, like browser JS.)</em></p>
<h2 id="Why-use-process-nextTick"><a href="#Why-use-process-nextTick" class="headerlink" title="Why use process.nextTick()?"></a>Why use <code>process.nextTick()</code>?</h2><p>There are two main reasons:</p>
<ol>
<li>Allow users to handle errors, cleanup any then unneeded resources, or perhaps try the request again before the event loop continues.</li>
<li>At times it’s necessary to allow a callback to run after the call stack has unwound but before the event loop continues.</li>
</ol>
<p>One example is to match the user’s expectations. Simple example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer();</span><br><span class="line">server.on(&apos;connection&apos;, (conn) =&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8080);</span><br><span class="line">server.on(&apos;listening&apos;, () =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>
<p>Say that <code>listen()</code> is run at the beginning of the event loop, but the listening callback is placed in a <code>setImmediate()</code>. Unless a hostname is passed, binding to the port will happen immediately. For the event loop to proceed, it must hit the <strong>poll</strong> phase, which means there is a non-zero chance that a connection could have been received allowing the connection event to be fired before the listening event.</p>
<p>Another example is running a function constructor that was to, say, inherit from <code>EventEmitter</code> and it wanted to call an event within the constructor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line">  EventEmitter.call(this);</span><br><span class="line">  this.emit(&apos;event&apos;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line">myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;an event occurred!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>You can’t emit an event from the constructor immediately because the script will not have processed to the point where the user assigns a callback to that event. So, within the constructor itself, you can use <code>process.nextTick()</code> to set a callback to emit the event after the constructor has finished, which provides the expected results:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line">const util = require(&apos;util&apos;);</span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line">  EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">  // use nextTick to emit the event once a handler is assigned</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    this.emit(&apos;event&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line">myEmitter.on(&apos;event&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;an event occurred!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#the-node-js-event-loop-timers-and-process-nexttick" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#the-node-js-event-loop-timers-and-process-nexttick</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-31T07:45:21.000Z"><a href="/2016/07/31/Angular/AngularJS简介/">2016-07-31</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/31/Angular/AngularJS简介/">一.简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-AugularJS简介"><a href="#1-AugularJS简介" class="headerlink" title="1.AugularJS简介"></a>1.AugularJS简介</h3><hr>
<p>AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。</p>
<p>AngularJS有五个主要核心特性，如下介绍：</p>
<ul>
<li><p>双向数据绑定 —— 实现了把model与view完全绑定在一起，model变化，view也变化，反之亦然。</p>
</li>
<li><p>模板 —— 在AngularJS中，模板相当于HTML文件被浏览器解析到DOM中，AngularJS遍历这些DOM，也就是说AuguarJS把模板当做DOM来操作，去生成一些指令来完成对view的数据绑定。</p>
</li>
<li><p>MVVM —— 吸收了传统的MVC设计模式针但又并不执行传统意义上的MVC，更接近于MVVM(Moodel-View-ViewModel)。</p>
</li>
<li><p>依赖注入 —— AngularJS拥有内建的依赖注入子系统，可以帮助开发人员更容易的开发，理解和测试应用。</p>
</li>
<li><p>指令 —— 可以用来创建自定义的标签，也可以用来装饰元素或者操作DOM属性</p>
</li>
</ul>
<h3 id="2-引入AngularJS脚本"><a href="#2-引入AngularJS脚本" class="headerlink" title="2.引入AngularJS脚本"></a>2.引入AngularJS脚本</h3><hr>
<p>认识了AngularJS框架，我们开始创建第一个AngularJS应用。</p>
<p>AngularJS是以一个JavaScript文件形式发布的，可通过script标签载入AngularJS脚本，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>完整的html代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html ng-app&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello &#123;&#123;&apos;World&apos;&#125;&#125;!</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>请在您的浏览器中运行以上代码查看效果。 </p>
<h3 id="3-AngularJS指令"><a href="#3-AngularJS指令" class="headerlink" title="3.AngularJS指令"></a>3.AngularJS指令</h3><hr>
<p>AngularJS有一套完整的、可扩展的、用来帮助web应用开发的指令集，它使得HTML可以转变成“特定领域语言(DSL)”，是用来扩展浏览器能力的技术之一，在DOM编译期间，和HTML关联着的指令会被检测到，并且被执行，这使得指令可以为DOM指定行为，或者改变它。</p>
<p>AngularJS通过称为指令的新属性来扩展的HTML，带有前缀ng-，我们也可以称之为“指令属性”，它就是绑定在DOM元素上的函数，可以调用方法、定义行为、绑定controller及$scope对象、操作DOM，等等。</p>
<p>AngularJS指令指示的是“当关联的HTML结构进入编译阶段时应该执行的操作”，它本质上只是一个当编译器编译到相关DOM时需要执行的函数，可以写在元素的名称里，属性里，css类名里，注释里。</p>
<p>当浏览器启动、开始解析HTML时，DOM元素上的指令属性就会跟其他属性一样被解析，也就是说当一个Angular.js应用启动，Angular编译器就会遍历DOM树来解析HTML，寻找这些指令属性函数，在一个DOM元素上找到一个或多个这样的指令属性函数，它们就会被收集起来、排序，然后按照优先级顺序被执行。</p>
<p>Angular.js应用的动态性和响应能力，都要归功于指令属性，常见的有：ng-app、ng-init、ng-model、ng-bind、ng-repeat等等。</p>
<h3 id="4-指令：ng-app"><a href="#4-指令：ng-app" class="headerlink" title="4.指令：ng-app"></a>4.指令：ng-app</h3><hr>
<p>ng-app指令来标明一个AngularJS应用程序，并通过AngularJS完成自动初始化应用和标记应用根作用域，同时载入和指令内容相关的模块，并通过拥有ng-app指令的标签为根节点开始编译其中的DOM。</p>
<p>引用方法很简单，如下所示：</p>
<pre><code>&lt;div ng-app=&quot;&quot;&gt;
&lt;/div&gt;  
</code></pre><p>如上引用，一个AngularJS应用程序初始化就完成了并标记了作用域，也就是div元素就是AngularJS应用程序的所有者，在它里面的指令也就会被Angular编译器所编译、解析了。</p>
<h3 id="5-指令：ng-init"><a href="#5-指令：ng-init" class="headerlink" title="5.指令：ng-init"></a>5.指令：ng-init</h3><hr>
<p>g-init指令初始化应用程序数据，也就是为AngularJS应用程序定义初始值，通常情况下，我们会使用一个控制器或模块来代替它，后面我们会介绍有关控制器和模块的知识。</p>
<p>如下所示，我们为应用程序变量name赋定初始值。</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;name=&apos;Hello World&apos;&quot;&gt;
&lt;/div&gt;
</code></pre><p>我们不仅可以赋值字符串，也可以赋值为数字、数组、对象，而且可以为多个变量赋初始值，如下所示：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;price=5&quot;&gt;
&lt;/div&gt;
</code></pre><p>//或者</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[&apos;Tom&apos;,&apos;Jerry&apos;,&apos;Gaffey&apos;]&quot;&gt;
&lt;/div&gt;
</code></pre><h3 id="6-数据绑定：表达式"><a href="#6-数据绑定：表达式" class="headerlink" title="6.数据绑定：表达式"></a>6.数据绑定：表达式</h3><hr>
<p>AngularJS框架的核心功能之一 —— 数据绑定，由两个花括号组成，可以把数据绑定到HTML，类似Javascript代码片段，可以包含文字、运算符和变量，通常在绑定数据中用到，表达式可以绑定数字、字符串、对象、数组，写在双大括号内。</p>
<p>如前面的示例，我们就可以使用表达式这样调用初始化的变量值，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-app=&quot;&quot; ng-init=&quot;name=&apos;Hello World&apos;&quot;&gt;</span><br><span class="line"> 		&#123;&#123; name &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然我们也可以使用表达式输出数字、数组等等，如下所示：<br>2.1. 输出数字，如下示例：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=12;price=5&quot;&gt;
    总价： {{ quantity * price }}
&lt;/div&gt;
</code></pre><p>2.2. 输出对象，如下示例：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[&apos;Tom&apos;,&apos;Jerry&apos;,&apos;Gaffey&apos;]&quot;&gt;
    名字为： {{ names[0] }}
&lt;/div&gt;
</code></pre><h3 id="7-指令：ng-model"><a href="#7-指令：ng-model" class="headerlink" title="7.指令：ng-model"></a>7.指令：ng-model</h3><hr>
<p>在AngularJS中，只需要使用ng-model指令就可以把应用程序数据绑定到HTML元素，实现model和view的双向绑定。</p>
<p>如下示例，使用ng-model指令对数据进行绑定。</p>
<pre><code>&lt;div ng-app=&quot;&quot;&gt;
    请输入任意值：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&gt;
    你输入的为： {{ name }}
&lt;/div&gt;
</code></pre><p>ng-model把相关处理事件绑定到指定标签上，这样我们就可以不用在手工处理相关事件(比如change等)的条件下完成对数据的展现需求。</p>
<h3 id="8-数据绑定：ng-bind"><a href="#8-数据绑定：ng-bind" class="headerlink" title="8.数据绑定：ng-bind"></a>8.数据绑定：ng-bind</h3><hr>
<p>指令ng-bind和AngularJS表达式有异曲同工之妙，但不同之处就在于ng-bind是在angular解析渲染完毕后才将数据显示出来的。</p>
<p>如下使用ng-bind指令绑定把应用程序数据。</p>
<pre><code>&lt;div ng-app=&quot;&quot;&gt;
        请输入一个名字：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&gt;
        Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>PS：使用花括号语法时，因为浏览器需要首先加载页面，渲染它，然后AngularJS才能把它解析成你期望看到的内容，所以对于首个页面中的数据绑定操作，建议采用ng-bind，以避免其未被渲染的模板被用户看到。</p>
<h3 id="9-指令：ng-click"><a href="#9-指令：ng-click" class="headerlink" title="9.指令：ng-click"></a>9.指令：ng-click</h3><hr>
<p>AngularJS也有自己的HTML事件指令,比如说通过ng-click定义一个AngularJS单击事件。</p>
<p>对按钮、链接等，我们都可以用ng-click指令属性来实现绑定，如下简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-app=&quot;&quot; ng-init=&quot;click=false&quot;&gt;</span><br><span class="line">    &lt;button ng-click=&quot;click= !click&quot;&gt;隐藏/显示&lt;/button&gt;</span><br><span class="line">    &lt;div ng-hide=&quot;click&quot;&gt;</span><br><span class="line">        请输入一个名字：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&gt;</span><br><span class="line">        Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt; </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>PS：ng-hide=”true”，设置HTML元素不可见。</p>
<p>ng-click指令将DOM元素的鼠标点击事件(即mousedown)绑定到一个方法上，当浏览器在该DOM元素上鼠标触发点击事件时，Angular就会调用相应的方法，是不是很简单方便呢！</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-23T14:16:53.000Z"><a href="/2016/07/23/Node.js_进程/Nodejs编写守护进程/">2016-07-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/23/Node.js_进程/Nodejs编写守护进程/">Nodejs编写守护进程</a></h1>
  

    </header>
    <div class="entry">
      
        <p>目前Nodejs编写一个守护进程非常简单，在6.3.1版本中已经存在非常方便的API，这些API可以帮助我们更方便的创建一个守护进程。本文仅在描述守护进程的创建方式，而不会对守护进程所要执行的任务做任何描述。</p>
<h3 id="守护进程的启动方式"><a href="#守护进程的启动方式" class="headerlink" title="守护进程的启动方式"></a>守护进程的启动方式</h3><p>如果不在Nodejs环境中，我们如何创建守护进程？过程如下：</p>
<ol>
<li>创建一个进程A。</li>
<li>在进程A中创建进程B，我们可以使用fork方式，或者其他方法。</li>
<li>对进程B执行 <code>setsid</code> 方法。</li>
<li>进程A退出，进程B由init进程接管。此时进程B为守护进程。</li>
</ol>
<h3 id="Setsid详解"><a href="#Setsid详解" class="headerlink" title="Setsid详解"></a>Setsid详解</h3><p><code>setsid</code> 主要完成三件事：</p>
<ol>
<li>该进程变成一个新会话的会话领导。</li>
<li>该进程变成一个新进程组的组长。</li>
<li>该进程没有控制终端。</li>
</ol>
<p>然而，Nodejs中并没有对 <code>setsid</code> 方法的直接封装，翻阅文档发现有一个地方是可以调用该方法的。</p>
<h3 id="Nodejs中启动子进程方法"><a href="#Nodejs中启动子进程方法" class="headerlink" title="Nodejs中启动子进程方法"></a>Nodejs中启动子进程方法</h3><p>借助 <code>clild_process</code> 中的 <code>spawn</code> 即可创建子进程，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">var</span> process = <span class="built_in">require</span>(<span class="string">'process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = spawn(<span class="string">'node'</span>,[<span class="string">'b.js'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid, p.pid);</span><br></pre></td></tr></table></figure>
<p>注意，这里只打印当前进程的PID和子进程的PID，同时为了观察效果，我并没有将父进程退出。</p>
<p><code>b.js</code> 中代码很简单，打开一个资源，并不停的写入数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> process = <span class="built_in">require</span>(<span class="string">'process'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">"/Users/mebius/Desktop/log.txt"</span>,<span class="string">'w'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fs.write(fd,process.pid+<span class="string">"\n"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行后的效果如图：<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/fork01_180703.png" alt=""></p>
<p>我们来看以下 <code>top</code> 命令下的进程情况。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/fork02_180703.png" alt=""></p>
<p>看一看到，此时父进程PID为17055，子进程的PPID为17055，PID为17056.</p>
<h3 id="Nodejs中Setsid的调用"><a href="#Nodejs中Setsid的调用" class="headerlink" title="Nodejs中Setsid的调用"></a>Nodejs中Setsid的调用</h3><p>到此为止，守护进程已经完成一半，下面要调用setsid方法，并且退出父进程。</p>
<p>代码修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">var</span> process = <span class="built_in">require</span>(<span class="string">'process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = spawn(<span class="string">'node'</span>,[<span class="string">'b.js'</span>],&#123;</span><br><span class="line">        detached : <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid, p.pid);</span><br><span class="line">process.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>spawn</code> 的第三个参数中，可以设置 <code>detached</code> 属性，如果该属性为true，则会调用 <code>setsid</code> 方法。这样就满足我们对守护进程的要求。</p>
<p>在此运行命令。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/fork03_180703.png" alt=""></p>
<p>查看 <code>top</code> 命令</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/fork04_180703.png" alt=""></p>
<p>可以看到，当前仅存在一个PID为17062的进程，这个进程就是我们要的守护进程。</p>
<blockquote>
<p>由于每次运行PID都不同，所以此次子进程的PID于第一次不同。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>守护进程最重要的是稳定，如果守护进程挂掉，那么其管理的子进程都将变为孤儿进程，同时被init进程接管，这是我们不愿意看到的。于此同时，守护进程对于子进程的管理也是有非常多的发挥余地的，例如PM2中，将一个进程同时启动4次，达到CPU多核使用的目的（很有可能你的进程在同一核中运行），进程挂掉后自动重启等等，这些事情等着我们去造轮子。</p>
<p>普通的进程, 在用户退出终端之后就会直接关闭. 通过 &amp; 启动到后台的进程, 之后会由于会（session组）被回收而终止进程. 守护进程是不依赖终端（tty）的进程, 不会因为用户退出终端而停止运行的进程.</p>
<p>总体来说，Nodejs启动守护进程方式比较简单，默认所暴露的API也屏蔽了很多系统级别API，使得大家使用上更加方便，但没有接触过Linux的人在理解上有一些复杂。推荐大家学习Nodejs的同时，多学习Linux系统调用的和系统内核的一些东西。</p>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://ashan.org/archives/917" target="_blank" rel="noopener">https://ashan.org/archives/917</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-23T14:16:53.000Z"><a href="/2016/06/23/Node.js/Node.js项目的配置文件/">2016-06-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/23/Node.js/Node.js项目的配置文件/">Node.js 项目的配置文件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在使用 Node.js 编写一个完整的项目时，程序中往往需要用到一些可配置的变量，从而使得程序能在不同的环境中运行。本文将介绍几种常见的方法。</p>
<h2 id="通过环境变量指定配置"><a href="#通过环境变量指定配置" class="headerlink" title="通过环境变量指定配置"></a>通过环境变量指定配置</h2><p><a href="http://baike.baidu.com/view/95930.htm" target="_blank" rel="noopener">环境变量（environment variables）</a> 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。比如<code>HOME</code>表示当前用户的根目录，<code>TMPDIR</code>表示系统临时目录等，我们可以通过设置一些特定的环境变量，程序在启动时可以读取这些环境变量并做相应的初始化动作。</p>
<p>在 Node.js 中可以通过<code>process.env</code>来访问当前的环境变量信息，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123; PATH: &apos;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&apos;,</span><br><span class="line">  TMPDIR: &apos;/var/folders/rs/g4wqpvvj7bj08t35dxvfm0rr0000gn/T/&apos;,</span><br><span class="line">  LOGNAME: &apos;glen&apos;,</span><br><span class="line">  XPC_FLAGS: &apos;0x0&apos;,</span><br><span class="line">  HOME: &apos;/Users/glen&apos;,</span><br><span class="line">  TERM: &apos;xterm-256color&apos;,</span><br><span class="line">  COLORFGBG: &apos;7;0&apos;,</span><br><span class="line">  USER: &apos;glen&apos;,</span><br><span class="line">  ITERM_PROFILE: &apos;Glen&apos;,</span><br><span class="line">  TERM_PROGRAM: &apos;iTerm.app&apos;,</span><br><span class="line">  XPC_SERVICE_NAME: &apos;0&apos;,</span><br><span class="line">  SHELL: &apos;/bin/zsh&apos;,</span><br><span class="line">  ITERM_SESSION_ID: &apos;w0t4p0&apos;,</span><br><span class="line">  PWD: &apos;/Users/glen/work&apos;,</span><br><span class="line">  __CF_USER_TEXT_ENCODING: &apos;0x1F5:0x0:0x0&apos;,</span><br><span class="line">  LC_CTYPE: &apos;UTF-8&apos;,</span><br><span class="line">  SHLVL: &apos;1&apos;,</span><br><span class="line">  OLDPWD: &apos;/Users/glen/work&apos;,</span><br><span class="line">  ZSH: &apos;/Users/glen/.oh-my-zsh&apos;,</span><br><span class="line">  PAGER: &apos;less&apos;,</span><br><span class="line">  LESS: &apos;-R&apos;,</span><br><span class="line">  LSCOLORS: &apos;Gxfxcxdxbxegedabagacad&apos;,</span><br><span class="line">  AUTOJUMP_SOURCED: &apos;1&apos;,</span><br><span class="line">  AUTOJUMP_ERROR_PATH: &apos;/Users/glen/Library/autojump/errors.log&apos;,</span><br><span class="line">  RUST_SRC_PATH: &apos;/Users/glen/work/source/rust/src&apos;,</span><br><span class="line">  _: &apos;/usr/local/bin/node&apos; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>环境变量的名字一般为大写，多个单词之间可通过下划线来连接。</p>
<p>Windows 系统下可通过<code>set</code>命令来设置环境变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set HELLO_MSG=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>
<p>Linux 系统下可通过<code>export</code>命令来设置，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HELLO_MSG=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>
<h3 id="在-Node-js-中读取环境变量"><a href="#在-Node-js-中读取环境变量" class="headerlink" title="在 Node.js 中读取环境变量"></a>在 Node.js 中读取环境变量</h3><p>创建文件<code>test.js</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.HELLO_MSG);</span><br></pre></td></tr></table></figure>
<p>然后在命令行中执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HELLO_MSG=&quot;Hello, world&quot; &amp;&amp; node test.js</span><br></pre></td></tr></table></figure>
<p>控制台将输出<code>Hello, world</code>，即我们启动程序时给环境变量<code>HELLO_MSG</code>设置的值。</p>
<h2 id="通过配置文件指定配置"><a href="#通过配置文件指定配置" class="headerlink" title="通过配置文件指定配置"></a>通过配置文件指定配置</h2><p>一些规模较小的项目往往会通过单一的配置文件来存储其配置， 在启动时会载入文件<code>config.js</code>，该文件的大概结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">  // debug 为 true 时，用于本地调试</span><br><span class="line">  debug: true,</span><br><span class="line"></span><br><span class="line">  name: &apos;Nodeclub&apos;, // 社区名字</span><br><span class="line">  description: &apos;CNode：Node.js 专业中文社区&apos;, // 社区的描述</span><br><span class="line">  keywords: &apos;nodejs, node, express, connect, socket.io&apos;,</span><br><span class="line"></span><br><span class="line">  // 其他配置项...</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure>
<p>在程序启动的时候，可以使用<code>require()</code>来载入此文件，得到一个对象，然后通过此对象的属性来读取相应的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 载入配置文件</span><br><span class="line">var config = require(&apos;./config&apos;);</span><br><span class="line"></span><br><span class="line">// 以下为使用到配置的部分代码：</span><br><span class="line">if (!config.debug &amp;&amp; config.oneapm_key) &#123;</span><br><span class="line">  require(&apos;oneapm&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: config.session_secret,</span><br><span class="line">  store: new RedisStore(&#123;</span><br><span class="line">    port: config.redis_port,</span><br><span class="line">    host: config.redis_host,</span><br><span class="line">  &#125;),</span><br><span class="line">  resave: true,</span><br><span class="line">  saveUninitialized: true,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(config.port, function () &#123;</span><br><span class="line">  logger.log(&apos;NodeClub listening on port&apos;, config.port);</span><br><span class="line">  logger.log(&apos;God bless love....&apos;);</span><br><span class="line">  logger.log(&apos;You can debug your app with http://&apos; + config.hostname + &apos;:&apos; + config.port);</span><br><span class="line">  logger.log(&apos;&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用配置文件与使用环境变量来指定配置相比，配置文件的可读性更强，可以表示一些更复杂的结构，而使用环境变量一般只限于<code>key=value</code>的形式。但在配置项数量较少时，使用环境变量会更简单，比如项目中只需要配置一个监听端口，可以简单使用<code>export PORT=3000 &amp;&amp; node app.js</code>命令来启动程序，而不需要单独创建一个配置文件。大多数时候往往会结合这两种方式来进行，下文讲详细讲解。</p>
<h3 id="其他配置文件格式"><a href="#其他配置文件格式" class="headerlink" title="其他配置文件格式"></a>其他配置文件格式</h3><p>一般为了方便，在 Node.js 项目中会习惯使用<code>.js</code>文件格式，它的好处是可以使用通过程序来动态生成一些配置项，比如一个配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">  // 文件上传配置</span><br><span class="line">  // 注：如果填写 qn_access，则会上传到 7 牛，以下配置无效</span><br><span class="line">  upload: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;public/upload/&apos;),</span><br><span class="line">    url: &apos;/public/upload/&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中使用到了<code>path.join()</code>和<code>__dirname</code>来生成<code>upload.path</code>。</p>
<h4 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h4><p>另外，我们也可以使用 <a href="http://json.org/" target="_blank" rel="noopener">JSON</a> 格式的配置文件，比如文件<code>config.json</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;name&quot;: &quot;Nodeclub&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;CNode：Node.js 专业中文社区&quot;,</span><br><span class="line">  &quot;keywords&quot;: &quot;nodejs, node, express, connect, socket.io&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中可以通过以下方式来载入 JSON 文件配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过 require()函数</span><br><span class="line">var config = require(&apos;./config.json&apos;);</span><br><span class="line"></span><br><span class="line">// 读取文件并使用 JSON.parse()解析</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var config = JSON.parse(fs.readFileSync(&apos;./config.json&apos;).toString());</span><br></pre></td></tr></table></figure>
<p>大多数时候，我们往往需要添加一些备注信息来说明某个配置项的使用方法及用途，在标准 JSON 文件中是不允许添加备注的，我们可以使用<code>strip-json-comments</code>模块来去掉配置文件中的备注，再将其当作标准的 JSON 来解析。</p>
<p>比如以下是带备注信息的 JSON 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // debug 为 true 时，用于本地调试</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  // 社区名字</span><br><span class="line">  &quot;name&quot;: &quot;Nodeclub&quot;,</span><br><span class="line">  // 社区的描述</span><br><span class="line">  &quot;description&quot;: &quot;CNode：Node.js 专业中文社区&quot;,</span><br><span class="line">  &quot;keywords&quot;: &quot;nodejs, node, express, connect, socket.io&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以编写一个<code>loadJSONFile()</code>函数来载入带有备注的 JSON 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var stripJsonComments = require(&apos;strip-json-comments&apos;);</span><br><span class="line"></span><br><span class="line">function loadJSONFile (file) &#123;</span><br><span class="line">  var json = fs.readFileSync(file).toString();</span><br><span class="line">  return JSON.parse(stripJsonComments(json));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var config = loadJSONFile(&apos;./config.json&apos;);</span><br><span class="line">console.log(config);</span><br></pre></td></tr></table></figure>
<h4 id="YAML-格式"><a href="#YAML-格式" class="headerlink" title="YAML 格式"></a>YAML 格式</h4><p><a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a> 是面向所有编程语言的对人类友好的数据序列化标准。其最大的优点是可读性较好，比如以下 YAML 格式的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name: John Smith</span><br><span class="line">age: 37</span><br><span class="line">spouse:</span><br><span class="line">  name: Jane Smith</span><br><span class="line">  age: 25</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 15</span><br><span class="line">  - name: Jenny Smith</span><br><span class="line">    age: 12</span><br></pre></td></tr></table></figure>
<p>其对应的 JSON 结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 37,</span><br><span class="line">  &quot;spouse&quot;: &#123;</span><br><span class="line">    &quot;age&quot;: 25,</span><br><span class="line">    &quot;name&quot;: &quot;Jane Smith&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;name&quot;: &quot;John Smith&quot;,</span><br><span class="line">  &quot;children&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: 15,</span><br><span class="line">      &quot;name&quot;: &quot;Jimmy Smith&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: 12,</span><br><span class="line">      &quot;name&quot;: &quot;Jenny Smith&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Node.js 中可以通过<code>yamljs</code>模块来解析 YAML 格式，比如可以编写一个<code>loadYAMLFile()</code>函数来载入 YAML 格式的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var YAML = require(&apos;yamljs&apos;);</span><br><span class="line"></span><br><span class="line">function loadYAMLFile (file) &#123;</span><br><span class="line">  return YAML.parse(fs.readFileSync(file).toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var config = loadYAMLFile(&apos;./config.yaml&apos;);</span><br><span class="line">console.log(config);</span><br></pre></td></tr></table></figure>
<h2 id="根据运行环境选择不同的配置"><a href="#根据运行环境选择不同的配置" class="headerlink" title="根据运行环境选择不同的配置"></a>根据运行环境选择不同的配置</h2><p>大多数情况下，程序在本地开发环境和生产环境中的配置信息是不一样的，比如开发时连接到的数据库里面的数据是模拟出来的，而生产环境要连接到实际的数据库上，因此我们需要让程序能根据不同的运行环境来载入不同的配置文件。</p>
<h3 id="使用单一配置文件名"><a href="#使用单一配置文件名" class="headerlink" title="使用单一配置文件名"></a>使用单一配置文件名</h3><p>载入的配置文件名为<code>./config.js</code>，项目中有一个默认配置文件<code>./config.default.js</code>。要运行程序，首先需要复制一份默认配置文件，并保存为<code>./config.js</code>，再根据当前运行环境来修改<code>./config.js</code>。</p>
<p>由于<code>./config.js</code>文件已经被添加到<code>.gitignore</code>文件中，因此我们<code>./config.js</code>文件的修改不会被纳入到项目的版本管理中，所以不同机器中的<code>./config.js</code>不会产生冲突，可以使用各自的配置来启动程序。</p>
<h3 id="通过环境变量指定配置文件名"><a href="#通过环境变量指定配置文件名" class="headerlink" title="通过环境变量指定配置文件名"></a>通过环境变量指定配置文件名</h3><p>我们可以通过环境变量来指定配置文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CONFIG_FILE=&quot;./config/production.js&quot;</span><br></pre></td></tr></table></figure>
<p>然后可以通过以下方式来载入配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var config = require(path.resolve(process.env.CONFIG_FILE));</span><br></pre></td></tr></table></figure>
<p>另外，也可以通过环境变量来指定当前运行环境的名称，然后在指定目录下载入相应的配置，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NODE_ENV=&quot;production&quot;</span><br></pre></td></tr></table></figure>
<p>然后可以通过以下方式来载入配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var configFile = path.resolve(&apos;./config&apos;, process.env.NODE_ENV + &apos;.js&apos;);</span><br><span class="line">var config = require(configFile);</span><br></pre></td></tr></table></figure>
<h2 id="使用-config-模块来读取配置"><a href="#使用-config-模块来读取配置" class="headerlink" title="使用 config 模块来读取配置"></a>使用 config 模块来读取配置</h2><p><a href="https://www.npmjs.com/package/config" target="_blank" rel="noopener">config</a> 模块是 NPM 上下载量最高的 Node.js 配置文件管理模块，其实现原理与上文中介绍的方法大同小异，在实际开发中我们可以考虑使用这个现成的模块。下面将介绍此模块的简单使用方法。</p>
<p><code>config</code>模块通过环境变量<code>NODE_CONFIG_DIR</code>来指定配置文件所在的目录，默认为<code>./config</code>（即当前运行目录下的<code>config</code>目录），通过环境变量<code>NODE_ENV</code>来指定当前的运行环境版本。</p>
<p>配置文件使用 JSON 格式，模块加载后，会首先载入默认的配置文件<code>${NODE_CONFIG_DIR}/default.json</code>，再载入文件<code>${NODE_CONFIG_DIR}/${NODE_ENV}.json</code>，如果配置项有冲突则覆盖默认的配置。</p>
<p>比如我们新建默认配置文件<code>config/default.json</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Customer module configs</span><br><span class="line">  &quot;Customer&quot;: &#123;</span><br><span class="line">    &quot;dbConfig&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="line">      &quot;port&quot;: 5984,</span><br><span class="line">      &quot;dbName&quot;: &quot;customers&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;credit&quot;: &#123;</span><br><span class="line">      &quot;initialLimit&quot;: 100,</span><br><span class="line">      // Set low for development</span><br><span class="line">      &quot;initialDays&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再新建<code>production</code>环境配置文件<code>config/production.json</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Customer&quot;: &#123;</span><br><span class="line">    &quot;dbConfig&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;prod-db-server&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;credit&quot;: &#123;</span><br><span class="line">      &quot;initialDays&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再新建测试文件<code>1.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var config = require(&apos;config&apos;);</span><br><span class="line">console.log(config);</span><br></pre></td></tr></table></figure>
<p>执行程序，可看到其输出的结果为默认的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; Customer:</span><br><span class="line">   &#123; dbConfig: &#123; host: &apos;localhost&apos;, port: 5984, dbName: &apos;customers&apos; &#125;,</span><br><span class="line">     credit: &#123; initialLimit: 100, initialDays: 1 &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>假如要使用<code>production</code>的配置，则使用以下命令启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NODE_ENV=production &amp;&amp; node 1.js</span><br></pre></td></tr></table></figure>
<p>则其输出将是如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; Customer:</span><br><span class="line">   &#123; dbConfig: &#123; host: &apos;prod-db-server&apos;, port: 5984, dbName: &apos;customers&apos; &#125;,</span><br><span class="line">     credit: &#123; initialLimit: 100, initialDays: 30 &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>production.json</code>文件中，重新定义了<code>Customer.dbConfig.host</code>和<code>Customer.credit.initialDays</code>这两个配置项，所以在<code>production</code>环境中仅这两项被覆盖为新的值，而其他配置项则使用<code>default.json</code>中指定的值。</p>
<p>载入<code>config</code>模块后，其返回的对象实际上就是当前的配置信息，同时提供了两个方法<code>get()</code>和<code>has()</code>来操作配置项。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var config = require(&apos;config&apos;);</span><br><span class="line">console.log(config);</span><br><span class="line">console.log(config.get(&apos;Customer&apos;));</span><br><span class="line">console.log(config.get(&apos;Customer.dbConfig&apos;));</span><br><span class="line">console.log(config.has(&apos;Customer.dbConfig.host&apos;));</span><br><span class="line">console.log(config.has(&apos;Customer.dbConfig.host2&apos;));</span><br></pre></td></tr></table></figure>
<p>执行程序后输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; Customer:</span><br><span class="line">   &#123; dbConfig: &#123; host: &apos;localhost&apos;, port: 5984, dbName: &apos;customers&apos; &#125;,</span><br><span class="line">     credit: &#123; initialLimit: 100, initialDays: 1 &#125; &#125; &#125;</span><br><span class="line">&#123; dbConfig: &#123; host: &apos;localhost&apos;, port: 5984, dbName: &apos;customers&apos; &#125;,</span><br><span class="line">  credit: &#123; initialLimit: 100, initialDays: 1 &#125; &#125;</span><br><span class="line">&#123; host: &apos;localhost&apos;, port: 5984, dbName: &apos;customers&apos; &#125;</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>其中<code>get()</code>用来获取指定配置，可以使用诸如<code>Customer.dbConfig</code>这样的格式，如果配置项不存在则会抛出异常。<code>has()</code>用来检测指定配置项是否存在，如果存在则返回<code>true</code>。</p>
<p>关于<code>config</code>模块的详细使用方法可阅读其帮助文档。</p>
<p>现阶段github上不错的库有：<code>dotenv</code>, <code>node-config</code></p>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://morning.work/page/2015-09/nodejs_project_config_loader.html" target="_blank" rel="noopener">http://morning.work/page/2015-09/nodejs_project_config_loader.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-15T14:16:53.000Z"><a href="/2016/04/15/Node.js_IO/Buffer那些事儿/">2016-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/15/Node.js_IO/Buffer那些事儿/">Buffer那些事儿</a></h1>
  

    </header>
    <div class="entry">
      
        <p>作为前端的JSer，是一件非常幸福的事情，因为在字符串上从来没有出现过任何纠结的问题。我们来看看PHP对字符串长度的判断结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php </span><br><span class="line">echo strlen(&quot;0123456789&quot;);     </span><br><span class="line">echo strlen(&quot;零一二三四五六七八九&quot;);     </span><br><span class="line">echo mb_strlen(&quot;零一二三四五六七八九&quot;, &quot;utf-8&quot;);      </span><br><span class="line">echo &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>以上三行判断分别返回10、30、10。对于中国人而言，strlen这个方法对于Unicode的判断结果是非常让人疑惑。而看看JavaScript中对字符串长度的判断，就知道这个length属性对调用者而言是多么友好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"0123456789"</span>.length); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"零一二三四五六七八九"</span>.length); <span class="regexp">/10</span></span><br><span class="line"><span class="regexp">console.log("\u00bd".length); /</span><span class="regexp">/ 1</span></span><br></pre></td></tr></table></figure>
<p>尽管在计算机内部，一个中文字和一个英文字占用的字节位数是不同的，但对于用户而言，它们拥有相同的长度。我认为这是JavaScript中 String处理得精彩的一个点。正是由于这个原因，所有的数据从后端传输到前端被调用时，都是这般友好的字符串。所以对于前端工程师而言，他们是没有字 符串Buffer的概念的。如果你是一名前端工程师，那么从此在与Node.js打交道的过程中，一定要小心Buffer啦，因为它比传统的String 要调皮一点。</p>
<h2 id="你该小心Buffer啦"><a href="#你该小心Buffer啦" class="headerlink" title="你该小心Buffer啦"></a>你该小心Buffer啦</h2><p>像许多计算机的技术一样，都是从国外传播过来的。那些以英文作为母语的传道者们应该没有考虑过英文以外的使用者，所以你有可能看到如下这样一段代码在向你描述如何在data事件中连接字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>)</span>&#123;</span><br><span class="line">    data += trunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果这个文件读取流读取的是一个纯英文的文件，这段代码是能够正常输出的。但是如果我们再改变一下条件，将每次读取的buffer大小变成一个奇数，以模拟一个字符被分配在两个trunk中的场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>, &#123;<span class="attr">bufferSize</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>我们将会得到以下这样的乱码输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件循���和请求���象构成了Node.js���异步I/O模型的���个基本���素，这也是典���的消费���生产者场景。</span><br></pre></td></tr></table></figure>
<p>造成这个问题的根源在于data += trunk语句里隐藏的错误，在默认的情况下，trunk是一个Buffer对象。这句话的实质是隐藏了toString的变换的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = data.toString() + trunk.toString();</span><br></pre></td></tr></table></figure>
<p>由于汉字不是用一个字节来存储的，导致有被截破的汉字的存在，于是出现乱码。解决这个问题有一个简单的方案，是设置编码集：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'testdata.md'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf-8'</span>, <span class="attr">bufferSize</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>这将得到一个正常的字符串响应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件循环和请求对象构成了Node.js的异步I/O模型的两个基本元素，这也是典型的消费者生产者场景。</span><br></pre></td></tr></table></figure>
<p>遗憾的是目前Node.js仅支持hex、utf8、ascii、binary、base64、ucs2几种编码的转换。对于那些因为历史遗留问题依旧还生存着的GBK，GB2312等编码，该方法是无能为力的。</p>
<h2 id="有趣的string-decoder"><a href="#有趣的string-decoder" class="headerlink" title="有趣的string_decoder"></a>有趣的string_decoder</h2><p>在这个例子中，如果仔细观察，会发现一件有趣的事情发生在设置编码集之后。我们提到data += trunk等价于data = data.toString() + trunk.toString()。通过以下的代码可以测试到一个汉字占用三个字节，而我们按11个字节来截取trunk的话，依旧会存在一个汉字被分割在两个trunk中的情景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"事件循环和请求对象"</span>.length);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">"事件循环和请求对象"</span>).length);</span><br></pre></td></tr></table></figure>
<p>按照猜想的toString()方式，应该返回的是事件循xxx和请求xxx象才对，其中“环”字应该变成乱码才对，但是在设置了encoding（默认的utf8）之后，结果却正常显示了，这个结果十分有趣。</p>
<p>在好奇心的驱使下可以探查到<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L1237" target="_blank" rel="noopener">data事件</a>调用了string_decoder来进行编码补足的行为。通过string_decoder对象输出第一个截取Buffer(事件循xx)时，只返回事件循这个字符串，保留xx。第二次通过string_decoder对象输出时检测到上次保留的xx，将上次剩余内容和本次的Buffer进行重新拼接输出。于是达到正常输出的目的。</p>
<p>string_decoder，目前在文件流读取和网络流读取中都有应用到，一定程度上避免了粗鲁拼接trunk导致的乱码错误。但是，遗憾在于string_decoder目前只支持utf8编码。它的思路其实还可以扩展到其他编码上，只是最终是否会支持目前尚不可得知。</p>
<h2 id="连接Buffer对象的正确方法"><a href="#连接Buffer对象的正确方法" class="headerlink" title="连接Buffer对象的正确方法"></a>连接Buffer对象的正确方法</h2><p>那么万能的适应各种编码而且正确的拼接Buffer对象的方法是什么呢？我们从Node.js在github上的源码中找出这样一段<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L107" target="_blank" rel="noopener">正确读取文件，并连接buffer对象的方法</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = [];</span><br><span class="line"><span class="keyword">var</span> nread = <span class="number">0</span>;</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    buffers.push(chunk);</span><br><span class="line">    nread += chunk.length;</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span>(buffers.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: buffer = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: buffer = buffers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            buffer = <span class="keyword">new</span> Buffer(nread);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, pos = <span class="number">0</span>, l = buffers.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> chunk = buffers[i];</span><br><span class="line">                chunk.copy(buffer, pos);</span><br><span class="line">                pos += chunk.length;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在end事件中通过细腻的连接方式，最后拿到理想的Buffer对象。这时候无论是在支持的编码之间转换，还是在不支持的编码之间转换（利用iconv模块转换），都不会导致乱码。</p>
<h2 id="简化连接Buffer对象的过程"><a href="#简化连接Buffer对象的过程" class="headerlink" title="简化连接Buffer对象的过程"></a>简化连接Buffer对象的过程</h2><p>上述一大段代码仅只完成了一件事情，就是连接多个Buffer对象，而这种场景需求将会在多个地方发生，所以，采用一种更优雅的方式来完成该过程是必要的。笔者基于以上的代码封装出一个bufferhelper模块，用于更简洁地处理Buffer对象。可以通过NPM进行安装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bufferhelper</span><br></pre></td></tr></table></figure>
<p>下面的例子演示了如何调用这个模块。与传统data += trunk之间只是bufferHelper.concat(chunk)的差别，既避免了错误的出现，又使得代码可以得到简化而有效地编写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);  </span><br><span class="line"><span class="keyword">var</span> BufferHelper = <span class="built_in">require</span>(<span class="string">'bufferhelper'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bufferHelper = <span class="keyword">new</span> BufferHelper();</span><br><span class="line">    request.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    bufferHelper.concat(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = bufferHelper.toBuffer().toString();</span><br><span class="line">    response.writeHead(<span class="number">200</span>);</span><br><span class="line">    response.end(html);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br></pre></td></tr></table></figure>
<p>所以关于Buffer对象的操作的最佳实践是：</p>
<ul>
<li>保持编码不变，以利于后续编码转换</li>
<li>使用封装方法达到简洁代码的目的</li>
</ul>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="http://www.infoq.com/cn/articles/nodejs-about-buffer" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/nodejs-about-buffer</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-15T14:16:53.000Z"><a href="/2016/04/15/Node.js_错误处理和调试/heapdump简介/">2016-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/15/Node.js_错误处理和调试/heapdump简介/">heapdump简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="heapdump工具介绍"><a href="#heapdump工具介绍" class="headerlink" title="heapdump工具介绍"></a>heapdump工具介绍</h3><blockquote>
<p><code>heapdump</code> 是一个非常有用的node内存调试工具. 它能够在运行时将V8的堆dump到文件中. 这样我们就可以通过chrome的带的的开发者工具查看当时的内存占用情况,帮助我们分析一些内存问题.</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>heapdump</code>的安装时非常简单的,和安装普通的npm包是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install heapdump --save</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>一旦我们安装了<code>heapdump</code>, 我们就可以在代码中使用<code>heapdump</code>了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var heapdump = require(&apos;heapdump&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="生产堆快照"><a href="#生产堆快照" class="headerlink" title="生产堆快照"></a>生产堆快照</h3><p>有两种方法来主动生成堆快照:</p>
<ol>
<li>主动调用方法 <code>writeSnapshot([filename], [callback])</code></li>
<li>通过给进程发送信号 <code>kill -USR2 pid</code></li>
</ol>
<p>默认情况下node进程是可以接收并处理<code>USR2</code>信号的, 如果想要禁止,可以通过添加启动参数来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env NODE_HEAPDUMP_OPTIONS=nosignal node app.js</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在以前的实现中,在生成块照时, <code>heapdump</code> 会fork一个新的node进程异步将老的内存快照信息写入文件. 通过这种方式生成的快照信息不能再chrome的开发者工具中进行比较, 并且和node.js v0.12 版本完全不兼容. 如果你确实想通过这种方式生成快照信息,可以通过添加参数来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env NODE_HEAPDUMP_OPTIONS=fork node script.js</span><br></pre></td></tr></table></figure>
<h3 id="分析快照信息"><a href="#分析快照信息" class="headerlink" title="分析快照信息"></a>分析快照信息</h3><ol>
<li><p>打开chrome控制台<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/chrome-devtool-profile.png" alt=""></p>
</li>
<li><p>加载快照文件</p>
</li>
</ol>
<p>点击<code>load</code>按钮, 选择文件就可以加载快照文件了.<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/chrome-nodejs-heapdump.png" alt=""></p>
<h3 id="配套工具-memwatch-next"><a href="#配套工具-memwatch-next" class="headerlink" title="配套工具 memwatch-next"></a>配套工具 memwatch-next</h3><p>线上运行的程序我们不会时不时的主动生产堆快照信息的, 如果能在发生内存泄露的时候生成快照信息,这样就最好了. 幸运的是有这种运行时内存<br>监控包:<code>memwatch-next</code></p>
<h3 id="安装-memwatch"><a href="#安装-memwatch" class="headerlink" title="安装 memwatch"></a>安装 memwatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install memwatch-next --save</span><br></pre></td></tr></table></figure>
<h3 id="使用-memwatch"><a href="#使用-memwatch" class="headerlink" title="使用 memwatch"></a>使用 memwatch</h3><h4 id="内存泄露监听"><a href="#内存泄露监听" class="headerlink" title="内存泄露监听"></a>内存泄露监听</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memwatch = <span class="built_in">require</span>(<span class="string">'memwatch-next'</span>);</span><br><span class="line">memwatch.on(<span class="string">'leak'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 发生内存泄露时的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Memory leak detected: '</span>, info);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="内存使用监控"><a href="#内存使用监控" class="headerlink" title="内存使用监控"></a>内存使用监控</h3><p>监控内存使用情况最好的方法是在V8的GC后统计内存使用信息, memwatch就是这样做的.当V8执行垃圾回收的时候, memwatch会触发一个事件, 我们可以通过监听该事件来收集内存使用情况.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memwatch.on(<span class="string">'stats'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p>内存状态数据格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;num_full_gc&quot;: 17,</span><br><span class="line">  &quot;num_inc_gc&quot;: 8,</span><br><span class="line">  &quot;heap_compactions&quot;: 8,</span><br><span class="line">  &quot;estimated_base&quot;: 2592568,</span><br><span class="line">  &quot;current_base&quot;: 2592568,</span><br><span class="line">  &quot;min&quot;: 2499912,</span><br><span class="line">  &quot;max&quot;: 2592568,</span><br><span class="line">  &quot;usage_trend&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>estimated_base</code> 和 <code>usage_trend</code> 是随事件变动的. 如果<code>usage_trend</code>的值一直是正数,则表明V8的堆大小是一直增长的, 也就是说程序可能有内存泄露.</p>
<p>V8 有自己执行 GC 的策略, 如当负载比较高的时, V8可能延迟进行GC, <code>memwatch</code> 提供了一个方法<code>gc()</code>可以让我们主动触发GC动作(V8执行full gc 并进行内存整理).</p>
<h3 id="Heap-Diffing"><a href="#Heap-Diffing" class="headerlink" title="Heap Diffing"></a>Heap Diffing</h3><p>针对内存泄露 <code>memwatch</code>提供了方法<code>HeapDiff</code>, 可以让我们对2个heap快照进行比较,找出差异.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take first snapshot </span></span><br><span class="line"><span class="keyword">var</span> hd = <span class="keyword">new</span> memwatch.HeapDiff();</span><br><span class="line"></span><br><span class="line"><span class="comment">// do some things ... </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Take the second snapshot and compute the diff </span></span><br><span class="line"><span class="keyword">var</span> diff = hd.end();</span><br></pre></td></tr></table></figure>
<p>diff 的内容格式是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;before&quot;: &#123; &quot;nodes&quot;: 11625, &quot;size_bytes&quot;: 1869904, &quot;size&quot;: &quot;1.78 mb&quot; &#125;,</span><br><span class="line">  &quot;after&quot;:  &#123; &quot;nodes&quot;: 21435, &quot;size_bytes&quot;: 2119136, &quot;size&quot;: &quot;2.02 mb&quot; &#125;,</span><br><span class="line">  &quot;change&quot;: &#123; &quot;size_bytes&quot;: 249232, &quot;size&quot;: &quot;243.39 kb&quot;, &quot;freed_nodes&quot;: 197,</span><br><span class="line">    &quot;allocated_nodes&quot;: 10007,</span><br><span class="line">    &quot;details&quot;: [</span><br><span class="line">      &#123; &quot;what&quot;: &quot;String&quot;,</span><br><span class="line">        &quot;size_bytes&quot;: -2120,  &quot;size&quot;: &quot;-2.07 kb&quot;,  &quot;+&quot;: 3,    &quot;-&quot;: 62</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; &quot;what&quot;: &quot;Array&quot;,</span><br><span class="line">        &quot;size_bytes&quot;: 66687,  &quot;size&quot;: &quot;65.13 kb&quot;,  &quot;+&quot;: 4,    &quot;-&quot;: 78</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; &quot;what&quot;: &quot;LeakingClass&quot;,</span><br><span class="line">        &quot;size_bytes&quot;: 239952, &quot;size&quot;: &quot;234.33 kb&quot;, &quot;+&quot;: 9998, &quot;-&quot;: 0</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法: 我们可以在memwatch的<code>stats</code>回调事件中调用HeapDiff, 这样就能比较</p>
<h3 id="配合使用"><a href="#配合使用" class="headerlink" title="配合使用"></a>配合使用</h3><p>在每一次发现内存泄漏的时候，我们都将此时的内存堆栈快照写入磁盘中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">memwatch.on(<span class="string">'leak'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.error(info);</span><br><span class="line"> <span class="keyword">var</span> file = <span class="string">'/tmp/myapp-'</span> + process.pid + <span class="string">'-'</span> + <span class="built_in">Date</span>.now() + <span class="string">'.heapsnapshot'</span>;</span><br><span class="line"> heapdump.writeSnapshot(file, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(err);</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">console</span>.error(<span class="string">'Wrote snapshot: '</span> + file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>原文：<a href="https://leokongwq.github.io/2016/11/08/nodejs-heapdump.html" target="_blank" rel="noopener">https://leokongwq.github.io/2016/11/08/nodejs-heapdump.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-12T14:16:53.000Z"><a href="/2016/04/12/Node.js_错误处理和调试/动态修改NodeJS程序中的变量值/">2016-04-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/12/Node.js_错误处理和调试/动态修改NodeJS程序中的变量值/">动态修改Node程序中的变量值</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="启动一个-HTTP-Server"><a href="#启动一个-HTTP-Server" class="headerlink" title="启动一个 HTTP Server"></a>启动一个 HTTP Server</h2><p>用简单的 Hello World 做例子吧，不过略作修改。在 <code>global</code> 下放一个变量 <code>message</code>， 然后打印出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message content will be modified !</span></span><br><span class="line">global.message = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(global.message);</span><br><span class="line">&#125;).listen(<span class="number">8001</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pid = %d'</span>, process.pid);</span><br></pre></td></tr></table></figure>
<p>用命令启动 Server，此时，通过用浏览器访问 <code>http://localhost:8001</code> 可以看到网页内容是 <code>hello world!</code>。 接下来我们将尝试在不改变代码，不重启进程的情况下把 <code>message</code> 换成 “hello bugs!”。</p>
<h2 id="使-Server-进程进入-Debug-模式"><a href="#使-Server-进程进入-Debug-模式" class="headerlink" title="使 Server 进程进入 Debug 模式"></a>使 Server 进程进入 Debug 模式</h2><p>V8 引擎在实现的时候留了 Debugger 接口。 通过命令 <code>node --debug-brk=5858 [filename]</code> 可以启动一个脚本，并且立即进入 Debug 模式。</p>
<p>那么如果是已经运行着的 NodeJS 程序，可以进入 Debug 模式吗？也是可以的，在操作系统下给 NodeJS 的进程发一个 <code>SIGUSR1</code> 信号，可以让进程进入 Debug 模式。 进入 Debug 模式的进程会在本地启动一个 TCP Server 并且默认监听 <code>5858</code> 端口。</p>
<p>此时在另一个命令行窗口执行命令 <code>node debug localhost:5858</code> 就可以连接到 Debugger 调试端口， 并且可以使用很多常用的 Debug 命令，比如 <code>c</code>继续执行，<code>s</code> 步入， <code>o</code>步出等。</p>
<h2 id="Debugger-协议"><a href="#Debugger-协议" class="headerlink" title="Debugger 协议"></a>Debugger 协议</h2><p>使用 <code>node debug hostname:port</code> 命令连接到进程进行 Debug 的方式比较简单，但是要完成一些高级的功能就会处处受限，因为它只封装了 Debugger 协议中 command 的一部分。 下面介绍一下这个简单的协议。</p>
<p>Client 和 Server 的通讯是通过 TCP 进行的。 DebugClient 第一次连接到 DebugServer 的时候会拿到一些 Header，比如 Node 版本， V8 版本等。后面紧跟着一个空的消息1</p>
<p><strong>消息1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type: connect\r\n</span><br><span class="line">V8-Version: <span class="number">3.28</span><span class="number">.71</span><span class="number">.19</span>\r\n</span><br><span class="line">Protocol-Version: <span class="number">1</span>\r\n</span><br><span class="line">Embedding-Host: node v0<span class="number">.12</span><span class="number">.4</span>\r\n</span><br><span class="line">Content-Length: <span class="number">0</span>\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>消息实体由 Header 和 Body 组成，消息1的 Body 为空，所以 Header 中对应的 Content-Length 为 0。而在下面这个例子里，Body 为一个单行的 JSON 字符串，这是由协议所规定的。</p>
<p><strong>消息2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">46</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;<span class="string">"command"</span>:<span class="string">"version"</span>,<span class="string">"type"</span>:<span class="string">"request"</span>,<span class="string">"seq"</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>消息2的类型( type )是 <code>request</code>，代表这是 Client 发给 Server 的命令，其他的可能值是 <code>response</code> 和 <code>event</code> 分别代表 Server 对 Client 的相应，和 Server 端发生的事件。</p>
<p><strong>消息3</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">137</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;<span class="string">"seq"</span>:<span class="number">1</span>,<span class="string">"request_seq"</span>:<span class="number">1</span>,<span class="string">"type"</span>:<span class="string">"response"</span>,<span class="string">"command"</span>:<span class="string">"version"</span>,<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"body"</span>:&#123;<span class="string">"V8Version"</span>:<span class="string">"3.28.71.19"</span>&#125;,<span class="string">"refs"</span>:[],<span class="string">"running"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>消息2是 Client 发送给 Server的，消息3是 Server 对 Client 的相应，那么如何判断消息3是不是消息2的结果呢？可以看到消息2中的 seq 值是1，而 消息3中的 request_seq 值是1。 Debugger 协议正是通过这两个值把异步返回的结果和请求一一对应起来的。</p>
<p>Debugger 协议就是这么的简单。</p>
<h3 id="实例化一个-Debugger-Client"><a href="#实例化一个-Debugger-Client" class="headerlink" title="实例化一个 Debugger Client"></a>实例化一个 Debugger Client</h3><p>了解了 Debugger 协议后，相信好奇心强的程序员已经跃跃欲试自己实现一个了。本着不重复发明轮子的原则开始在网上找实现，找了好久找到这个库 <a href="https://www.npmjs.com/package/pDebug" target="_blank" rel="noopener">pDebug</a>， 可惜这个库已经好久不更新了。后来通过阅读 <code>node-inspector</code> 的源码才发现，其实 NodeJS 自带了一个 Debugger 模块, 相关代码在 <code>_debugger</code> 模块里(<a href="https://github.com/joyent/node/blob/master/lib/_debugger.js" target="_blank" rel="noopener">源码</a>)，由于模块名是以 <code>_</code>开头的，所以网上找不到它的 API，好在代码注释写的非常详细，很快就能上手。</p>
<p>我们需要的正是这个模块下的 Client， 而 Client 其实是继承于 Socket 的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Client = <span class="built_in">require</span>(<span class="string">'_debugger'</span>).Client;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line">client.connect(<span class="number">5858</span>);</span><br><span class="line">client.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连接成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过-Debugger-接口执行命令"><a href="#通过-Debugger-接口执行命令" class="headerlink" title="通过 Debugger 接口执行命令"></a>通过 Debugger 接口执行命令</h3><p>接下来我们来看看如何修改这个 global 的变量，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modifyTheMessage</span>(<span class="params">newMessage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = &#123;</span><br><span class="line">        <span class="string">'command'</span>: <span class="string">'evaluate'</span>,</span><br><span class="line">        <span class="string">'arguments'</span>: &#123;</span><br><span class="line">            <span class="string">'expression'</span>: <span class="string">'global.message="'</span> + newMessage + <span class="string">'"'</span>,</span><br><span class="line">            <span class="string">'global'</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    client.req(msg, <span class="function"><span class="keyword">function</span> (<span class="params">err, body, res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'modified to %s'</span>, newMessage);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>client.req</code> 方法封装了 <code>type=request</code> 消息类型 和 <code>seq</code> 自增的逻辑，因此在构造 <code>msg</code> JSON对象的时候不需要指明这两个属性。 我们要修改 message 其实就是在 JavaScript 调用的顶层执行 <code>global.message=newMessage</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时，再访问 <code>http://localhost:8001</code> 可以看到网页上显示的内容已经由 <code>&#39;hello world!&#39;</code> 变成了 <code>&#39;hello bugs!&#39;</code>，是不是很神奇。</p>
<p>这种方式也带来了很多可能性：</p>
<ul>
<li>动态修改配置</li>
</ul>
<p>线上的服务器不用重启就可以应用新的配置</p>
<ul>
<li>模块注入</li>
</ul>
<p>通过其他任意语言编写的应用程序为已经运行的 NodeJS 进程注入新的模块</p>
<ul>
<li>性能监控</li>
</ul>
<p>可以剥离用户线上代码对第三方性能监控模块的直接依赖</p>
<ul>
<li>错误监控</li>
</ul>
<p>发生异常时，通过 Debugger 可以抓到发生错误的函数和行号，并且抓取各个调用栈中的每一个变量，即使是在闭包里</p>
<ul>
<li>Chrome 调试</li>
</ul>
<p>由于 Chrome 也是基于 V8 的，上述方法也可以用于 Chrome 相关的功能集成</p>
<p>原文：<a href="http://code.oneapm.com/nodejs/2015/06/27/intereference/" target="_blank" rel="noopener">http://code.oneapm.com/nodejs/2015/06/27/intereference/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-10T14:16:53.000Z"><a href="/2016/04/10/Node.js_错误处理和调试/CPU profiling/">2016-04-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/10/Node.js_错误处理和调试/CPU profiling/">CPU profiling</a></h1>
  

    </header>
    <div class="entry">
      
        <p>There are many third party tools available for profiling Node.js applications but, in many cases, the easiest option is to use the Node.js built in profiler. The built in profiler uses the <a href="https://developers.google.com/v8/profiler_example" target="_blank" rel="noopener">profiler inside V8</a> which samples the stack at regular intervals during program execution. It records the results of these samples, along with important optimization events such as jit compiles, as a series of ticks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code-creation,LazyCompile,0,0x2d5000a337a0,396,&quot;bp native array.js:1153:16&quot;,0x289f644df68,~</span><br><span class="line">code-creation,LazyCompile,0,0x2d5000a33940,716,&quot;hasOwnProperty native v8natives.js:198:30&quot;,0x289f64438d0,~</span><br><span class="line">code-creation,LazyCompile,0,0x2d5000a33c20,284,&quot;ToName native runtime.js:549:16&quot;,0x289f643bb28,~</span><br><span class="line">code-creation,Stub,2,0x2d5000a33d40,182,&quot;DoubleToIStub&quot;</span><br><span class="line">code-creation,Stub,2,0x2d5000a33e00,507,&quot;NumberToStringStub&quot;</span><br></pre></td></tr></table></figure>
<p>In the past you need the V8 source code to be able to interpret the ticks. Luckily, tools have recently been introduced into Node.js 4.4.0 that facilitate the consumption of this information without separately building V8 from source. Let’s see how the built-in profiler can help provide insight into application performance.</p>
<p>To illustrate the use of the tick profiler, we will work with a simple Express application. Our application will have two handlers, one for adding new users to our system:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/newUser'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || users.username) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> salt = crypto.randomBytes(<span class="number">128</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.pbkdf2Sync(password, salt, <span class="number">10000</span>, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  users[username] = &#123; salt, hash &#125;;</span><br><span class="line"></span><br><span class="line">  res.sendStatus(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>and another for validating user authentication attempts:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/auth'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || !users[username]) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hash = crypto.pbkdf2Sync(password, users[username].salt, <span class="number">10000</span>, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (users[username].hash.toString() === hash.toString()) &#123;</span><br><span class="line">    res.sendStatus(<span class="number">200</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.sendStatus(<span class="number">401</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>Please note that these are NOT recommended handlers for authenticating users in your Node.js applications and are used purely for illustration purposes. You should not be trying to design your own cryptographic authentication mechanisms in general. It is much better to use existing, proven authentication solutions.</em></p>
<p>Now assume that we’ve deployed our application and users are complaining about high latency on requests. We can easily run the app with the built in profiler:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production node --prof app.js</span><br></pre></td></tr></table></figure>
<p>and put some load on the server using <code>ab</code> (ApacheBench):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;http://localhost:8080/newUser?username=matt&amp;password=password&quot;</span><br><span class="line">ab -k -c 20 -n 250 &quot;http://localhost:8080/auth?username=matt&amp;password=password&quot;</span><br></pre></td></tr></table></figure>
<p>and get an ab output of:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20</span><br><span class="line">Time taken for tests:   46.932 seconds</span><br><span class="line">Complete requests:      250</span><br><span class="line">Failed requests:        0</span><br><span class="line">Keep-Alive requests:    250</span><br><span class="line">Total transferred:      50250 bytes</span><br><span class="line">HTML transferred:       500 bytes</span><br><span class="line">Requests per second:    5.33 [#/sec] (mean)</span><br><span class="line">Time per request:       3754.556 [ms] (mean)</span><br><span class="line">Time per request:       187.728 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1.05 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   3755</span><br><span class="line">  66%   3804</span><br><span class="line">  75%   3818</span><br><span class="line">  80%   3825</span><br><span class="line">  90%   3845</span><br><span class="line">  95%   3858</span><br><span class="line">  98%   3874</span><br><span class="line">  99%   3875</span><br><span class="line"> 100%   4225 (longest request)</span><br></pre></td></tr></table></figure>
<p>From this output, we see that we’re only managing to serve about 5 requests per second and that the average request takes just under 4 seconds round trip. In a real world example, we could be doing lots of work in many functions on behalf of a user request but even in our simple example, time could be lost compiling regular expressions, generating random salts, generating unique hashes from user passwords, or inside the Express framework itself.</p>
<p>Since we ran our application using the <code>--prof</code> option, a tick file was generated in the same directory as your local run of the application. It should have the form <code>isolate-0xnnnnnnnnnnnn-v8.log</code> (where <code>n</code> is a digit).</p>
<p>In order to make sense of this file, we need to use the tick processor bundled with the Node.js binary. To run the processor, use the <code>--prof-process</code> flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --prof-process isolate-0xnnnnnnnnnnnn-v8.log &gt; processed.txt</span><br></pre></td></tr></table></figure>
<p>Opening processed.txt in your favorite text editor will give you a few different types of information. The file is broken up into sections which are again broken up by language. First, we look at the summary section and see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Summary]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">    79    0.2%    0.2%  JavaScript</span><br><span class="line"> 36703   97.2%   99.2%  C++</span><br><span class="line">     7    0.0%    0.0%  GC</span><br><span class="line">   767    2.0%          Shared libraries</span><br><span class="line">   215    0.6%          Unaccounted</span><br></pre></td></tr></table></figure>
<p>This tells us that 97% of all samples gathered occurred in C++ code and that when viewing other sections of the processed output we should pay most attention to work being done in C++ (as opposed to Javascript). With this in mind, we next find the [C++] section which contains information about which C++ functions are taking the most CPU time and see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[C++]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line"> 19557   51.8%   52.9%  node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)</span><br><span class="line">  4510   11.9%   12.2%  _sha1_block_data_order</span><br><span class="line">  3165    8.4%    8.6%  _malloc_zone_malloc</span><br></pre></td></tr></table></figure>
<p>We see that the top 3 entries account for 72.1% of CPU time taken by the program. From this output, we immediately see that at least 51.8% of CPU time is taken up by a function called PBKDF2 which corresponds to our hash generation from a user’s password. However, it may not be immediately obvious how the lower two entries factor into our application (or if it is we will pretend otherwise for the sake of example). To better understand the relationship between these functions, we will next look at the [Bottom up (heavy) profile] section which provides information about the primary callers of each function. Examining this section, we find:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ticks parent  name</span><br><span class="line">19557   51.8%  node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)</span><br><span class="line">19557  100.0%    v8::internal::Builtins::~Builtins()</span><br><span class="line">19557  100.0%      LazyCompile: ~pbkdf2 crypto.js:557:16</span><br><span class="line"></span><br><span class="line"> 4510   11.9%  _sha1_block_data_order</span><br><span class="line"> 4510  100.0%    LazyCompile: *pbkdf2 crypto.js:557:16</span><br><span class="line"> 4510  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30</span><br><span class="line"></span><br><span class="line"> 3165    8.4%  _malloc_zone_malloc</span><br><span class="line"> 3161   99.9%    LazyCompile: *pbkdf2 crypto.js:557:16</span><br><span class="line"> 3161  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30</span><br></pre></td></tr></table></figure>
<p>Parsing this section takes a little more work than the raw tick counts above. Within each of the “call stacks” above, the percentage in the parent column tells you the percentage of samples for which the function in the row above was called by the function in the current row. For example, in the middle “call stack” above for _sha1_block_data_order, we see that _sha1_block_data_order occurred in 11.9% of samples, which we knew from the raw counts above. However, here, we can also tell that it was always called by the pbkdf2 function inside the Node.js crypto module. We see that similarly, _malloc_zone_malloc was called almost exclusively by the same pbkdf2 function. Thus, using the information in this view, we can tell that our hash computation from the user’s password accounts not only for the 51.8% from above but also for all CPU time in the top 3 most sampled functions since the calls to _sha1_block_data_order and _malloc_zone_malloc were made on behalf of the pbkdf2 function.</p>
<p>At this point, it is very clear that the password based hash generation should be the target of our optimization. Thankfully, you’ve fully internalized the <a href="https://nodesource.com/blog/why-asynchronous" target="_blank" rel="noopener">benefits of asynchronous programming</a> and you realize that the work to generate a hash from the user’s password is being done in a synchronous way and thus tying down the event loop. This prevents us from working on other incoming requests while computing a hash.</p>
<p>To remedy this issue, you make a small modification to the above handlers to use the asynchronous version of the pbkdf2 function:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/auth'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.query.username || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> password = req.query.password || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  username = username.replace(<span class="regexp">/[!@#$%^&amp;*]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!username || !password || !users[username]) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  crypto.pbkdf2(password, users[username].salt, <span class="number">10000</span>, <span class="number">512</span>, (err, hash) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (users[username].hash.toString() === hash.toString()) &#123;</span><br><span class="line">      res.sendStatus(<span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.sendStatus(<span class="number">401</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>A new run of the ab benchmark above with the asynchronous version of your app yields:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20</span><br><span class="line">Time taken for tests:   12.846 seconds</span><br><span class="line">Complete requests:      250</span><br><span class="line">Failed requests:        0</span><br><span class="line">Keep-Alive requests:    250</span><br><span class="line">Total transferred:      50250 bytes</span><br><span class="line">HTML transferred:       500 bytes</span><br><span class="line">Requests per second:    19.46 [#/sec] (mean)</span><br><span class="line">Time per request:       1027.689 [ms] (mean)</span><br><span class="line">Time per request:       51.384 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          3.82 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   1018</span><br><span class="line">  66%   1035</span><br><span class="line">  75%   1041</span><br><span class="line">  80%   1043</span><br><span class="line">  90%   1049</span><br><span class="line">  95%   1063</span><br><span class="line">  98%   1070</span><br><span class="line">  99%   1071</span><br><span class="line"> 100%   1079 (longest request)</span><br></pre></td></tr></table></figure>
<p>Yay! Your app is now serving about 20 requests per second, roughly 4 times more than it was with the synchronous hash generation. Additionally, the average latency is down from the 4 seconds before to just over 1 second.</p>
<p>Hopefully, through the performance investigation of this (admittedly contrived) example, you’ve seen how the V8 tick processor can help you gain a better understanding of the performance of your Node.js applications.</p>
<p>原文：<a href="https://nodejs.org/en/docs/guides/simple-profiling/" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/simple-profiling/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-05T14:16:53.000Z"><a href="/2016/04/05/Node.js_错误处理和调试/Node出现uncaughtException之后的优雅退出方案/">2016-04-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/05/Node.js_错误处理和调试/Node出现uncaughtException之后的优雅退出方案/">Node出现uncaughtException之后的优雅退出方案</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Node 的异步特性是它最大的魅力，但是在带来便利的同时也带来了不少麻烦和坑，错误捕获就是一个。由于 Node 的异步特性，导致我们无法使用 try/catch 来捕获回调函数中的异常，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入 try/catch'</span>);</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'fs'</span>).stat(<span class="string">'SOME_FILE_DOES_NOT_EXIST'</span>, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readCallback</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err; <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 这里捕获不到 readCallback 函数中抛出的异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'离开 try/catch'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入 <span class="keyword">try</span>/<span class="keyword">catch</span></span><br><span class="line">离开 <span class="keyword">try</span>/<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">test.js:<span class="number">7</span></span><br><span class="line">            <span class="keyword">throw</span> err; <span class="comment">// 抛出异常</span></span><br><span class="line">                  ^</span><br><span class="line"><span class="built_in">Error</span>: ENOENT, stat <span class="string">'SOME_FILE_DOES_NOT_EXIST'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中由于 <code>fs.stat</code> 去查询一个不存在的文件的状态，导致 <code>readCallback</code> 抛出了一个异常。由于 <code>fs.read</code> 的异步特性，<code>readCallback</code> 函数的调用发生在 <code>try/catch</code> 块结束之后，所以该异常不会被 try/catch 捕获。之后 Node 会触发 <code>uncaughtException</code> 事件，如果这个事件依然没有得到响应，整个进程(<code>process</code>)就会 crash。</p>
<p>程序员永远无法保证代码中不出现 <code>uncaughtException</code>，即便是自己代码写的足够小心，也不能保证用的第三方模块没有 bug，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="built_in">require</span>(<span class="string">'deserialize'</span>); </span><br><span class="line"><span class="comment">// 假设 deserialize 是一个带有 bug 的第三方模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app 是一个 express 服务对象</span></span><br><span class="line">app.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    mysql.query(<span class="string">'SELECT * FROM user WHERE id=1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> config = deserialize(user.config); </span><br><span class="line"><span class="comment">// 假如这里触发了 deserialize 的 bug</span></span><br><span class="line">        res.send(config);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果不幸触发了 <code>deserialize</code> 模块的 bug，这里就会抛出一个异常，最终结果是整个服务 crash。</p>
<p>当这种情况发生在 Web 服务上时结果是灾难性的。<code>uncaughtException</code> 错误会导致当前的所有的用户连接都被中断，甚至不能返回一个正常的 HTTP 错误码，用户只能等到浏览器超时才能看到一个 <code>no data received</code> 错误。</p>
<p>这是一种非常野蛮粗暴的异常处理机制，任何线上服务都不应该因为 <code>uncaughtException</code> 导致服务器崩溃。一个友好的错误处理机制应该满足三个条件:</p>
<ol>
<li>对于引发异常的用户，返回 500 页面</li>
<li>其他用户不受影响，可以正常访问</li>
<li>不影响整个进程的正常运行</li>
</ol>
<p>很遗憾的是，保证 <code>uncaughtException</code> 不影响整个进程的健康运转是不可能的。当 Node 抛出 <code>uncaughtException</code> 异常时就会丢失当前环境的堆栈，导致 Node 不能正常进行内存回收。也就是说，每一次 <code>uncaughtException</code> 都有可能导致内存泄露。</p>
<p>既然如此，退而求其次，我们可以在满足前两个条件的情况下退出进程以便重启服务。</p>
<h2 id="用-domain-来捕获异步异常"><a href="#用-domain-来捕获异步异常" class="headerlink" title="用 domain 来捕获异步异常"></a>用 domain 来捕获异步异常</h2><p>普遍的思路是，如果可以通过某种方式来捕获回调函数中的异常，那么就不会有 <code>uncaughtException</code> 错误导致的崩溃。为了解决这个问题，Node 0.8 之后的版本新增了 <code>domain</code> 模块，它可以用来捕获回调函数中抛出的异常。</p>
<p><code>domain</code> 主要的 API 有 <code>domain.run</code> 和 <code>error</code> 事件。简单的说，通过 <code>domain.run</code> 执行的函数中引发的异常都可以通过 <code>domain</code> 的 <code>error</code> 事件捕获，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"><span class="keyword">var</span> d = domain.create();</span><br><span class="line">d.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async error'</span>); <span class="comment">// 抛出一个异步异常</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch err:'</span>, err); <span class="comment">// 这里可以捕获异步异常</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <code>domain</code> 模块，以及 JavaScript 的词法作用域特性，可以很轻易的为引发异常的用户返回 500 页面。以 express 为例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqDomain = domain.create();</span><br><span class="line">    reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 下面抛出的异常在这里被捕获</span></span><br><span class="line">        res.send(<span class="number">500</span>, err.stack); <span class="comment">// 成功给用户返回了 500</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    reqDomain.run(next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async exception'</span>); <span class="comment">// 抛出一个异步异常</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码将 domain 作为一个中间件来使用，保证之后 express 所有的中间件都在 <code>domain.run</code>函数内部执行。这些中间件内的异常都可以通过 <code>error</code> 事件来捕获。</p>
<p>尽管借助于闭包，我们可以正常的给用户返回 500 错误，但是 <code>domain</code> 捕获到错误时依然会丢失堆栈信息，此时已经无法保证程序的健康运行，必须退出。Node http server 提供了 <code>close</code> 方法，该方法在调用时会停止 server 接收新的请求，但不会断开当前已经建立的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制退出机制</span></span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref(); <span class="comment">// 非常重要</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动退出机制，停止接收新链接，等待当前已建立连接的关闭</span></span><br><span class="line">        server.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 此时所有连接均已关闭，此时 Node 会自动退出，不需要再调用 </span></span><br><span class="line">process.exit(<span class="number">1</span>) 来结束进程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子来自 Node 的文档。其中有几个关键点：</p>
<ul>
<li>Node 有个非常好的特性，所有连接都被释放后进程会自动结束，所以不需要再 <code>server.close</code> 方法的回调函数中退出进程</li>
<li>强制退出机制: 因为用户连接有可能因为某些原因无法释放，在这种情况下应该强制退出整个进程。</li>
<li><code>killTimer.unref()</code>: 如果不使用 <code>unref</code> 方法，那么即使 server 的所有连接都关闭，Node 也会保持运行直到 <code>killTimer</code> 的回调函数被调用。<code>unref</code> 可以创建一个”不保持程序运行”的计时器。</li>
<li>处理异常时要小心的把异常处理逻辑用 try/catch 包住，避免处理异常时抛出新的异常</li>
</ul>
<p>通过 <code>domain</code> 似乎就已经解决了我们的需求: 给触发异常的用户一个 500，停止接收新请求，提供正常的服务给已经建立连接的用户，直到所有请求都已结束，退出进程。但是，理想很丰满，现实很骨感，<code>domain</code> 有个最大的问题，它<a href="http://cnodejs.org/topic/516b64596d38277306407936" target="_blank" rel="noopener">不能捕获所有的异步异常</a>！。也就是说，即使用了 <code>domain</code>，程序依然有因为 <code>uncaughtException</code> crash 的可能。</p>
<p>所幸的是我们可以监听 <code>uncaughtException</code> 事件。</p>
<h2 id="uncaughtException-事件"><a href="#uncaughtException-事件" class="headerlink" title="uncaughtException 事件"></a><code>uncaughtException</code> 事件</h2><p><code>uncaughtException</code> 是一个非常古老的事件。当 Node 发现一个未捕获的异常时，会触发这个事件。并且如果这个事件存在回调函数，Node 就不会强制结束进程。这个特性，可以用来弥补 <code>domain</code> 的不足:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>uncaughtException</code> 事件的缺点在于无法为抛出异常的用户请求返回一个 500 错误，这是由于 <code>uncaughtException</code> 丢失了当前环境的上下文，比如下面的例子就是它做不到的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async error'</span>); </span><br><span class="line"><span class="comment">// uncaughtException, 导致 req 的引用丢失</span></span><br><span class="line">        res.send(<span class="number">200</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="number">500</span>); <span class="comment">// 做不到，拿不到当前请求的 res 对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终出错的用户只能等待浏览器超时。</p>
<h2 id="domain-uncaughtException"><a href="#domain-uncaughtException" class="headerlink" title="domain + uncaughtException"></a><code>domain</code> + <code>uncaughtException</code></h2><p>所以，我们可以结合两种异常捕获机制，用 <code>domain</code> 来捕获大部分的异常，并且提供友好的 500 页面以及优雅退出。对于剩下的异常，通过 <code>uncaughtException</code> 事件来避免服务器直接 crash。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).create(app);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">'domain'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 domain 来捕获大部分异常</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqDomain = domain.create();</span><br><span class="line">    reqDomain.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                process.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;, <span class="number">30000</span>);</span><br><span class="line">            killTimer.unref();</span><br><span class="line"></span><br><span class="line">            server.close();</span><br><span class="line"></span><br><span class="line">            res.send(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    reqDomain.run(next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncaughtException 避免程序崩溃</span></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="其他的一些问题"><a href="#其他的一些问题" class="headerlink" title="其他的一些问题"></a>其他的一些问题</h2><h3 id="express-中异常的处理"><a href="#express-中异常的处理" class="headerlink" title="express 中异常的处理"></a><code>express</code> 中异常的处理</h3><p>使用 <code>express</code> 时记住一定不要在 controller 的异步回调中抛出异常，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 总是接收 next 参数</span></span><br><span class="line">    mysql.query(<span class="string">'SELECT * FROM users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 不要这样做</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应该将 err 传递给 errorHandler 处理</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 带有四个参数的 middleware 专门用来处理异常</span></span><br><span class="line">    res.render(<span class="number">500</span>, err.stack);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="和-cluster-一起使用"><a href="#和-cluster-一起使用" class="headerlink" title="和 cluster 一起使用"></a>和 cluster 一起使用</h3><p>cluster 是 node 自带的负载均衡模块，使用 cluster 模块可以方便的建立起一套 master/slave 服务。在使用 cluster 模块时，需要注意不仅需要调用 <code>server.close()</code> 来关闭连接，同时还需要调用 <code>cluster.worker.disconnect()</code> 通知 master 进程已停止服务:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> killTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">30000</span>);</span><br><span class="line">        killTimer.unref();</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cluster.worker) &#123;</span><br><span class="line">            cluster.worker.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error when exit'</span>, e.stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="不要通过-uncaughtException-来忽略错误"><a href="#不要通过-uncaughtException-来忽略错误" class="headerlink" title="不要通过 uncaughtException 来忽略错误"></a>不要通过 <code>uncaughtException</code> 来忽略错误</h3><p>当 <code>uncaughtException</code> 事件有一个以上的 <code>listener</code> 时，会阻止 Node 结束进程。因此就有一个广泛流传的做法是监听 <code>process</code> 的 <code>uncaughtException</code> 事件来阻止进程退出，这种做法有内存泄露的风险，所以千万不要这么做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123; // 不要这么做</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="pm2-对于-uncaughtException-的额外处理"><a href="#pm2-对于-uncaughtException-的额外处理" class="headerlink" title="pm2 对于 uncaughtException 的额外处理"></a>pm2 对于 <code>uncaughtException</code> 的额外处理</h3><p>如果你在用 pm2 0.7.1 之前的版本，那么要当心。pm2 有一个 bug，如果进程抛出了 <code>uncaughtException</code>，无论代码中是否捕获了这个事件，进程都会被 pm2 杀死。0.7.2 之后的 pm2 解决了这个问题。</p>
<h3 id="要小心-worker-disconnect"><a href="#要小心-worker-disconnect" class="headerlink" title="要小心 worker.disconnect()"></a>要小心 worker.disconnect()</h3><p>如果你在退出进程时希望可以发消息给监控服务器，并且还使用了 cluster，那么这个时候要特别小心，比如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> udpLog = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    udpLog.send(<span class="string">'process '</span> + process.pid + <span class="string">' down'</span>, </span><br><span class="line">    <span class="comment">/* ... 一些发送 udp 消息的参数 ...*/</span>);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line">    cluster.worker.disconnect();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这份代码就不能正常的将消息发送出去。因为 <code>udpLog.send</code> 是一个异步方法，真正发消息的操作发生在下一个事件循环中。而在真正的发送消息之前 <code>cluster.worker.disconnect()</code> 就已经执行了。<code>worker.disconnect()</code> 会在当前进程没有任何链接之后，杀掉整个进程，这种情况有可能发生在发送 log 数据之前，导致 log 数据发不出去。</p>
<p>一个解决方法是在 <code>udpLog.send</code> 方法发送完数据后再调用 <code>worker.disconnect</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> udpLog = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    udpLog.send(<span class="string">'process '</span> + process.pid + <span class="string">' down'</span>, <span class="comment">/* ... </span></span><br><span class="line"><span class="comment">一些发送 udp 消息的参数 ...*/</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cluster.worker.disconnect();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证 worker.disconnect 不会拖太久..</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cluster.worker.disconnect();</span><br><span class="line">    &#125;, <span class="number">100</span>).unref();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>说了这么多，结论是，目前为止(Node 0.10.25)，依然没有一个完美的方案来解决任意异常的优雅退出问题。用 <code>domain</code> 来捕获大部分异常，并且通过 <code>uncaughtException</code> 避免程序 crash 是目前来说最理想的方案。回调异常的退出问题在遇到 cluster 以后会更加复杂，特别是对于连接关闭的处理要格外小心。</p>
<p>原文：<a href="http://www.infoq.com/cn/articles/quit-scheme-of-node-uncaughtexception-emergence" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/quit-scheme-of-node-uncaughtexception-emergence</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-IO/">Node.js_IO</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-事件/">Node.js_事件</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-入门/">Node.js_入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js-异步编程/">Node.js_异步编程</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-模块/">Node.js_模块</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-测试/">Node.js_测试</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-进程/">Node.js_进程</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-错误处理和调试/">Node.js_错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/安全/">安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>