<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 10 页 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-24T09:45:23.000Z"><a href="/2014/06/24/Git/Git(5)分支管理/">2014-06-24</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/24/Git/Git(5)分支管理/">五.分支管理</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-分支管理图文详解一"><a href="#1-分支管理图文详解一" class="headerlink" title="1.分支管理图文详解一"></a>1.分支管理图文详解一</h3><hr>
<p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>　　一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br>　　<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbranch01.png" alt=""></p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长，当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbranch02.png" alt=""></p>
<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<h3 id="2-分支管理图文详解二"><a href="#2-分支管理图文详解二" class="headerlink" title="2.分支管理图文详解二"></a>2.分支管理图文详解二</h3><hr>
<p>接着分支管理图文详解一，现在对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbranch03.png" alt=""></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbranch04.png" alt=""></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkbranch05.png" alt=""></p>
<h3 id="3-创建分支"><a href="#3-创建分支" class="headerlink" title="3.创建分支"></a>3.创建分支</h3><hr>
<p>首先，我们创建dev分支，然后切换到dev分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<p>$ git branch dev<br>$ git checkout dev<br>Switched to branch ‘dev’</p>
<p>然后，用git branch命令查看当前分支：</p>
<p>$ git branch<br>*dev<br>  master</p>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>
<p>Creating a new branch is quick.</p>
<p>然后提交：</p>
<p>$ git add readme.txt<br>$ git commit -m “branch test”<br>[dev fec145a] branch test<br>1 file changed, 1 insertion(+)</p>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>
<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkdev.png" alt=""></p>
<h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4.合并分支"></a>4.合并分支</h3><hr>
<p>我们把前面dev分支的工作成果合并到master分支上：</p>
<p>$ git merge dev<br>Updating d17efd8..fec145a<br>Fast-forward<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)</p>
<p>　　git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>　　注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>　　当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。</p>
<h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5.删除分支"></a>5.删除分支</h3><hr>
<p>合并完成后，就可以放心地删除dev分支了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 5659891).</span><br></pre></td></tr></table></figure></p>
<p>删除后，查看branch，就只剩下master分支了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
<p>前面所讲知识：汇总下这些使用命令：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name></name></p>
<p>创建+切换分支：git checkout -b <name></name></p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>删除分支：git branch -d <name></name></p>
<h3 id="6-产生冲突"><a href="#6-产生冲突" class="headerlink" title="6.产生冲突"></a>6.产生冲突</h3><hr>
<p>当我们进行合并分支往往会产生冲突。</p>
<p>在准备新的feature1分支，继续我们的新分支开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br></pre></td></tr></table></figure></p>
<p>修改readme.txt最后一行，改为Creating a new branch is quick AND simple.</p>
<p>在feature1分支上提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br></pre></td></tr></table></figure></p>
<p>切换到master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br></pre></td></tr></table></figure></p>
<p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为Creating a new branch is quick &amp; simple.提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-解决冲突"><a href="#7-解决冲突" class="headerlink" title="7.解决冲突"></a>7.解决冲突</h3><hr>
<p>在上节中master分支和feature1分支各自都分别有新的提交，变成了这样：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkresolve01.png" alt=""></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，执行git merge feature1,在看readme.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p>
<p>我们把冲突的内容修改为Creating a new branch is quick and simple.，提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure></p>
<p>现在，master分支和feature1分支变成了下图所示：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkresolve02.png" alt=""></p>
<p>用带参数的git log也可以看到分支的合并情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></p>
<p>最后，删除feature1分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1.</span><br></pre></td></tr></table></figure></p>
<p>冲突解决，最后，删除feature1分支 git branch -d feature1。当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
<h3 id="8-Bug分支"><a href="#8-Bug分支" class="headerlink" title="8.Bug分支"></a>8.Bug分支</h3><hr>
<p>如果你有一个bug任务，你想创建一个分支issue-101来修复它，但是你当前正在dev上进行的工作还没有完成而不能提交，bug需要现在修复，所以现在你需要暂停dev上工作，Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：$ git stash。</p>
<p>　　假定需要在master分支上修复，就从master创建临时分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &apos;issue-101&apos;</span><br></pre></td></tr></table></figure></p>
<p>　　现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br></pre></td></tr></table></figure></p>
<p>　　修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">...</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">...</span><br><span class="line">$ git branch -d issue-101</span><br><span class="line">Deleted branch issue-101 (...).</span><br></pre></td></tr></table></figure></p>
<p>　　Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<ul>
<li>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</li>
<li>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</li>
</ul>
<h3 id="9-Feature分支"><a href="#9-Feature分支" class="headerlink" title="9.Feature分支"></a>9.Feature分支</h3><hr>
<p>　在软件开发中，总会添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>　　现在新功能开发代号为Vulcan:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure></p>
<p>　　开发完毕，添加并提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br></pre></td></tr></table></figure></p>
<p>切回dev，准备合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure></p>
<p>　　一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>　　由于种种原因，此功能又不需要了，现在这个分支需要就地销毁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</span><br></pre></td></tr></table></figure></p>
<p>　　销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p>
<p>　　现在我们强行删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 756d4af).</span><br></pre></td></tr></table></figure></p>
<p>　　注意：开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p>
<h3 id="10-推送分支"><a href="#10-推送分支" class="headerlink" title="10.推送分支"></a>10.推送分支</h3><hr>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。</p>
<p>　　要查看远程库的信息，用git remote<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>　　或者，用git remote -v显示更详细的信息：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></p>
<p>推送分支<br>　　推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>　　如果要推送其他分支，比如dev，就改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。
　　<h3 id="11-多人协助"><a href="#11-多人协助" class="headerlink" title="11.多人协助"></a>11.多人协助</h3></li>
</ul>
<hr>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。当你的同事也克隆一份此项目从远程库，默认情况下，只能看到本地的master分支。现在，你的同事要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>
<p>　　现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程，并且已经向origin/dev分支推送了他的提交，这时你也对同样的文件作了修改，并试图推送，推送失败，因为你的同事的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送，git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。</p>
<p>　　这回git pull成功，但是是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;merge &amp; fix hello.py&quot;</span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p>
<p>　　因此，多人协作的工作模式通常是这样：</p>
<ul>
<li>首先，可以试图用git push origin branch-name推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>　　如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-23T09:45:23.000Z"><a href="/2014/06/23/Git/Git(4)远程仓库/">2014-06-23</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/23/Git/Git(4)远程仓库/">四.远程仓库</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-远程仓库简介"><a href="#1-远程仓库简介" class="headerlink" title="1.远程仓库简介"></a>1.远程仓库简介</h3><hr>
<p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>　　开始介绍Git的远程仓库功能。我们现在借用GitHub神奇的网站，这个网站就是提供Git仓库托管服务的，所以只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>　　由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>　　第1步：创建SSH Key。在当前目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“<br>　　你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>　　第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>　　然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br>　　<img src="http://7xq1il.com1.z0.glb.clouddn.com/mkgitsshkey.png" alt=""></p>
<h3 id="2-GitHub创建新仓库"><a href="#2-GitHub创建新仓库" class="headerlink" title="2.GitHub创建新仓库"></a>2.GitHub创建新仓库</h3><hr>
<p>GitHub创建一个Git仓库,并且本地仓库与此仓库进行远程同步，此仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p>
<p>　　首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br>　　<br>　　<img src="http://7xq1il.com1.z0.glb.clouddn.com/mkgithub1.png" alt=""><br>　　<br>　在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p>
<p>　　目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>　　现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:onlyone/learngit.git</span><br></pre></td></tr></table></figure></p>
<p>　　请千万注意，把上面的onlyone替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>　　添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>　　注意：要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git。　
　　</p>
<h3 id="3-本地库推送到远程库"><a href="#3-本地库推送到远程库" class="headerlink" title="3.本地库推送到远程库"></a>3.本地库推送到远程库</h3><hr>
<p>本地库的所有内容推送到远程库上：</p>
<p>$ git push -u origin master<br>　　把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>　　由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>　　推送成功，github内容与当前目录中readme.txt一致：<br>　　<br>　　<img src="http://7xq1il.com1.z0.glb.clouddn.com/mkgithubremote.png" alt=""><br>　　<br>从现在起，只要本地作了提交，就可以通过命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>　　把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<p>　　注意：要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
　　</p>
<h3 id="4-SSH警告"><a href="#4-SSH警告" class="headerlink" title="4.SSH警告"></a>4.SSH警告</h3><hr>
<p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>　　这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>　　Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p>
<p>　　这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>　　如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p>
<h3 id="5-从远程库克隆"><a href="#5-从远程库克隆" class="headerlink" title="5.从远程库克隆"></a>5.从远程库克隆</h3><hr>
<p>从远程库克隆,就需要我们先创建远程库，在github创建一个新的gitskills仓库，我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：</p>
<p>　　现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line"> </span><br><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p>
<p>　　注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。</p>
<p>　　你也许还注意到，GitHub给出的地址不止一个，还可以用github.com/onlyone/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</p>
<p>　　注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p>
<p>　　Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-20T06:45:23.000Z"><a href="/2014/06/20/Git/Git(3)操作Git/">2014-06-20</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/20/Git/Git(3)操作Git/">三.操作Git</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-status命令与diff命令"><a href="#1-status命令与diff命令" class="headerlink" title="1.status命令与diff命令"></a>1.status命令与diff命令</h3><hr>
<p>前面我们已经成功地添加并提交了一个readme.txt文件，修改readme.txt如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Git is a distributed version control system. &quot; &gt; readme.txt</span><br><span class="line">echo &quot;Git is free software.&quot; &gt;&gt; readme.txt</span><br></pre></td></tr></table></figure></p>
<p>　　运行git status命令看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">...</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>　　git status命令可以让我们时刻掌握仓库当前的状态，上面显示，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>　　git diff这个命令看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">...</span><br><span class="line">-Git is version control system.                                             </span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software</span><br></pre></td></tr></table></figure></p>
<p>　　git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。</p>
<p>　　readme.txt作了什么修改后，再把它提交到仓库，提交修改和提交新文件是一样的两步，git add和git commit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;add distributed&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意</p>
<ul>
<li>要随时掌握工作区的状态，使用git status命令。</li>
<li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li>
</ul>
<h3 id="2-版本回退"><a href="#2-版本回退" class="headerlink" title="2.版本回退"></a>2.版本回退</h3><hr>
<p>现在，再练习一次，修改readme.txt文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Git is a distributed version control system.&quot; &gt; readme.txt</span><br><span class="line">echo &quot;Git is free software distributed under the GPL.&quot; &gt;&gt; readme.txt</span><br></pre></td></tr></table></figure></p>
<p>　　我们再次提交一次readme.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br></pre></td></tr></table></figure></p>
<p>　　我们现在已经提交多次文件，想看看有那些？版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Date:   Tue Oct 25 15:11:49 2015 +0000</span><br><span class="line">    append GPL</span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8cd576c5ee85</span><br><span class="line">Date:   Tue Oct 25 14:53:12 2015 +0000</span><br><span class="line">    add distributed</span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Date:   Mon Oct 24 17:51:55 2015 +0000</span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>　　git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。commit 36281**2e1e0是commit id（版本号）。如果嫌输出信息太多，可以使用$ git log –pretty=oneline，此时你看到的一大串类似3628164…882e1e0的是commit id（版本号）。</p>
<p>　　每提交一个新版本，实际上Git就会把它们自动串成一条时间线。现在准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p>
<p>　　首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>　　现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ea34578 add distributed</span><br></pre></td></tr></table></figure></p>
<h3 id="3-重新恢复到新版本"><a href="#3-重新恢复到新版本" class="headerlink" title="3.重新恢复到新版本"></a>3.重新恢复到新版本</h3><hr>
<p>接着上节版本回退，还可以继续回退到上一个版本wrote a readme file，不过我们现在看看版本库的状态git log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure></p>
<p>　　最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>　　只要之前的命令行结果还在，就可以找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3628164</span><br><span class="line">HEAD is now at 3628164 append GPL</span><br></pre></td></tr></table></figure></p>
<p>　　版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>　　可以查看readme.txt的内容$ cat readme.txt.</p>
<p>　　Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkback01.jpg" alt=""><br>改为指向add distributed：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkback02.jpg" alt=""></p>
<h3 id="4-git-reflog命令"><a href="#4-git-reflog命令" class="headerlink" title="4.git reflog命令"></a>4.git reflog命令</h3><hr>
<p>现在，你回退到了某个版本，当想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>　　在Git中可以放心下。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p>
<p>　　这样可以看到，第二行显示append GPL的commit id是3628164，这样我们就可以重新找到了。</p>
<p>　　注意，我们从这两节中可以了解到：</p>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。<br>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
<h3 id="5-工作区"><a href="#5-工作区" class="headerlink" title="5.工作区"></a>5.工作区</h3><hr>
<p><strong>工作区</strong>：就是你在电脑里能看到的目录,learngit文件夹就是一个工作区，比如我们环境中当前的目录。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkworkArea.png" alt=""></p>
<h3 id="6-暂存区"><a href="#6-暂存区" class="headerlink" title="6.暂存区"></a>6.暂存区</h3><hr>
<p><strong>版本库:</strong>工作区有一个隐藏目录.git 这个不算工作区，而是Git的版本库。</p>
<p><strong>暂存区:</strong>英文叫stage,或index。一般存放在git 目录下的index文件(.git/index)中，所以我们把暂存区时也叫作索引(index).</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkstage.jpg" alt=""></p>
<h3 id="7-暂存区实践"><a href="#7-暂存区实践" class="headerlink" title="7.暂存区实践"></a>7.暂存区实践</h3><hr>
<p>现在我们对readme.txt做个修改，比如追加一行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Git has a mutable index called stage.&quot; &gt;&gt; readme.txt</span><br></pre></td></tr></table></figure></p>
<p>然后，在工作区新增一个LICENSE文本文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;LICENSE is a new file.&quot; &gt; LICENSE</span><br></pre></td></tr></table></figure></p>
<p>用git status查看一下状态，Git显示结果，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下，通过图可以理解为</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkstorageArea01.jpg" alt=""><br>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br></pre></td></tr></table></figure></p>
<p>一旦提交后，如果你又没有对工作区做任何修改，用git status查看下，没有任何内容，现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkstorageArea02.jpg" alt=""></p>
<h3 id="8-管理修改"><a href="#8-管理修改" class="headerlink" title="8.管理修改"></a>8.管理修改</h3><hr>
<p>Git与其他版本控制系统相比，Git跟踪并管理的是修改，而非文件。</p>
<p>　　为什么说Git管理的是修改，而不是文件。接下来做测试，我们对readme.txt修改，追加一行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Git tracks changes.&quot; &gt;&gt; readme.txt</span><br></pre></td></tr></table></figure></p>
<p>　　然后通过git add添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<p>　　接下来，我们再次修改readme.txt内容，把最后一行内容修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>　　git commit提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master d4f25b6] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>　　通过git status查看每次操作的状态，可以看出第二次修改 -&gt; git commit，没有被提交。</p>
<p>　　Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>
<h3 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="9.撤销修改"></a>9.撤销修改</h3><hr>
<p>如果你在readme.txt中加入了一行文件，又感觉不好，你可以删除新加的，恢复到原来的。</p>
<p>Git会告诉你，git checkout – file可以丢弃工作区的修改：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p>
<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</li>
</ul>
<p>现在，看看readme.txt的文件内容：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure></p>
<p>现在来看几种情况，如何撤销修改</p>
<p>1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：</p>
<p>第一步用命令git reset HEAD file，就回到了1；<br>第二步按1操作。<br>3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h3 id="10-删除文件"><a href="#10-删除文件" class="headerlink" title="10.删除文件"></a>10.删除文件</h3><hr>
<p>在Git中，删除也是一个修改操作，先添加一个新文件test.txt到Git并且提交：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master 94cdc44] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure></p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">...</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &apos;test.txt&apos;</span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure></p>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></p>
<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>　　命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-18T07:45:23.000Z"><a href="/2014/06/18/Git/Git(2)创建版本库/">2014-06-18</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/18/Git/Git(2)创建版本库/">二.创建版本库</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是版本库"><a href="#1-什么是版本库" class="headerlink" title="1.什么是版本库"></a>1.什么是版本库</h3><hr>
<p>　版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/home/shouliang/learngit</span><br></pre></td></tr></table></figure></p>
<p>pwd命令用于显示当前目录。在环境中这个仓库位于/home/shouliang/learngit。</p>
<p>通过git init命令把这个目录变成Git可以管理的仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/shouliang/learngit/.git/</span><br></pre></td></tr></table></figure></p>
<p>　　瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>　　如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<h3 id="2-添加文件"><a href="#2-添加文件" class="headerlink" title="2.添加文件"></a>2.添加文件</h3><hr>
<p>我们了解下版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>为了简明起见，我们创建一个readme.txt作为练习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Git is a version control system.&quot; &gt; readme.txt</span><br><span class="line">// 输入这句话保存到创建的readme.txt文件中</span><br><span class="line">echo &quot; Git is free software.&quot; &gt;&gt; readme.txt</span><br><span class="line">// 输入此内容追加到readme.txt中</span><br></pre></td></tr></table></figure></p>
<p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>用命令git add告诉Git，把文件添加到仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p>
<p>git add 实际上是个脚本命令，没有任何显示，说明添加成功。</p>
<h3 id="3-提交文件"><a href="#3-提交文件" class="headerlink" title="3.提交文件"></a>3.提交文件</h3><hr>
<p>用命令git commit告诉Git，把文件提交到仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p>
<p>　　简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>　　git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>　　为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><hr>
<p>此节知识点我们所学习的内容：</p>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ul>
<li>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li>
<li>第二步，使用命令git commit，完成。　　</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-15T06:45:23.000Z"><a href="/2014/06/15/Git/Git(1)简介/">2014-06-15</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/15/Git/Git(1)简介/">一.简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-Git的诞生"><a href="#1-Git的诞生" class="headerlink" title="1.Git的诞生"></a>1.Git的诞生</h3><hr>
<p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>　　Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>　　到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linux Torvalds）基于使用 BitKcheper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p>
<p>速度<br>简单的设计<br>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）<br>完全分布式<br>　　有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>　　自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p>
<p>　　Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<h3 id="2-Git介绍"><a href="#2-Git介绍" class="headerlink" title="2.Git介绍"></a>2.Git介绍</h3><hr>
<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>　　Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>　　最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面的样子了：<br>　　<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkold_version.jpg" alt=""></p>
<h3 id="3-Git特点"><a href="#3-Git特点" class="headerlink" title="3.Git特点"></a>3.Git特点</h3><hr>
<p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p>
<ul>
<li>直接记录快照，而非差异比较 ： Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。</li>
<li>近乎所有操作都是本地执行 ：在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。</li>
<li>时刻保持数据完整性 ：在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</li>
<li>多数操作仅添加数据 ：常用的 Git 操作大多仅仅是把数据添加到数据库。<br>开发流程示意图：</li>
</ul>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkdevelop.jpg" alt=""></p>
<h3 id="4-集中式"><a href="#4-集中式" class="headerlink" title="4.集中式"></a>4.集中式</h3><hr>
<p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p>
<p>　　集中式版本控制系统，版本库是集中存放在中央服务器的，一起工作的人需要用自己的电脑从服务器上同步更新或上传自己的修改。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkfos.jpg" alt="">　　</p>
<p>但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。</p>
<p>　　而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。　　</p>
<h3 id="5-分布式"><a href="#5-分布式" class="headerlink" title="5.分布式"></a>5.分布式</h3><hr>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？</p>
<p>　分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网就可以工作。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你和同事在各自电脑修改相同文件，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>　　分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库。大家之间可以相互复制。</p>
<p>　　分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="http://7xq1il.com1.z0.glb.clouddn.com/mkdis.jpg" alt=""></p>
<h3 id="6-Git安装"><a href="#6-Git安装" class="headerlink" title="6.Git安装"></a>6.Git安装</h3><hr>
<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>　　在Linux上安装Git</p>
<p>　　首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br></pre></td></tr></table></figure></p>
<p>　　像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>　　如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。如果想查看是否安装成功，通过git –version。</p>
<p>　　如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-13T11:45:23.000Z"><a href="/2014/06/13/Node.js_测试/Mocha(4)为项目开发一个BDD测试/">2014-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/13/Node.js_测试/Mocha(4)为项目开发一个BDD测试/">四.为项目开发一个BDD测试</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-辅助模块"><a href="#1-辅助模块" class="headerlink" title="1.辅助模块"></a>1.辅助模块</h3><hr>
<p>我们进行单元测试，一般都需要组合几个工具来来使用的。下面我们开始介绍：</p>
<p>chai断言库<br>chai 断言库支持BDD 的 expect/should 语法风格 和TDD的 assert 语法风格。</p>
<p>superagent<br>在用Node做Web开发的时候，模拟HTTP请求时必不可少的。这也就引出了superagent这个模块，它是一个模拟http请求的库。它作用是简化发起请求的库。</p>
<p>项目的package.json 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mocha-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node app.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;superagent&quot;: &quot;1.4.0&quot;,</span><br><span class="line">    &quot;chai&quot;: &quot;3.4.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-项目描述"><a href="#2-项目描述" class="headerlink" title="2.项目描述"></a>2.项目描述</h3><hr>
<p>首先我们创建一个app.js文件。内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;),</span><br><span class="line">    PORT = 3000; </span><br><span class="line">function onRequest(request, response) &#123;</span><br><span class="line">    console.log(&quot;Request received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></p>
<p>描述：为了让项目尽可能的简单，我们没有用到任何的框架。只是创建了一个http服务器监听了3000端口。</p>
<h3 id="3-项目重构"><a href="#3-项目重构" class="headerlink" title="3.项目重构"></a>3.项目重构</h3><hr>
<p>我们的app.js需要最外部暴露两个方法。所以要对我们右边的项目进行修改。</p>
<p>需要修改的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></p>
<p>重构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(onRequest);</span><br><span class="line">var boot = function () &#123;</span><br><span class="line">    server.listen(PORT, function () &#123;</span><br><span class="line">        console.info(&apos;Express server listening on port &apos; + PORT);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">var shutdown = function () &#123;</span><br><span class="line">    server.close();</span><br><span class="line">&#125;;</span><br><span class="line">if (require.main === module) &#123;</span><br><span class="line">    boot();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.info(&apos;Running app as a module&apos;);</span><br><span class="line">    exports.boot = boot;</span><br><span class="line">    exports.shutdown = shutdown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重构描述：现在我们把启动服务和关闭服务分别进行了封装并且对外进行了暴露。</p>
<h3 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4.测试用例"></a>4.测试用例</h3><hr>
<p>现在，我们创建一个名字为 tests 的测试文件夹，并创建一个index.js的文件。测试用例前需要启动服务器，结束后关闭服务。这个时候就用到了前面暴露的 boot() 和 shutdown() 方法。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var boot = require(&apos;../app&apos;).boot,</span><br><span class="line">    shutdown = require(&apos;../app&apos;).shutdown,</span><br><span class="line">    request = require(&apos;superagent&apos;),</span><br><span class="line">    expect = require(&apos;chai&apos;).expect;</span><br><span class="line"> </span><br><span class="line">describe(&apos;server&apos;, function () &#123;</span><br><span class="line">    before(function () &#123;</span><br><span class="line">        boot();</span><br><span class="line">    &#125;);</span><br><span class="line">    describe(&apos;index&apos;, function () &#123;</span><br><span class="line">        it(&apos;should respond to GET&apos;, function (done) &#123;</span><br><span class="line">            request</span><br><span class="line">                .get(&apos;http://localhost:3000&apos;)</span><br><span class="line">                .end(function (err, res) &#123;</span><br><span class="line">                    expect(res.status).to.equal(200);</span><br><span class="line">                    done();</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    after(function () &#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行命令：mocha tests</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-10T08:45:23.000Z"><a href="/2014/06/10/Node.js_测试/Mocha(3)hook机制和测试技巧/">2014-06-10</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/10/Node.js_测试/Mocha(3)hook机制和测试技巧/">三.hook机制和测试技巧</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-hook机制"><a href="#1-hook机制" class="headerlink" title="1.hook机制"></a>1.hook机制</h3><hr>
<p>hook 就是在测试流程的不同时段触发，比如在整个测试流程之前，或在每个独立测试之前等。</p>
<p>hook也可以理解为是一些逻辑，通常表现为一个函数或者一些声明，当特定的事件触发时 hook 才执行。</p>
<p>提供方法有：before()、beforeEach() after() 和 afterEach()。</p>
<p><strong>方法解析：</strong></p>
<ul>
<li>before()：所有测试用例的统一前置动作</li>
<li>after()：所有测试用例的统一后置动作</li>
<li>beforeEach()：每个测试用例的前置动作</li>
<li>afterEach()：每个测试用例的后置动作<br>用法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;hooks&apos;, function() &#123;</span><br><span class="line">  before(function() &#123;</span><br><span class="line">    //在执行本区块的所有测试之前执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  after(function() &#123;</span><br><span class="line">    //在执行本区块的所有测试之后执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    //在执行本区块的每个测试之前都执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  afterEach(function() &#123;</span><br><span class="line">    //在执行本区块的每个测试之后都执行</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  //测试用例</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-描述hook"><a href="#2-描述hook" class="headerlink" title="2.描述hook"></a>2.描述hook</h3><hr>
<p>所有的 hook 都可以加上描述，这样可以更好地定位到测试用例中的错误。如果 hook 函数指定了名称，会在没有描述时使用函数名，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(function() &#123;</span><br><span class="line">  //beforeEach hook</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">beforeEach(function needFun() &#123;</span><br><span class="line">  //beforeEach: namedFun</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">beforeEach(&apos;some description&apos;, function() &#123;</span><br><span class="line">  //beforeEach:some description</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>补充：上述示例中 注释的内容就是对 hook 的描述。</p>
<h3 id="3-测试占位"><a href="#3-测试占位" class="headerlink" title="3.测试占位"></a>3.测试占位</h3><hr>
<p>测试用例占位只要添加一个没有回调的 it() 方法即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"> </span><br><span class="line">describe(&apos;Array&apos;, function() &#123;</span><br><span class="line"> </span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">    //同步测试</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function() &#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(5));</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(0));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  describe(&apos;Array&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">      //下面是一个挂起的测试</span><br><span class="line">      it(&apos;当值不存在时应该返回 -1&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-仅执行指定测试"><a href="#4-仅执行指定测试" class="headerlink" title="4.仅执行指定测试"></a>4.仅执行指定测试</h3><hr>
<p>仅执行指定测试的特性可以让你通过添加 .only() 来指定唯一要执行的测试套件或测试用例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe.only(&apos;#indexOf()&apos;, function()&#123;    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>或一个指定的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it.only(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;) </span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>PS:注意只能出现一个 .only()</p>
<h3 id="5-忽略指定测试"><a href="#5-忽略指定测试" class="headerlink" title="5.忽略指定测试"></a>5.忽略指定测试</h3><hr>
<p>该特性和 .only() 非常相似，通过添加 .skip() 你可以告诉 Mocha 忽略的测试套件或者测试用例（可以有多个）。该操作使得这些操作处于挂起的状态，这比使用注释来的要好，因为你可能会忘记把注释给取消掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe.skip(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>或一个指定的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it.skip(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="6-动态生成测试"><a href="#6-动态生成测试" class="headerlink" title="6.动态生成测试"></a>6.动态生成测试</h3><hr>
<p>由于mocha 可以使用 function.prototype.call 和function 表达式定义测试套件和测试用例，所以可以动态生成测试用例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"> </span><br><span class="line">function add() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments).reduce(function(prev, curr) &#123;</span><br><span class="line">    return prev + curr;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">describe(&apos;add()&apos;, function() &#123;</span><br><span class="line">  var tests = [</span><br><span class="line">    &#123;args: [1, 2],       expected: 3&#125;,</span><br><span class="line">    &#123;args: [1, 2, 3],    expected: 6&#125;,</span><br><span class="line">    &#123;args: [1, 2, 3, 4], expected: 10&#125;</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  tests.forEach(function(test) &#123;</span><br><span class="line">    it(&apos;correctly adds &apos; + test.args.length + &apos; args&apos;, function() &#123;</span><br><span class="line">      var res = add.apply(null, test.args);</span><br><span class="line">      assert.equal(res, test.expected);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-08T07:45:23.000Z"><a href="/2014/06/08/Node.js_测试/Mocha(2)mocha接口/">2014-06-08</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/08/Node.js_测试/Mocha(2)mocha接口/">二.mocha接口</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-BDD行为驱动开发"><a href="#1-BDD行为驱动开发" class="headerlink" title="1.BDD行为驱动开发"></a>1.BDD行为驱动开发</h3><hr>
<p>mocha “接口” 系统允许开发者选择自身喜爱的特定领域语言风格, mocha 提供 TDD（测试驱动开发）、BDD (行为驱动开发) 和 exports 风格的接口。</p>
<p>BDD是“行为驱动的开发”（Behavior-Driven Development）的简称，指的是写出优秀测试的最佳实践的总称。</p>
<p>BDD认为，不应该针对代码的实现细节写测试，而是要针对行为写测试。BDD测试的是行为，即软件应该怎样运行。</p>
<p>BDD接口提供以下方法：</p>
<ul>
<li>describe()：测试套件</li>
<li>it()：测试用例</li>
<li>before()：所有测试用例的统一前置动作</li>
<li>after()：所有测试用例的统一后置动作</li>
<li>beforeEach()：每个测试用例的前置动作</li>
<li>afterEach()：每个测试用例的后置动作<br>BDD的特征就是使用describe()和it() 这两个方法。</li>
</ul>
<p>before()、after()、beforeEach()和afterEach() 是为测试做辅助的作用域，它们合起来组成了hook的概念。</p>
<h3 id="2-方法解析"><a href="#2-方法解析" class="headerlink" title="2.方法解析"></a>2.方法解析</h3><hr>
<h4 id="descript"><a href="#descript" class="headerlink" title="descript()"></a>descript()</h4><p>describe()方法接收两个参数：第一个参数是一个字符串，表示测试套件的名字或标题，表示将要测试什么。第二个参数是一个函数，用来实现这个测试套件。</p>
<p>上述中引出了一个概念：测试套件。那什么是测试套件呢？</p>
<p>测试套件（test suite）指的是，一组针对软件规格的某个方面的测试用例。也可以看作，对软件的某个方面的描述（describe）。结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A suite&quot;, function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="it"><a href="#it" class="headerlink" title="it()"></a>it()</h4><p>要想理解it()，首先我们要知道什么是测试用例? 测试用例（test case）指的是，针对软件一个功能点的测试，是软件测试的最基本单位。一组相关的测试用例，构成一个测试套件。</p>
<p>测试用例由it函数构成，它与describe函数一样，接受两个参数：第一个参数是字符串，表示测试用例的标题；第二个参数是函数，用来实现这个测试用例。</p>
<h4 id="BDD风格用例"><a href="#BDD风格用例" class="headerlink" title="BDD风格用例"></a>BDD风格用例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  before(function()&#123;</span><br><span class="line">    console.log(&apos;在测试之前运行&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      expect([1,2,3].indexOf(4)).to.equal(-1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-TDD测试驱动开发"><a href="#3-TDD测试驱动开发" class="headerlink" title="3.TDD测试驱动开发"></a>3.TDD测试驱动开发</h3><hr>
<h4 id="TDD风格"><a href="#TDD风格" class="headerlink" title="TDD风格"></a>TDD风格</h4><p>TDD（测试驱动开发）组织方式是使用测试集（suite）和测试（test）。</p>
<p>每个测试集都有 setup 和 teardown 函数。这些方法会在测试集中的测试执行前执行，它们的作用是为了避免代码重复以及最大限度使得测试之间相互独立。</p>
<p>TDD接口：</p>
<ul>
<li>suite：类似BDD中 describe()</li>
<li>test：类似BDD中 it()</li>
<li>setup：类似BDD中 before()</li>
<li>teardown：类似BDD中 after()</li>
<li>suiteSetup：类似BDD中 beforeEach()</li>
<li>suiteTeardown：类似BDD中 afterEach()<br>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&quot;assert&quot;);</span><br><span class="line"></span><br><span class="line">suite(&apos;Array&apos;, function()&#123;</span><br><span class="line">  setup(function()&#123;</span><br><span class="line">    console.log(&apos;测试执行前执行&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  suite(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    test(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(4));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行mocha：</p>
<p> <strong>mocha –ui tdd *.js</strong> (*表示的是文件名)</p>
<p>PS：mocha 默认是使用 bdd 的接口，所以在这里我们告诉mocha我们用的是tdd.</p>
<h3 id="4-exports风格"><a href="#4-exports风格" class="headerlink" title="4.exports风格"></a>4.exports风格</h3><hr>
<p>exports类似于nodejs里的模块语法,关键字 before, after, beforeEach, 和 afterEach 是特殊保留的，值为对象时是一个测试套件，为函数时则是一个测试用例。</p>
<h4 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  before: function()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;, </span><br><span class="line">  </span><br><span class="line">  &apos;Array&apos;: &#123;</span><br><span class="line">     &apos;#indexOf()&apos;: &#123;</span><br><span class="line">        &apos;当值不存在时应该返回 -1&apos;: function()&#123;</span><br><span class="line">          expect([1,2,3].indexOf(4)).to.equal(-1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="运行-mocha"><a href="#运行-mocha" class="headerlink" title="运行 mocha"></a>运行 mocha</h4><p>mocha –ui exports *.js</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><hr>
<p>我们在前文中讲到了 mocha 提供 TDD（测试驱动开发）、BDD (行为驱动开发) 和 exports 风格的接口。其实还有 QUnit 和 require 风格的接口。</p>
<p>但是比较常用就是 BDD 和 TDD，mocha 默认的也是BDD，且 BDD 是 TDD 的一个专业版本，它指定了从业务需求的角度出发需要哪些单元测试。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-05T06:45:23.000Z"><a href="/2014/06/05/Node.js_测试/Mocha(1)快速开始/">2014-06-05</a></time>
      
      
  
    <h1 class="title"><a href="/2014/06/05/Node.js_测试/Mocha(1)快速开始/">一.快速开始</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-什么是mocha"><a href="#1-什么是mocha" class="headerlink" title="1.什么是mocha"></a>1.什么是mocha</h3><hr>
<p>mocha 是一个功能丰富的javascript测试框架，可以运行在nodejs和浏览器环境，使异步测试变得简单有趣。mocha 串联运行测试，允许灵活和精确地报告结果，同时映射未捕获的异常用来纠正测试用例。</p>
<p>支持TDD/BDD 的 开发方式，结合 should.js/expect/chai/better-assert 断言库，能轻松构建各种风格的测试用例。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>简单</li>
<li>灵活</li>
<li>有趣<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4>通过npm全局安装： npm install -g mocha</li>
</ul>
<h3 id="2-第一个测试用例"><a href="#2-第一个测试用例" class="headerlink" title="2.第一个测试用例"></a>2.第一个测试用例</h3><hr>
<p>我们首先来见识一下mocha最基本的测试用例是怎么的结构,如下。</p>
<p>测试用例：</p>
<p>//模块依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&quot;assert&quot;);</span><br></pre></td></tr></table></figure></p>
<p>//断言条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;Array&apos;, function()&#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function()&#123;</span><br><span class="line">    it(&apos;当值不存在时应该返回 -1&apos;, function()&#123;</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(5));</span><br><span class="line">      assert.equal(-1, [1,2,3].indexOf(0));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例解析：测试用例首先需要引用断言模块，如上文中var assert = require(‘assert’);，代码 assert.equal(-1, [1,2,3].indexOf(5)); 中使用的是assert.equal(actual, expected, [message]) 语法。作用等同于使用’==’进行相等判断。actual为实际值，expected 为期望值。message为返回的信息。</p>
<p>运行 Mocha：$ mocha</p>
<h3 id="3-assert断言"><a href="#3-assert断言" class="headerlink" title="3.assert断言"></a>3.assert断言</h3><hr>
<p>断言（assert）指的是对代码行为的预期。一个测试用例内部，包含一个或多个断言（assert）。</p>
<p>断言会返回一个布尔值，表示代码行为是否符合预期。测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为true，测试用例才会通过。</p>
<p>比如上节示例中的：</p>
<p>assert.equal(-1, [1,2,3].indexOf(5));</p>
<p>assert.equal(-1, [1,2,3].indexOf(0));</p>
<p>实际值（-1）和期望值（[1,2,3].indexOf(5)）是一样的，断言为true，所以这个测试用例成功了。</p>
<p>mocha 允许开发者使用任意的断言库，当这些断言库抛出了一个错误异常时，mocha将会捕获并进行相应处理。这意味着你可以利用如 should.js断言库、 Node.js 常规的 assert 模块或其它类似的断言代码库。以下是众所周知的适用于Node.js或浏览器的断言库：</p>
<ul>
<li>should.js</li>
<li>expect.js</li>
<li>chai.js</li>
<li>better-assert</li>
<li>assert：nodejs原生模块，在前文示例中我们有应用到。</li>
</ul>
<h3 id="4-chai-js断言库"><a href="#4-chai-js断言库" class="headerlink" title="4.chai.js断言库"></a>4.chai.js断言库</h3><hr>
<p>Chai 是一个非常灵活的断言库，它可以让你使用如下三种主要断言方式的任何一种：</p>
<h4 id="assert："><a href="#assert：" class="headerlink" title="assert："></a>assert：</h4><p>这是来自老派测试驱动开发的经典的assert方式。比如：</p>
<p>assert.equal(variable, “value”);</p>
<h4 id="expect："><a href="#expect：" class="headerlink" title="expect："></a>expect：</h4><p>这种链式的断言方式在行为驱动开发中最为常见。比如：</p>
<p>expect(variable).to.equal(“value”);</p>
<h4 id="should："><a href="#should：" class="headerlink" title="should："></a>should：</h4><p>这也是在测试驱动开发中比较常用的方式之一。举例：</p>
<p>variable.should.equal(“value”);</p>
<h3 id="5-expect语法"><a href="#5-expect语法" class="headerlink" title="5.expect语法"></a>5.expect语法</h3><hr>
<p>expect 库应用是非常广泛的，它拥有很好的链式结构和仿自然语言的方法。通常写同一个断言会有几个方法，比如expect(response).to.be(true) 和 expect(response).equal(true)。以下列举了 expect 常用的主要方法：</p>
<ul>
<li>ok ：检查是否为真</li>
<li>true：检查对象是否为真</li>
<li>to.be、to：作为连接两个方法的链式方法</li>
<li>not：链接一个否定的断言，如 expect(false).not.to.be(true)</li>
<li>a/an：检查类型（也适用于数组类型）</li>
<li>include/contain：检查数组或字符串是否包含某个元素</li>
<li>below/above：检查是否大于或者小于某个限定值<br>mocha支持TDD/BDD 的 开发方式，结合 should.js、expect、chai、better-assert 断言库，能轻松构建各种风格的测试用例。这里面有两个知识点，一个是断言库，另一个是 TDD/BDD 。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-07T07:45:23.000Z"><a href="/2014/05/07/Express/express(2)示例准备登陆/">2014-05-07</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/07/Express/express(2)示例准备登陆/">二.准备登陆</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1-安装模板"><a href="#1-安装模板" class="headerlink" title="1.安装模板"></a>1.安装模板</h3><hr>
<p>我们要使用express框架实现一个简单的用户登陆功能，先准备一下相关资源。</p>
<p>在nodejs中使用express框架，它默认的是ejs和jade渲染模板，以ejs模板为例，讲述模板渲染网页模板的基础功能。</p>
<p>ejs模板安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure></p>
<p>1.目录下安装好了之后，如何调用呢，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 指定渲染模板文件的后缀名为ejs</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br></pre></td></tr></table></figure></p>
<p>2.默认ejs模板只支持渲染以ejs为扩展名的文件，可能在使用的时候会觉得它的代码书写方式很不爽还是想用html的形式去书写，该怎么办呢，这时就得去修改模板引擎了，也就会用到express的engine函数。</p>
<p>3.engine注册模板引擎的函数，处理指定的后缀名文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改模板文件的后缀名为html</span><br><span class="line">app.set( &apos;view engine&apos;, &apos;html&apos; );</span><br><span class="line">// 运行ejs模块</span><br><span class="line">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</span><br></pre></td></tr></table></figure></p>
<p>“__express”，ejs模块的一个公共属性，表示要渲染的文件扩展名。</p>
<h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2.静态资源"></a>2.静态资源</h3><hr>
<p>如果要在网页中加载静态文件（css、js、img），就需要另外指定一个存放静态文件的目录，当浏览器发出非HTML文件请求时，服务器端就会到这个目录下去寻找相关文件。</p>
<p>项目目录下添加一个存放静态文件的目录为public。</p>
<p>在public目录下在添加三个存放js、css、img的目录，相应取名为javascripts、stylesheets、images。</p>
<p>然后就可以把相关文件放到相应的目录下了。</p>
<p>比如，浏览器发出如下的样式表请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"/stylesheets/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"screen"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务器端就到public/stylesheets/目录中寻找bootstrap.min.css文件。</p>
<p>有了静态目录文件，我们还得在启动文件里告诉它这个静态文件路径，需要指定一下，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(require(&apos;path&apos;).join(__dirname, &apos;public&apos;)));</span><br></pre></td></tr></table></figure></p>
<p>PS：express.static —— 指定静态文件的查找目录。</p>
<p>使用use函数调用中间件指定express静态访问目录，’public’就是我们我们新建的用来存放静态文件的总目录。</p>
<h3 id="3-添加视图"><a href="#3-添加视图" class="headerlink" title="3.添加视图"></a>3.添加视图</h3><hr>
<p>下面我们就来添加网页模板了，项目中我们会新建一个目录用来单独存放模板文件，这里我们就统一放到根路径上了。</p>
<p>下面开始新建index.html、login.html、home.html三个页面。</p>
<p>1.index.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:400px;width:550px;margin:50px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin-left: 35px;&quot;&gt;</span><br><span class="line">        # 首页</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; style=&quot;margin-top: 90px;margin-left: 60px;&quot;&gt; </span><br><span class="line">            # 欢迎进入首页！</span><br><span class="line">            &lt;div style=&quot;margin-top: 145px;&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; value=&quot;登 陆&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.login.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">... </span><br><span class="line">&lt;div style=&quot;height:300px;width:350px;margin:100px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width:200px;margin:auto;margin-top:50px;&quot;&gt; </span><br><span class="line">        # 用户登录</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; method=&quot;post&quot; &gt;</span><br><span class="line">            &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; style=&quot;margin: 20px 0px;&quot; /&gt;</span><br><span class="line">            &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; /&gt;</span><br><span class="line">            &lt;div style=&quot;margin-top:30px;margin-left:125px;&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; value=&quot;登 陆&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.home.html页面参考内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:400px;width:550px;margin:50px auto;margin-left:auto;border:solid 1px;background: rgb(246, 246, 253);&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin-left: 45px;&quot;&gt;</span><br><span class="line">        # 主页</span><br><span class="line">        &lt;form action=&quot;#&quot;  role=&quot;form&quot; style=&quot;margin-top: 90px;&quot;&gt;</span><br><span class="line">            # 登陆成功！</span><br><span class="line">            &lt;div style=&quot;margin-top: 145px;&quot;&gt;</span><br><span class="line">                &lt;input  type=&quot;button&quot; value=&quot;退 出&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>和静态文件一样，我们也要设置views存放的目录，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设定views变量，意为视图存放的目录</span><br><span class="line">app.set(&apos;views&apos;, __dirname);</span><br></pre></td></tr></table></figure></p>
<p>有了网页模板和指定目录，下面就可以访问它们了。</p>
<h3 id="4-渲染视图"><a href="#4-渲染视图" class="headerlink" title="4.渲染视图"></a>4.渲染视图</h3><hr>
<p>我们要如何对网页模板进行访问呢，这就要用到res对象的render函数了。</p>
<p>render函数，对网页模板进行渲染。</p>
<p>格式：res.render(view, [locals], callback);</p>
<p>参数view就是模板的文件名callback用来处理返回的渲染后的字符串，options、callback可省略，在渲染模板时locals可为其模板传入变量值，在模板中就可以调用所传变量了。</p>
<p>比如渲染我们刚刚添加的index.html页面，我们就可以在app.js中写入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">app.set(&apos;views&apos;, __dirname);</span><br><span class="line">app.set( &apos;view engine&apos;, &apos;html&apos; );</span><br><span class="line">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</span><br><span class="line">app.get(&apos;/&apos;, function(req, res) &#123;</span><br><span class="line">    res.render(&apos;index&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(80);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-url重定向"><a href="#5-url重定向" class="headerlink" title="5.url重定向"></a>5.url重定向</h3><hr>
<h4 id="redirect基本用法"><a href="#redirect基本用法" class="headerlink" title="redirect基本用法"></a>redirect基本用法</h4><p>redirect方法允许网址的重定向，跳转到指定的url并且可以指定status，默认为302方式。</p>
<p>格式：res.redirect([status], url);</p>
<p>例1：使用一个完整的url跳转到一个完全不同的域名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.redirect(&quot;http://www.hubwiz.com&quot;);</span><br></pre></td></tr></table></figure></p>
<p>例2：跳转指定页面，比如登陆页，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.redirect(&quot;login&quot;);</span><br></pre></td></tr></table></figure></p>
<p>后面我们开始实现登陆功能，先试一下redirect重定向</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/9/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/11/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>3</small></li>
  
    <li><a href="/tags/ES6/">ES6</a><small>4</small></li>
  
    <li><a href="/tags/Express/">Express</a><small>2</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Linux性能优化/">Linux性能优化</a><small>2</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/MySQL实战/">MySQL实战</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-IO/">Node.js_IO</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-事件/">Node.js_事件</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-入门/">Node.js_入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js-基础/">Node.js_基础</a><small>6</small></li>
  
    <li><a href="/tags/Node-js-异步/">Node.js_异步</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-模块/">Node.js_模块</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-测试/">Node.js_测试</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-网络/">Node.js_网络</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-进程/">Node.js_进程</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-错误处理和调试/">Node.js_错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/Redis/">Redis</a><small>2</small></li>
  
    <li><a href="/tags/Shell/">Shell</a><small>1</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>3</small></li>
  
    <li><a href="/tags/从0开始学大数据/">从0开始学大数据</a><small>2</small></li>
  
    <li><a href="/tags/区块链/">区块链</a><small>1</small></li>
  
    <li><a href="/tags/数据分析实战/">数据分析实战</a><small>3</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>2</small></li>
  
    <li><a href="/tags/数据结构与算法/">数据结构与算法</a><small>12</small></li>
  
    <li><a href="/tags/程序员的数学基础课/">程序员的数学基础课</a><small>4</small></li>
  
    <li><a href="/tags/网络安全/">网络安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
    <li><a href="/tags/趣谈网络协议/">趣谈网络协议</a><small>7</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>