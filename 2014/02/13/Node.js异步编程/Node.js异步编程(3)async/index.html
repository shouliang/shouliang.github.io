<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>三.async | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="三.async"/>
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-02-13T06:45:23.000Z"><a href="/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/">2014-02-13</a></time>
      
      
  
    <h1 class="title">三.async</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><hr>
<p>async是一个流程控制库，它就像黑夜中的明灯照亮那陷入callback嵌套泥潭的人们。 这么说虽然有些夸张，但是async确实为我们带来了丰富的嵌套解决方案。</p>
<p>项目地址：</p>
<p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a></p>
<p>npm 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install async</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-serires-tasks-callback"><a href="#2-serires-tasks-callback" class="headerlink" title="2.serires(tasks, callback)"></a>2.serires(tasks, callback)</h3><hr>
<p>首先登场的是series函数，它的作用是串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">    one: function(callback)&#123;</span><br><span class="line">        callback(null, 1);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: function(callback)&#123;</span><br><span class="line">        callback(null, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,function(err, results) &#123; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>series函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式，如示例中的参数为数组，返回的results应该是这样的’[1,2]’。</p>
<h3 id="3-waterfall-tasks-callback"><a href="#3-waterfall-tasks-callback" class="headerlink" title="3.waterfall(tasks,[callback])"></a>3.waterfall(tasks,[callback])</h3><hr>
<p>waterfall和series函数有很多相似之处，都是按顺序依次执行一组函数，不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([  </span><br><span class="line">    function(callback)&#123; </span><br><span class="line">      //task1 </span><br><span class="line">      callback(null,1);       </span><br><span class="line">    &#125;,function(data,callback)&#123;</span><br><span class="line">      //task2 </span><br><span class="line">      callback(null,2); </span><br><span class="line">    &#125; </span><br><span class="line">],function(err,results)&#123;  </span><br><span class="line">    console.log(results); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是waterfall的tasks参数只能是数组类型。</p>
<h3 id="4-parallel-tasks-callback"><a href="#4-parallel-tasks-callback" class="headerlink" title="4.parallel(tasks,[callback])"></a>4.parallel(tasks,[callback])</h3><hr>
<p>parallel函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。 传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>tasks参数可以是一个数组或是json对象，和series函数一样，tasks参数类型不同，返回的results格式会不一样。</p>
<h3 id="5-paralleLimit-tasks-limit-callback"><a href="#5-paralleLimit-tasks-limit-callback" class="headerlink" title="5.paralleLimit(tasks,limit,[callback])"></a>5.paralleLimit(tasks,limit,[callback])</h3><hr>
<p>parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.parallelLimit([</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;one&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function(callback)&#123;</span><br><span class="line">        callback(null, &apos;two&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">2,</span><br><span class="line">function(err, results)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-whilst-test-fn-callback"><a href="#6-whilst-test-fn-callback" class="headerlink" title="6.whilst(test,fn,callback)"></a>6.whilst(test,fn,callback)</h3><hr>
<p>相当于while，但其中的异步调用将在完成后才会进行下一次循环。当你需要循环异步的操作的时候，它可以帮助你。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.whilst(</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件。</p>
<p>fn参数就是我们要异步执行的作业，每次fn执行完毕后才会进入下一次循环。</p>
<h3 id="7-doWhilst"><a href="#7-doWhilst" class="headerlink" title="7.doWhilst"></a>7.doWhilst</h3><hr>
<p>相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">async.doWhilst(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 5; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-until-test-fn-callback"><a href="#8-until-test-fn-callback" class="headerlink" title="8.until(test,fn,callback)"></a>8.until(test,fn,callback)</h3><hr>
<p>until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.until(</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-doUntil-fn-test-callback"><a href="#9-doUntil-fn-test-callback" class="headerlink" title="9.doUntil(fn,test,callback)"></a>9.doUntil(fn,test,callback)</h3><hr>
<p>doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var count = 5;</span><br><span class="line">async.doUntil(</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        setTimeout(callback, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123; return count &lt; 0; &#125;,</span><br><span class="line">    function (err) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-forever-fn-errback"><a href="#10-forever-fn-errback" class="headerlink" title="10.forever(fn,errback)"></a>10.forever(fn,errback)</h3><hr>
<p>forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async.forever(</span><br><span class="line">    function(next) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    function(err) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-compose-fn1-fn2…"><a href="#11-compose-fn1-fn2…" class="headerlink" title="11.compose(fn1,fn2…)"></a>11.compose(fn1,fn2…)</h3><hr>
<p>使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值。</p>
<p>我们可以使用compose把异步函数f、g、h，组合成f(g(h()))的形式，通过callback得到返回值，请看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unction fn1(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(n, callback) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(null, n * 3);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var demo = async.compose(fn2, fn1);</span><br><span class="line">demo(4, function (err, result) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-auto-tasks-callback"><a href="#12-auto-tasks-callback" class="headerlink" title="12.auto(tasks,[callback])"></a>12.auto(tasks,[callback])</h3><hr>
<p>用来处理有依赖关系的多个任务的执行。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async.auto(&#123;</span><br><span class="line">    getData: function(callback)&#123;</span><br><span class="line">        callback(null, &apos;data&apos;, &apos;converted to array&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    makeFolder: function(callback)&#123;        </span><br><span class="line">        callback(null, &apos;folder&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback, results)&#123;        </span><br><span class="line">        callback(null, &apos;filename&apos;);</span><br><span class="line">    &#125;],</span><br><span class="line">    emailLink: [&apos;writeFile&apos;, function(callback, results)&#123;</span><br><span class="line">        callback(null, &#123;&apos;file&apos;:results.writeFile, &apos;email&apos;:&apos;user@example.com&apos;&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, function(err, results) &#123;</span><br><span class="line">    console.log(&apos;err = &apos;, err);</span><br><span class="line">    console.log(&apos;results = &apos;, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>示例中writeFile依赖getData和makeFolder,emailLink依赖writeFile。</p>
<h3 id="13-queue-worker-concurrency"><a href="#13-queue-worker-concurrency" class="headerlink" title="13.queue(worker,concurrency)"></a>13.queue(worker,concurrency)</h3><hr>
<p>queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。</p>
<p>它有多个点可供回调，如无等候任务时(empty)、全部执行完时(drain)等。</p>
<p>示例：定义一个queue，其worker数量为2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;worker is processing task: &apos;, task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当最后一个任务交给worker执行时，会调用empty函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.empty = function() &#123;</span><br><span class="line">    console.log(&apos;no more tasks wating&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-apply-function-arguments…"><a href="#14-apply-function-arguments…" class="headerlink" title="14.apply(function,arguments…)"></a>14.apply(function,arguments…)</h3><hr>
<p>apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(callback) &#123; </span><br><span class="line">    test(3, callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用apply改写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async.apply(test, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="15-iterator-tasks"><a href="#15-iterator-tasks" class="headerlink" title="15.iterator(tasks)"></a>15.iterator(tasks)</h3><hr>
<p>将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var iter = async.iterator([</span><br><span class="line">    function() &#123; console.log(&apos;111&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;222&apos;) &#125;,</span><br><span class="line">    function() &#123; console.log(&apos;333&apos;) &#125;</span><br><span class="line">]);</span><br><span class="line">iter();</span><br></pre></td></tr></table></figure>
<p>直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator。</p>
<p>对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null。</p>
<h3 id="16-小结"><a href="#16-小结" class="headerlink" title="16.小结"></a>16.小结</h3><hr>
<p>async模块在流程控制方面给我们带来了比较全面的解决办法，下面我们来回顾一下都有哪几种方案：</p>
<p>串行控制： series、waterfall、compose;</p>
<p>并行控制：</p>
<p>parallel、parallelLimit、queue;</p>
<p>循环控制：<br>whilst、doWhilst、until、doUntil、forever;</p>
<p>其他控制：<br>apply、applyEach、iterator、auto;</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/异步编程/">异步编程</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=shouliang0816";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://shouliang.github.io/2014/02/13/Node.js异步编程/Node.js异步编程(3)async/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/Mocha/">Mocha</a><small>4</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js入门/">Node.js入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js错误处理-调试/">Node.js错误处理&amp;调试</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/异步编程/">异步编程</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>