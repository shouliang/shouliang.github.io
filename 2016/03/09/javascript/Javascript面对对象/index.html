<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Javascipt面对对象 | shouliang&#39;s blog</title>
  <meta name="author" content="shouliang">
  
  <meta name="description" content="Node">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Javascipt面对对象"/>
  <meta property="og:site_name" content="shouliang&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="shouliang&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">shouliang&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-09T06:45:23.000Z"><a href="/2016/03/09/javascript/Javascript面对对象/">2016-03-09</a></time>
      
      
  
    <h1 class="title">Javascipt面对对象</h1>
  

    </header>
    <div class="entry">
      
        <p>面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式，主要包括模块化、多态、和封装几种技术。 对JavaScript而言，其核心是支持面向对象的，同时它也提供了强大灵活的基于原型的面向对象编程能力。 本文将会深入的探讨有关使用JavaScript进行面向对象编程的一些核心基础知识，包括对象的创建，继承机制， 最后还会简要的介绍如何借助ES6提供的新的类机制重写传统的JavaScript面向对象代码。</p>
<h3 id="面向对象的几个概念"><a href="#面向对象的几个概念" class="headerlink" title="面向对象的几个概念"></a>面向对象的几个概念</h3><p>在进入正题前，先了解传统的面向对象编程（例如Java）中常会涉及到的概念，大致可以包括：</p>
<ul>
<li>类：定义对象的特征。它是对象的属性和方法的模板定义。</li>
<li>对象（或称实例）：类的一个实例。</li>
<li>属性：对象的特征，比如颜色、尺寸等。</li>
<li>方法：对象的行为，比如行走、说话等。</li>
<li>构造函数：对象初始化的瞬间被调用的方法。</li>
<li>继承：子类可以继承父类的特征。例如，猫继承了动物的一般特性。</li>
<li>封装：一种把数据和相关的方法绑定在一起使用的方法。</li>
<li>抽象：结合复杂的继承、方法、属性的对象能够模拟现实的模型。</li>
<li>多态：不同的类可以定义相同的方法或属性。<br>在JavaScript的面向对象编程中大体也包括这些。不过在称呼上可能稍有不同，例如，JavaScript中没有原生的“类”的概念， 而只有对象的概念。因此，随着你认识的深入，我们会混用对象、实例、构造函数等概念。</li>
</ul>
<h3 id="对象（类）的创建"><a href="#对象（类）的创建" class="headerlink" title="对象（类）的创建"></a>对象（类）的创建</h3><p>在JavaScript中，我们通常可以使用构造函数来创建特定类型的对象。诸如Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。 此外，我们也可以创建自定义的构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br></pre></td></tr></table></figure></p>
<p>按照惯例，构造函数始终都应该以一个大写字母开头（和Java中定义的类一样），普通函数则小写字母开头。 要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象（实例）</li>
<li>将构造函数的作用域赋给新对象（也就是重设了this的指向，this就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>在上面的例子中，我们创建了Person的两个实例person1和person2。 这两个对象默认都有一个constructor属性，该属性指向它们的构造函数Person，也就是说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.constructor == Person);  //true</span><br><span class="line">console.log(person2.constructor == Person);  //true</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义对象的类型检测"><a href="#自定义对象的类型检测" class="headerlink" title="自定义对象的类型检测"></a>自定义对象的类型检测</h3><p>我们可以使用instanceof操作符进行类型检测。我们创建的所有对象既是Object的实例，同时也是Person的实例。 因为所有的对象都继承自Object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1 instanceof Object);  //true</span><br><span class="line">console.log(person1 instanceof Person);  //true</span><br><span class="line">console.log(person2 instanceof Object);  //true</span><br><span class="line">console.log(person2 instanceof Person);  //true</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>我们不建议在构造函数中直接定义方法，如果这样做的话，每个方法都要在每个实例上重新创建一遍，这将非常损耗性能。 ——不要忘了，ECMAScript中的函数是对象，每定义一个函数，也就实例化了一个对象。</p>
<p>幸运的是，在ECMAScript中，我们可以借助原型对象来解决这个问题。</p>
<h3 id="借助原型模式定义对象的方法"><a href="#借助原型模式定义对象的方法" class="headerlink" title="借助原型模式定义对象的方法"></a>借助原型模式定义对象的方法</h3><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向该函数的原型对象， 该对象包含了由特定类型的所有实例共享的属性和方法。也就是说，我们可以利用原型对象来让所有对象实例共享它所包含的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line">// 通过原型模式来添加所有实例共享的方法</span><br><span class="line">// sayName() 方法将会被Person的所有实例共享，而避免了重复创建</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br><span class="line">console.log(person1.sayName === person2.sayName); // true</span><br><span class="line">person1.sayName(); // Weiwei</span><br><span class="line">person2.sayName(); // Lily</span><br></pre></td></tr></table></figure></p>
<p>正如上面的代码所示，通过原型模式定义的方法sayName()为所有的实例所共享。也就是， person1和person2访问的是同一个sayName()函数。同样的，公共属性也可以使用原型模式进行定义。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Chinese (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Chinese.prototype.country = &apos;China&apos;; // 公共属性，所有实例共享</span><br></pre></td></tr></table></figure></p>
<p>当我们new Person()时，返回的Person实例会结合构造函数中定义的属性、行为和原型中定义的属性、行为， 生成最终属于Person实例的属性和行为。</p>
<p>构造函数中定义的属性和行为的优先级要比原型中定义的属性和行为的优先级高，如果构造函数和原型中定义了同名的属性或行为， 构造函数中的属性或行为会覆盖原型中的同名的属性或行为。</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>现在我们来深入的理解一下什么是原型对象。</p>
<p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 也就是说：Person.prototype.constructor指向Person构造函数。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。 当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中称这个指针为[[Prototype]]， 在Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>（目前已被废弃）；而在其他实现中，这个属性对脚本则是完全不可见的。 要注意，这个链接存在于实例与构造函数的原型对象之间，而不是实例与构造函数之间。</p>
<p>这三者关系的示意图如下：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/imgprototype-graph-1.jpg" alt=""></p>
<p>上图展示了Person构造函数、Person的原型对象以及Person现有的两个实例之间的关系。</p>
<ul>
<li>Person.prototype指向了原型对象</li>
<li>Person.prototype.constructor又指回了Person构造函数</li>
<li>Person的每个实例person1和person2都包含一个内部属性（通常为<strong>proto</strong>），person1.<strong>proto</strong>和person2.<strong>proto</strong>指向了原型对象</li>
</ul>
<h3 id="查找对象属性"><a href="#查找对象属性" class="headerlink" title="查找对象属性"></a>查找对象属性</h3><p>从上图我们发现，虽然Person的两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。 这是通过查找对象属性的过程来实现的。</p>
<ol>
<li>搜索首先从对象实例本身开始（实例person1有sayName属性吗？——没有）</li>
<li>如果没找到，则继续搜索指针指向的原型对象（person1.<strong>proto</strong>有sayName属性吗？——有）<br>这也是多个对象实例共享原型所保存的属性和方法的基本原理。</li>
</ol>
<p>注意，如果我们在对象的实例中重写了某个原型中已存在的属性，则该实例属性会屏蔽原型中的那个属性。 此时，可以使用delete操作符删除实例上的属性。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>根据ECMAScript标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。 这个等同于 JavaScript 的 <strong>proto</strong> 属性（现已弃用，因为它不是标准）。 从ECMAScript 5开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。</p>
<p>其中Object.getPrototypeOf()在所有支持的实现中，这个方法返回[[Prototype]]的值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ === Object.getPrototypeOf(person1); // true</span><br><span class="line">Object.getPrototypeOf(person1) === Person.prototype; // true</span><br></pre></td></tr></table></figure></p>
<p>也就是说，Object.getPrototypeOf(p1)返回的对象实际就是这个对象的原型。 这个方法的兼容性请参考该链接。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>要取得对象上所有可枚举的实例属性，可以使用ES5中的Object.keys()方法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(p1); // [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;]</span><br></pre></td></tr></table></figure></p>
<p>此外，如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyName()方法。</p>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>在上面的代码中，如果我们要添加原型属性和方法，就要重复的敲一遍Person.prototype。为了减少这个重复的过程， 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写整个原型对象</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  </span><br><span class="line">  // 这里务必要重新将构造函数指回Person构造函数，否则会指向这个新创建的对象</span><br><span class="line">  constructor: Person, // Attention!</span><br><span class="line"></span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var person2 = new Person(&apos;Lily&apos;, 25, &apos;Doctor&apos;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName === person2.sayName); // true</span><br><span class="line"></span><br><span class="line">person1.sayName();  // Weiwei</span><br><span class="line">person2.sayName();  // Lily</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。 注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性设置为true。默认情况下，原生的constructor属性是不可枚举的。 你可以使用Object.defineProperty()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 重设构造函数，只适用于ES5兼容的浏览器</span><br><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性， 而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方的引用， 最大限度的节省了内存。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>大多的面向对象语言都支持两种继承方式：接口继承和实现继承。ECMAScript只支持实现继承，而且其实现继承主要依靠原型链来实现。</p>
<p>前面我们知道，JavaScript中实例的属性和行为是由构造函数和原型两部分共同组成的。如果我们想让Child继承Father， 那么我们就需要把Father构造函数和原型中属性和行为全部传给Child的构造函数和原型。</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>使用原型链作为实现继承的基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。首先我们先回顾一些基本概念：</p>
<p>每个构造函数都有一个原型对象（prototype）<br>原型对象包含一个指向构造函数的指针（constructor）<br>实例都包含一个指向原型对象的内部指针（[[Prototype]]）<br>如果我们让原型对象等于另一个类型的实现，结果会怎么样？显然，此时的原型对象将包含一个指向另一个原型的指针， 相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立， 如此层层递进，就构成了实例与原型的链条。 更详细的内容可以参考这个链接。 先看一个简单的例子，它演示了使用原型链实现继承的基本框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line">  this.fatherValue = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getFatherValue = function () &#123;</span><br><span class="line">  console.log(this.fatherValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">  this.childValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现继承：继承自Father</span><br><span class="line">Child.prototype = new Father();</span><br><span class="line"></span><br><span class="line">Child.prototype.getChildValue = function () &#123;</span><br><span class="line">  console.log(this.childValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new Child();</span><br><span class="line">instance.getFatherValue(); // true</span><br><span class="line">instance.getChildValue();  // false</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，原型链继承的核心语句是Child.prototype = new Father()，它实现了Child对Father的继承， 而继承是通过创建Father的实例，并将该实例赋给Child.prototype实现的。</p>
<p>实现的本质是重写原型对象，代之以一个新类型的实例。也就是说，原来存在于Father的实例中的所有属性和方法， 现在也存在于Child.prototype中了。</p>
<p>这个例子中的实例以及构造函数和原型之间的关系如下图所示：</p>
<p><img src="http://7xq1il.com1.z0.glb.clouddn.com/imgprototype-chain-inheritance.jpg" alt=""></p>
<p>在上面的代码中，我们没有使用Child默认提供的原型，而是给它换了一个新原型；这个新原型就是Father的实例。 于是，新原型不仅具有了作为一个Father的实例所拥有的全部属性和方法。而且其内部还有一个指针[[Prototype]]，指向了Father的原型。</p>
<ul>
<li>instance指向Child的原型对象</li>
<li>Child的原型对象指向Father的原型对象</li>
<li>getFatherValue()方法仍然还在Father.prototype中</li>
<li>但是，fatherValue则位于Child.prototype中</li>
<li>instance.constructor现在指向的是Father<br>因为fatherValue是一个实例属性，而getFatherValue()则是一个原型方法。既然Child.prototype现在是Father的实例， 那么fatherValue当然就位于该实例中。</li>
</ul>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。例如，instance.getFatherValue()会经历三个搜索步骤：</p>
<ol>
<li>搜索实例</li>
<li>搜索Child.prototype</li>
<li>搜索Father.prototype</li>
</ol>
<h3 id="别忘了Object"><a href="#别忘了Object" class="headerlink" title="别忘了Object"></a>别忘了Object</h3><p>所有的函数都默认原型都是Object的实例，因此默认原型都会包含一个内部指针[[Prototype]]，指向Object.prototype。 这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以， 我们说上面例子展示的原型链中还应该包括另外一个继承层次。关于Object的更多内容，可以参考这篇博客。</p>
<p>也就是说，Child继承了Father，而Father继承了Object。当调用了instance.toString()时， 实际上调用的是保存在Object.prototype中的那个方法。</p>
<h3 id="原型链继承的问题"><a href="#原型链继承的问题" class="headerlink" title="原型链继承的问题"></a>原型链继承的问题</h3><p>首先是顺序，一定要先继承父类，然后为子类添加新方法。</p>
<p>其次，使用原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line">  this.fatherValue = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getFatherValue = function () &#123;</span><br><span class="line">  console.log(this.fatherValue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">  this.childValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承了Father</span><br><span class="line">// 此时的原型链为 Child -&gt; Father -&gt; Object</span><br><span class="line">Child.prototype = new Father();</span><br><span class="line"></span><br><span class="line">// 使用字面量添加新方法，会导致上一行代码无效</span><br><span class="line">// 此时我们设想的原型链被切断，而是变成 Child -&gt; Object</span><br><span class="line">// 所以我们不推荐这么写了</span><br><span class="line">Child.prototype = &#123;</span><br><span class="line">  getChildValue: function () &#123;</span><br><span class="line">    console.log(this.childValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new Child();</span><br><span class="line">instance.getChildValue();  // false</span><br><span class="line">instance.getFatherValue(); // error!</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们连续两次修改了Child.prototype的值。由于现在的原型包含的是一个Object的实例， 而非Father的实例，因此我们设想中的原型链已经被切断——Child和Father之间已经没有关系了。</p>
<p>最后，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下， 给超类型的构造函数传递参数。因此，我们很少单独使用原型链。</p>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>借用构造函数（constructor stealing）的基本思想如下：即在子类构造函数的内部调用超类型构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Father (name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">  // 继承了Father，同时传递了参数</span><br><span class="line">  // 之所以这么做，是为了获得Father构造函数中的所有属性和方法</span><br><span class="line">  // 之所以用call，是为了修正Father内部this的指向</span><br><span class="line">  Father.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Child(&quot;weiwei&quot;);</span><br><span class="line">instance1.colors.push(&apos;black&apos;);</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line">console.log(instance1.name); // weiwei</span><br><span class="line"></span><br><span class="line">var instance2 = new Child(&quot;lily&quot;);</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line">console.log(instance2.name); // lily</span><br></pre></td></tr></table></figure></p>
<p>为了确保Father构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h3 id="借用构造函数的缺点"><a href="#借用构造函数的缺点" class="headerlink" title="借用构造函数的缺点"></a>借用构造函数的缺点</h3><p>同构造函数一样，无法实现方法的复用（所有的方法会被重复创建一份）。</p>
<h3 id="组合使用原型链和借用构造函数"><a href="#组合使用原型链和借用构造函数" class="headerlink" title="组合使用原型链和借用构造函数"></a>组合使用原型链和借用构造函数</h3><p>通常，我们会组合使用原型链继承和借用构造函数来实现继承。也就是说，使用原型链实现对原型属性和方法的继承， 而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 我们改造最初的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 父类构造函数</span><br><span class="line">function Person (name, age, job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类方法</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// --------------</span><br><span class="line"></span><br><span class="line">// 子类构造函数</span><br><span class="line">function Student (name, age, job, school) &#123;</span><br><span class="line">  // 继承父类的所有实例属性（获得父类构造函数中的属性）</span><br><span class="line">  Person.call(this, name, age, job);</span><br><span class="line">  this.school = school; // 添加新的子类属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类的原型方法（获得父类原型链上的属性和方法）</span><br><span class="line">Student.prototype = new Person();</span><br><span class="line"></span><br><span class="line">// 新增的子类方法</span><br><span class="line">Student.prototype.saySchool = function () &#123;</span><br><span class="line">  console.log(this.school);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Weiwei&apos;, 27, &apos;Student&apos;);</span><br><span class="line">var student1 = new Student(&apos;Lily&apos;, 25, &apos;Doctor&apos;, &quot;Southeast University&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName === student1.sayName); // true</span><br><span class="line"></span><br><span class="line">person1.sayName();  // Weiwei</span><br><span class="line">student1.sayName(); // Lily</span><br><span class="line">student1.saySchool(); // Southeast University</span><br></pre></td></tr></table></figure></p>
<p>组合集成避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。 而且，instanceof和isPropertyOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="组合继承的改进版：使用Object-create"><a href="#组合继承的改进版：使用Object-create" class="headerlink" title="组合继承的改进版：使用Object.create()"></a>组合继承的改进版：使用Object.create()</h3><p>在上面，我们继承父类的原型方法使用的是Student.prototype = new Person()。 这样做有很多的问题。 改进方法是使用ES5中新增的Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用create()方法传入的第一个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype.constructor); // [Function: Person]</span><br><span class="line"></span><br><span class="line">// 设置 constructor 属性指向 Student</span><br><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure></p>
<p>关于Object.create()的实现，我们可以参考一个简单的polyfill：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createObject(proto) &#123;</span><br><span class="line">    function F() &#123; &#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage:</span><br><span class="line">Student.prototype = createObject(Person.prototype);</span><br><span class="line">从本质上讲，createObject()对传入其中的对象执行了一次浅复制。</span><br></pre></td></tr></table></figure>
<h3 id="ES6中的面向对象语法"><a href="#ES6中的面向对象语法" class="headerlink" title="ES6中的面向对象语法"></a>ES6中的面向对象语法</h3><p>ES6中引入了一套新的关键字用来实现class。 但它并不是映入了一种新的面向对象继承模式。JavaScript仍然是基于原型的，这些新的关键字包括class、 constructor、 static、 extends、 和super。</p>
<p>class关键字不过是提供了一种在本文中所讨论的基于原型模式和构造器模式的面向对象的继承方式的语法糖(syntactic sugar)。</p>
<p>对前面的代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor (name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line"></span><br><span class="line">  constructor (name, age, school) &#123;</span><br><span class="line">    super(name, age, &apos;Student&apos;);</span><br><span class="line">    this.school = school;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  saySchool () &#123;</span><br><span class="line">    console.log(this.school);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu1 = new Student(&apos;weiwei&apos;, 20, &apos;Southeast University&apos;);</span><br><span class="line">var stu2 = new Student(&apos;lily&apos;, 22, &apos;Nanjing University&apos;);</span><br><span class="line"></span><br><span class="line">stu1.sayName(); // weiwei</span><br><span class="line">stu1.saySchool(); // Southeast University</span><br><span class="line"></span><br><span class="line">stu2.sayName(); // lily</span><br><span class="line">stu2.saySchool(); // Nanjing University</span><br></pre></td></tr></table></figure>
<h3 id="类：class"><a href="#类：class" class="headerlink" title="类：class"></a>类：class</h3><p>是JavaScript中现有基于原型的继承的语法糖。ES6中的类并不是一种新的创建对象的方法，只不过是一种“特殊的函数”， 因此也包括类表达式和类声明， 但需要注意的是，与函数声明不同的是，类声明不会被提升。 参考链接</p>
<h3 id="类构造器：constructor"><a href="#类构造器：constructor" class="headerlink" title="类构造器：constructor"></a>类构造器：constructor</h3><p>constructor()方法是有一种特殊的和class一起用于创建和初始化对象的方法。注意，在ES6类中只能有一个名称为constructor的方法， 否则会报错。在constructor()方法中可以调用super关键字调用父类构造器。如果你没有指定一个构造器方法， 类会自动使用一个默认的构造器。参考链接</p>
<h3 id="类的静态方法：static"><a href="#类的静态方法：static" class="headerlink" title="类的静态方法：static"></a>类的静态方法：static</h3><p>静态方法就是可以直接使用类名调用的方法，而无需对类进行实例化，当然实例化后的类也无法调用静态方法。 静态方法常被用于创建应用的工具函数。参考链接</p>
<h3 id="继承父类：extends"><a href="#继承父类：extends" class="headerlink" title="继承父类：extends"></a>继承父类：extends</h3><p>extends关键字可以用于继承父类。使用extends可以扩展一个内置的对象（如Date），也可以是自定义对象，或者是null。</p>
<h3 id="关键字：super"><a href="#关键字：super" class="headerlink" title="关键字：super"></a>关键字：super</h3><p>super关键字用于调用父对象上的函数。 super.prop和super[expr]表达式在类和对象字面量中的任何方法定义中都有效。</p>
<p>super([arguments]); // 调用父类构造器<br>super.functionOnParent([arguments]); // 调用父类中的方法<br>如果是在类的构造器中，需要在this关键字之前使用。参考链接</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文对JavaScript的面向对象机制进行了较为深入的解读，尤其是构造函数和原型链方式实现对象的创建、继承、以及实例化。 此外，本文还简要介绍了如在ES6中编写面向对象代码。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/Javascript/">Javascript</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=shouliang0816";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://shouliang.github.io/2016/03/09/javascript/Javascript面对对象/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shouliang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angular/">Angular</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>7</small></li>
  
    <li><a href="/tags/Gulp/">Gulp</a><small>4</small></li>
  
    <li><a href="/tags/Javascript/">Javascript</a><small>2</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>2</small></li>
  
    <li><a href="/tags/Mongoose/">Mongoose</a><small>6</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-IO/">Node.js_IO</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-事件/">Node.js_事件</a><small>4</small></li>
  
    <li><a href="/tags/Node-js-入门/">Node.js_入门</a><small>9</small></li>
  
    <li><a href="/tags/Node-js-异步编程/">Node.js_异步编程</a><small>3</small></li>
  
    <li><a href="/tags/Node-js-模块/">Node.js_模块</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-测试/">Node.js_测试</a><small>5</small></li>
  
    <li><a href="/tags/Node-js-网络/">Node.js_网络</a><small>1</small></li>
  
    <li><a href="/tags/Node-js-进程/">Node.js_进程</a><small>2</small></li>
  
    <li><a href="/tags/Node-js-错误处理和调试/">Node.js_错误处理和调试</a><small>5</small></li>
  
    <li><a href="/tags/Unix/">Unix</a><small>3</small></li>
  
    <li><a href="/tags/express/">express</a><small>2</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/存储/">存储</a><small>3</small></li>
  
    <li><a href="/tags/安全/">安全</a><small>8</small></li>
  
    <li><a href="/tags/计算机网络/">计算机网络</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shouliang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>